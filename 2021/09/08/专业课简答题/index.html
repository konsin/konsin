<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="Konsin个人学习笔记记录小站" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>专业课简答题 |  不想当咸鱼王</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-专业课简答题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  专业课简答题
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/08/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AE%80%E7%AD%94%E9%A2%98/" class="article-date">
  <time datetime="2021-09-08T07:59:58.000Z" itemprop="datePublished">2021-09-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">33 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><ol>
<li>操作系统的作用? <ol>
<li>操作系统是用户与计算机硬件系统之间的接口. </li>
<li>操作系统是计算机资源的管理者 </li>
<li>操作系统是计算机工作流程的组织者 </li>
<li>操作系统实现了对计算机资源的抽象<br />{1. 覆盖了一层I/O设备管理软件,隐藏I/O细节;<br />2.在隐藏I/O细节的基础上覆盖了一层用于文件管理的软件} </li>
</ol>
</li>
<li><strong>操作系统具有那几大特征,他们之间的关系?</strong><br />操作系统有:并发、共享、虚拟、异步 四大特征 <ol>
<li>并发和共享是操作系统最基本的特征，为了提高计算机资源利用率，OS必然要采用多道技术，使多个程序共享系统的资源，并发的执行</li>
<li>并发和共享互为存在的条件。1. 资源的共享是以程序的并发执行为条件的。2.若系统不能对资源共享实施有效的管理，也必将影响到程序的并发</li>
<li>虚拟性以并发和共享为前提</li>
<li>异步性是并发和共享的必然结果，多个并发进行共享资源会使得每个进程的运行过程受到其他进程制约</li>
</ol>
</li>
<li>什么是多道技术，OS引入多道的目的<br />多道程序技术是指在内存中同时存放若干个作业，并使它们共享系统资源且并发运行的技术。<br />OS引入多道技术：1.提高CPU利用率；2.提高内存和I/O设备利用率；3.增加系统吞吐量 </li>
<li>推动批处理系统和分时系统形成和发展的主要动力是什么？<br />批处理系统：不断提高系统资源利用率和提高系统吞吐量<br />分时系统：为了更好地满足用户地需要 </li>
<li>实现分时系统地关键问题是使用户能与自己的作业进行交互，为此需要引入：1. 缓冲区暂存用户键入的命令和输出的结果；2. 规定每个程序每次只能运行一个时间片 </li>
<li>比较分时系统与实时系统<br />分时系统：多路性、独立性、及时性、<strong>交互性</strong><br />实时系统：多路性、独立性、<strong>及时性</strong>、交互性、可靠性 <ol>
<li>从交互性方面：交互性是分时系统的关键问题，用户可以进行广泛的人机交互；实时系统的交互性具有很大的局限性。</li>
<li>从及时性方面：分时系统的及时性是指用户能在很短时间内获得系统的响应，2-3秒；及时性是实时系统的关键问题，由被控制对象所要求的开始截止时间和完成截止始键决定，毫秒级</li>
<li>从可靠性方面：可靠性是实时系统另一个关键问题。分时系统的可靠性要求较低</li>
</ol>
</li>
<li>批处理系统、分时系统、实时系统各有什么特点？ <ol>
<li>批处理系统：用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行</li>
<li>分时系统：可让多个用户同时使用计算机，人机交互性强，具有每个用户独立使用计算机的独占性，系统响应及时</li>
<li>实时操作系统能对控制对象做出及时反应，可靠性高，响应及时，但资源利用率低</li>
</ol>
</li>
</ol>
<h2 id="第二章-进程控制与描述"><a href="#第二章-进程控制与描述" class="headerlink" title="第二章 进程控制与描述"></a>第二章 进程控制与描述</h2><ol>
<li><p>进程控制块PCB（进程存在的唯一标志）：<br />作用：1. 进程控制块时操作系统用来描述和管理进程的数据结构；2.使一个在多道环境下不能独立运行的程序成为一个能独立运行的基本单位； 3.记录系统所需的用于描述进程当前情况机控制进程运行的全部信息。<br />在进程整个生命周期中，系统总是通过PCB来对进程进行控制和管理，系统依靠PCB感知进程的存在。  </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进程标识符</span><br><span class="line">处理机状态：主要是寄存器的内容组成，用于CPU切换时保存线程信息和恢复现场信息。</span><br><span class="line">进程调度信息：进程状态、优先级、等待和使用CPU的时间等，用于进程调度和对换。</span><br><span class="line">进程控制信息：地址，进程同步和通信信息，资源清单，队列指针等</span><br></pre></td></tr></table></figure></li>
<li><p>进程创建的过程： </p>
<ol>
<li>申请空PCB：先从PCB集合中申请一个空闲的PCB</li>
<li>分配资源：在为新进程分配内存等资源</li>
<li>初始化PCB：根据父进程提供的参数和分配到的资源的情况来对PCB进行初始化</li>
<li>插入就绪队列</li>
</ol>
</li>
<li><p>进程同步机制原则：</p>
<ol>
<li>空闲让进，临界区空闲，允许一个请求进程立即进入临界区</li>
<li>忙则等待，已有进程进入临界区，其他请求进入的进程必须等待</li>
<li>有限等待，应保证请求进程在有限时间内进入临界区</li>
<li>让权等待 ，当进程不能进入临界区，应立即释放处理机，防止忙等</li>
</ol>
</li>
<li><p>进程通信的类型：<br />共享存储器系统，管道通信，消息传递系统，客户机-服务器系统 </p>
</li>
<li><p>消息缓冲队列机制发送原语和接收原语：</p>
</li>
</ol>
<p>原理：消息缓冲队列通信机制通过内存中公用的消息缓冲区进行进程通信，属于直接通信方式。发送进程发送消息时，需申请一个消息缓冲区，并把自己的进程标示符和有关消息的内容填入消息缓冲区，然后将其插入到接收进程的消息缓冲队列中，接收进程接收消息时需从自己的消息缓冲队列中摘下一个消息缓冲区，取出其中的消息，然后消息缓冲区归还给系统。</p>
<p>PCB需要添加：mq（消息缓冲队列队首指针）；mutex（消息缓冲队列互斥信号量）；sm（消息缓冲队列资源信号量）。    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span>&#123;</span> <span class="comment">//消息缓冲区数据结构</span></span><br><span class="line">    <span class="type">int</span> sender; <span class="comment">//发送者进程标识符</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//消息长度</span></span><br><span class="line">    <span class="type">char</span> *text；<span class="comment">//消息正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个消息缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send</span><span class="params">(receiver a)</span>&#123; <span class="comment">//发送原语</span></span><br><span class="line">     getbuf(a.size, i); <span class="comment">//根据a.size申请缓冲区</span></span><br><span class="line">     i.sender = a.sender; <span class="comment">//将发送区a中的信息复制到缓冲区i</span></span><br><span class="line">     i.size = a.size;</span><br><span class="line">     copy(i.text, a.text);</span><br><span class="line">     i,next = <span class="number">0</span>;</span><br><span class="line">     getid(PCBset, receiver, j)<span class="comment">//获得接收程序j的PCB</span></span><br><span class="line">     wait(j.mutex)</span><br><span class="line">     insert(&amp;j.mq, i) <span class="comment">//将消息缓冲区i插入消息队列</span></span><br><span class="line">     signal(j.mutex)</span><br><span class="line">     signal(j.sm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">receive</span><span class="params">(b)</span> &#123; <span class="comment">//接收原语</span></span><br><span class="line">    j = internal_name; <span class="comment">//获取当前进行的PCB</span></span><br><span class="line">    wait(j.sm);</span><br><span class="line">    wait(j.mutex);</span><br><span class="line">    remove(j.mq, i); <span class="comment">//移出消息队列第一个消息</span></span><br><span class="line">    signal(j.mutex); </span><br><span class="line">    b.sender = i.sender; <span class="comment">//将缓冲区i中信息复制到接收区b</span></span><br><span class="line">    b.size = i.size;</span><br><span class="line">    copy(b.text, i.text);</span><br><span class="line">    releasebuf(i); <span class="comment">//释放消息缓冲区i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>为什么要引入进程？<br />为了实现多个程序的并发执行，提高资源利用率和系统吞吐量。<br />传统的程序在并发执行时结果不可再现。<br />不利影响：管理进程需要付出一定的代价，包括进程控制块，进程间切换，同步，通信等。 </p>
</li>
<li><p>进程和程序的异同：<br />进程与程序紧密相关又完全不同。 </p>
<ol>
<li>进程实体中除了程序段和数据段之外还包含一个数据结构PCB </li>
<li>进程是动态的，是程序的一次执行过程。<br />程序是静态的，是一组指令的有序集合 </li>
<li>多个进程实体可同时放在内存中并发执行，这是引入进程的目的<br />程序的并发具有不可再现性，不能正确的并发。 </li>
<li>进程是一个能够独立运行、独立分配资源和独立接收调度的基本单位。程序在多道程序环境下不能独立运行（没有PCB） </li>
<li>进程与程序不一一对应；同一程序多次运行产生多个进程；同一程序一次执行也可产生多个进程（fork调用产生子进程）；一个进程在生命周期不同时候可以执行不同的程序。 </li>
</ol>
</li>
<li><p>进程和线程的异同 </p>
<ol>
<li>调度性：引入线程后，线程成为调度和分派的基本单位，进程只是拥有资源的基本单位</li>
<li>并发性：都可并发</li>
<li>拥有资源：拥有资源的基本单位是进程。线程只有一点必不可少的资源，但可共享其隶属进程的资源。</li>
<li>独立性：进程可独立的申请资源和运行，而同一进程下的线程共享进程的地址空间和其他资源，独立性较低。</li>
<li>开销：创建撤销进程时，OS都要为之分配和回收资源。开销远大于线程。</li>
<li>传统的进程只能运行在一个处理机上，多线程的进程则可以运行在多个处理机上，并发效果更好。</li>
</ol>
</li>
<li><p>进程状态转换  </p>
<table>
<thead>
<tr>
<th>状态转换</th>
<th>引起转换的事件</th>
</tr>
</thead>
<tbody><tr>
<td>就绪-执行</td>
<td>CPU调度</td>
</tr>
<tr>
<td>执行-就绪</td>
<td>时间片完，更高优先级进程抢占</td>
</tr>
<tr>
<td>执行-阻塞</td>
<td>等待I/O或临界资源</td>
</tr>
<tr>
<td>阻塞-就绪</td>
<td>等待的事件完成</td>
</tr>
</tbody></table>
</li>
<li><p>内核支持线程和用户级线程：<br />内核支持线程是在内核支持下实现的，即每个线程的线程控制块设置在内核中。用户级线程仅存在于用户空间中，每个线程控制块设置在用户空间中，所有对线程的操作也在用户空间中完成，无需内核帮助。 </p>
</li>
</ol>
<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><ol>
<li><p>处理机调度算法的目标</p>
<ol>
<li>资源利用率：为提高资源利用率，应使系统中的处理机和其他所有资源都尽可能保持忙碌</li>
<li>公平性：应使进程获得合理的CPU时间，不会发生饥饿现象。</li>
<li>平衡性：尽可能保持系统资源使用的平衡性</li>
<li>策略强制执行</li>
</ol>
</li>
<li><p>处理机调度的层次</p>
<ol>
<li>高级调度：作业调度，把作业从后备队列拿出，分派资源后建立进程中，使之可以获得处理机</li>
<li>中级调度：内存调度，把外存中的就绪进程调入内存，插入就绪队列</li>
<li>低级调度：进程调度，最基本的调度。决定就绪队列的进程获得处理机</li>
</ol>
</li>
<li><p>调度的方式</p>
<ol>
<li>非剥夺（非抢占）方式：一旦分配就占有资源直到阻塞或结束。优点是简单，系统开销小</li>
<li>剥夺（抢占）方式：当前进程所占有的资源可被其他进程夺走。<ol>
<li>优点：更高的系统吞吐率和响应效率</li>
<li>原则：优先权、短进程、时间片原则</li>
</ol>
</li>
</ol>
</li>
<li><p>引起进程调度的因素：</p>
<ol>
<li>正在执行的进程正常终止或异常终止</li>
<li>正在执行的进程因某种原因而阻塞</li>
<li>引入时间片的系统中，时间片完</li>
<li>抢占调度方式中，有更高优先权的进程</li>
</ol>
</li>
<li><p>调度的算法的类型及比较：</p>
<p> 有先来先服务、短作业优先、优先级调度、高响应比优先、时间片轮转、多级反馈队列等</p>
<ol>
<li>先来先服务、短作业优先无法保证及时接收和处理问题，无法保证在规定时间间隔内响应每个用户需求，也不能达到实时系统的及时性需求。</li>
<li>优先级调度算法，按优先级进行调度，对于更紧急的任务予以更高优先级，适合实时操作系统</li>
<li>高响应比优先，时间片轮转，多级反馈队列能保证每个任务在一定时间内分配到时间片，适合分时系统</li>
</ol>
</li>
<li><p>低级调度主要功能</p>
<p> 低级调度用于决定就绪队列中哪个进程获得处理机，并由分派程序把处理机分配给该进程</p>
<ol>
<li>保存当前进程的处理机现场信息到PCB</li>
<li>按调度算法选择投入执行新进程</li>
<li>恢复新进程的现场，将处理机分配给新进程</li>
</ol>
</li>
<li><p>高响应比优先调度算法优点是什么？</p>
<p> 响应比 = 响应时间/要求服务时间 = （等待时间+要求服务时间）/要求服务时间 ； 优点是：</p>
<ol>
<li>如果进程等待时间相同，则要求服务时间最短的进程优先权最高，有利于短作业。【SJF短作业优先只考虑了作业运行时间而忽略了作业等待时间】</li>
<li>如果作业要求服务时间相同，则优先权将取决于进程到达先后次序，体现了公平原则。【FCFS先来先服务只考虑作业等待时间而忽视了作业运行时间】</li>
<li>如果进程较长，它的优先权将随着等待时间的曾长而提高，不会长时间得不到服务。<ol start="8">
<li>为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？</li>
</ol>
</li>
<li>对于终端型作业用户而言，其提交的作业大多为交互型作业，作业通常较小，系统只要能使这些作业在第一个队列所规定的时间片内完成，便可使其满意</li>
<li>对于短批处理作业用户而言，较短的作业可在第一个队列完成，稍长的也可以在第二三队列执行一个时间片完成，周转时间仍然很短。</li>
<li>对于长批处理作业用户而言，用户不必担心作业长期得不到处理，且每下降一个队列，长作业等待时间都进一步缩短。</li>
</ol>
</li>
<li><p>死锁定理</p>
<p> 在资源分配图中找到一个既不阻塞又非独立的进程，分配给该进程资源后，该进程执行完毕释放所占资源，即消去请求边与分配边，使其成为孤立点，重复该过程，若能使所有进程都能成为孤立点，则该图是可完全简化的。<br />当前状态为死锁的充分条件是，当且仅当该状态的资源分配图是不可完全简化的。</p>
</li>
<li><p>产生死锁的原因和必要条件</p>
<p>原因：系统资源的竞争和进程推进顺序非法。<br />必要条件：互斥条件、请求与保持条件、不剥夺条件、循环等待条件<br />预防死锁：破坏四个条件<br />避免死锁：银行家算法，防止进入不安全状态<br />检测死锁：死锁定理，资源分配图<br />解除死锁：资源剥夺，撤销进程，解除死锁</p>
</li>
</ol>
<h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><ol>
<li><p>程序的装入</p>
<ol>
<li>绝对装入方式：产生使用绝对地址的目标模块。只适用于单道程序环境</li>
<li>可重定位装入方式：程序中的其他地址都是相对于始址的<ol>
<li>静态重定位：在装入时，由重定位程序一次性完成的。不允许程序在运行时在内存中移动位置。</li>
</ol>
</li>
<li>动态运行时装入方式：需要重定位寄存器的支持。可以将程序分配在不连续的存储区中，程序运行之前可以只装入部分代码即刻运行，运行期间动态申请分配内存，便于程序段共享。</li>
</ol>
</li>
<li><p>程序的链接</p>
<ol>
<li>静态链接方式：在程序运行之前将各目标模块及所需的库函数链接为一个完整的装入模块。</li>
<li>装入时动态链接：链接在装入时进行，便于对程序模块进行修改和更新，可对外存中的目标模块实现共享。</li>
<li>运行时动态链接：链接在运行时进行。便于实现目标模块的修改、更新和共享，加快程序的装入过程，提高内存利用率。</li>
</ol>
</li>
<li><p>为什么引入对换？</p>
<ol>
<li>在多道程序环境下，一方面内存中某些进程由于某事件尚未发生而阻塞，却占用大量内存空间，可能出现内存中所有进程被阻塞。另一方面：又有很多作业意志驻留外存，不能进入内存运行</li>
<li>提高内存利用率，系统吞吐量</li>
</ol>
</li>
<li><p>什么情况下需要进行重定位？为什么要引入重定位？</p>
<p> 重定位概念：将作业空间中的逻辑地址转换为主存空间中的物理地址，从而保证作业能够正常进行。</p>
<ol>
<li>程序在装入时，指令和数据的实际物理地址与装入模块中的相对地址是不一致的，此时需要重定位。</li>
<li>引入动态重定位是因为进程在运行过程中进场要在内存中移动位置。重定位的过程是由硬件地址变换机构在程序执行每条指令时自动完成。</li>
</ol>
</li>
<li><p>连续分配方式中动态分区分配方式：</p>
<ol>
<li>首次适应算法：按地址从小到大为序，分配第一个符合条件的分区。</li>
<li>最佳适应算法：按空间从小到大为序，分配第一个符合条件的分区。</li>
<li>最坏适应算法：按空间从大到小为序，分配第一个符合条件分区。</li>
<li>循环首次适应：与首次适应算法相似，从上次分配的下一个位置继续。</li>
</ol>
</li>
<li><p>分页系统地址变换机构</p>
<p> 硬件支持：页表寄存器，地址变换机构</p>
<ol>
<li>页号与页表长度比较，页号大于页表长度，则产生越界中断</li>
<li>以页号为索引去检索页表。页表始址+页号x页表项长度</li>
<li>从页表中获取物理块号。</li>
<li>物理地址=物理块号+页内地址。</li>
</ol>
<p> 一次数据操作，访问两次内存：访问页表获取块号，访问数据。<br />引入快表的地址变换机构</p>
<ol>
<li>页表在与页表寄存器中的页表长度比较时并行地与快表中的所有页号比较。</li>
<li>若在快表中则直接读出物理块号。</li>
<li>否则从页表中读，并将得到的页表项和页号装入到快表中。</li>
</ol>
<p> 多级页表机制下页内地址长度等于页面大小。</p>
</li>
<li><p>分段系统地址变换机构</p>
<p> 硬件支持：段表寄存器，地址变换机构</p>
<ol>
<li>段号S与段表度长比较，若大于则产生越界中断。</li>
<li>使用段号进行索引段表得到该段的基址和长度。段表始址+段号x段表项长度。</li>
<li>检查段内地址是否超过段长，超过则产生越界中断。</li>
<li>物理地址=起始地址（基址）+段内地址。</li>
</ol>
<p> 一次数据操作访问两次内存。</p>
</li>
<li><p>分页与分段比较：</p>
<ol>
<li><p>页是信息的物理单位，分页是为了提高内存利用率。段是信息的逻辑单位，含有一组其意义相对完整的信息。分段是为了能更好的满足用户的需要。</p>
</li>
<li><p>页的大小固定且由系统决定。段的长度不固定且由用户所编写的程序决定。</p>
</li>
<li><p>分页的地址空间是一维的，分段的地址空间是二维的。</p>
</li>
<li><p>分页有内部碎片，无外部碎片。分段无内部碎片，有外部碎片。</p>
</li>
<li><p>分段更容易实现共享和动态链接。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h2><ol>
<li><p>什么是虚拟存储器？</p>
<p> 虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统。<br />虚拟存储器具有如下特征：</p>
<ol>
<li>多次性，最本质最重要的特征。虚拟存储器将一个作业分成多次调入内存。部分装入。</li>
<li>对换性，虚拟存储器允许将将暂时用不到的程序从内存调到对换区，提高内存利用率。</li>
<li>虚拟性，虚拟存储器对内存的扩充是逻辑上的。</li>
<li>离散性，虚拟存储器必须建立在离散分配的基础上。</li>
</ol>
</li>
<li><p>如何实现页式虚拟存储器？</p>
<p> 首先请求分页的页表机制。扩充页表，增加状态位确认是否在内存；增加外存始址便于调入；增加引用位供置换算法。增加修改位减少换出时写磁盘次数。<br />请求调页技术，需要硬件上缺页中断机制和软件配合实现。<br />置换页技术，关键是采取什么置换算法。<br />还有地址变换机构。</p>
</li>
<li><p>局部性原理</p>
<ol>
<li>时间局部性，某条指令（数据）一旦执行（访问），不久后可能被再次执行（访问）。原因是程序中的大量循环操作。</li>
<li>空间局部性，程序在一段时间内所访问的地址可能集中在一定范围内。原因是程序的顺序执行。</li>
</ol>
</li>
<li><p>缺页中断中断机构与一般中断之间的区别</p>
<ol>
<li>在指令执行期间产生和处理中断信号。</li>
<li>一条指令在执行期间可能产生多次中断。</li>
</ol>
</li>
<li><p>请求分页系统中地址变换过程（考试中不需要写这个详细的，要写按地址字段进行转换的）</p>
</li>
</ol>
<img src="https://fastly.jsdelivr.net/gh/konsin/images@main/202207111635877.jpeg" alt="7B745057-CD3E-4C10-99F6-05F104B1AE8F.jpeg" style="zoom:20%;" />

<ol start="6">
<li>页面置换算法<ol>
<li><p>最佳算法（OPT）：选择往后最长时间内不再被访问的页面置换。</p>
</li>
<li><p>先进先出页面置换算法（FIFO）</p>
</li>
<li><p>最近最久未使用算法（LRU）：为每个页面设置一个访问字段，记录自上次被访问以来所经历的时间。选择最大的置换。需要寄存器和栈的硬件支持。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第六章-输入输出系统（I-O）"><a href="#第六章-输入输出系统（I-O）" class="headerlink" title="第六章 输入输出系统（I/O）"></a>第六章 输入输出系统（I/O）</h2><ol>
<li><p>I/O系统基本功能</p>
<p>方便用户使用I/O设备。</p>
<ol>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
</ol>
<p>提高设备的资源利用率。</p>
<ol>
<li><p>提高处理机和I/O设备的利用率。</p>
</li>
<li><p>对I/O设备进行控制。</p>
</li>
</ol>
<p>方便用户共享。</p>
<ol>
<li><p>确保对设备的正确共享</p>
</li>
<li><p>错误处理</p>
</li>
</ol>
</li>
<li><p>I/O系统的层次结构</p>
<ol>
<li>用户层I/O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ol>
</li>
<li><p>I/O控制方式</p>
<ol>
<li><p>轮询方式：程序直接对设备循环测试</p>
<p>优点：简单，易于实现<br />缺点：CPU和I/O只能串行工作，CPU利用率很低</p>
</li>
<li><p>中断方式：引入中断机制，当设备准备完成时发生中断</p>
<p>优点：CPU和I/O可以并行工作，相较于轮询方式大大提高了CPU利用率<br />缺点：仍以字节为单位，降低了效率。</p>
</li>
<li><p>DMA（直接存储器存取）方式：在I/O设备与内存之间直接开辟数据通路</p>
<p>特点：</p>
<ol>
<li>基本单位是数据块</li>
<li>数据是直接从设备送入送出内存的</li>
<li>仅在传送一个或多个数据块的开始和结束时才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</li>
</ol>
</li>
<li><p>通道控制方式：引入专门的I/O处理机进行管理</p>
<p>进一步减少CPU干预，基本单位变为一组数据块</p>
</li>
</ol>
</li>
<li><p>试说明I/O控制发展的主要推动因素是什么？</p>
<ol>
<li>力图减少CPU对I/O设备的干预，充分发挥CPU的数据处理能力</li>
<li>缓和CPU的高速性和I/O设备的低速性之间速度不匹配的矛盾。提高CPU利用率和系统的吞吐量。</li>
<li>提高CPU和I/O设备操作的并行程度。提高整个系统的资源利用率和吞吐量。</li>
</ol>
</li>
<li><p>中断的重要性：</p>
<ol>
<li>中断是多道程序实现的基础，进程的切换通过中断完成。</li>
<li>中断是设备管理的基础，为提高CPU利用率和实现CPU与I/O设备并行执行。</li>
</ol>
</li>
<li><p>中断驱动I/O方式和DMA方式有什么不同？</p>
<ol>
<li>中断方式是程序的切换，要保护和恢复现场； DMA方式除了预处理和后处理其余时间不占用CPU</li>
<li>对中断请求的响应只能发生在每条指令结束时（指令执行周期后）；对DMA的请求响应可以发生在每个机器周期结束时（取指、间址、执行），只要CPU不占用总线就可以响应。</li>
<li>中断传送过程需要CPU的干预；DMA传送过程不需要CPU的干预，故DMA传输效率高，适合高速外设成组数据传输。</li>
<li>DMA请求优先于中断请求</li>
<li>中断方式具有对异常事件的处理能力。 DMA方式仅局限传送数据块的I/O操作。</li>
<li>从数据传送来看，中断靠程序传送，DMA靠硬件传送。</li>
</ol>
</li>
<li><p>DMA方式和I/O通道方式的区别。</p>
<ol>
<li>DMA需要CPU控制数据传送位置，数据块大小等参数，而通道中这些参数的设置是由通道控制的。</li>
<li>一个DMA控制器对应一台设备。 一个I/O通道可以控制多台设备。</li>
</ol>
</li>
<li><p>为什么I/O通道常采用交叉连接的方式</p>
<p>I/O通道是一种特殊的处理机，它具有执行I/O指令的功能，能控制I/O操作。由于通道价格昂贵，所以通道数量少，这往往成为I/O的瓶颈，造成整个系统吞吐量的下降。为解决此问题，增加设备到主机之间的通路而不增加通道，提高了系统可靠性。</p>
</li>
<li><p>为什么要引入缓冲区？（重要）</p>
<ol>
<li>缓和CPU和I/O设备速度不匹配的矛盾。</li>
<li>减少对CPU的中断频率，放宽CPU响应中断时间。</li>
<li>提高CPU和I/O设备之间的并行性</li>
<li>解决数据粒度不匹配的问题。</li>
</ol>
</li>
<li><p>为什么要引入设备独立性？如何实现设备独立性？（重要）</p>
<p>引入设备独立性，可使应用程序独立于具体的物理设备。用逻辑设备名来申请使用某类物理设备，可显著地改善资源的利用率及可适应性。独立性还可以使用户程序独立于设备的类型，可以很方便地进行输入输出重定向。<br />为了实现设备独立性，必须在设备驱动程序之上设置一层设备独立性软件，用来执行所有I/O设备的公用操作，并向用户层软件提供统一接口。关键是系统中必须设置一张逻辑设备表LUT来进行逻辑设备到物理设备的映射。（逻辑设备名、物理设备名、设备驱动程序入口地址）</p>
</li>
<li><p>什么是虚拟设备？实现虚拟设备的关键技术是什么？</p>
<p>虚拟设备是指通过某种虚拟技术，将一台物理设备变为若干台逻辑设备，从而实现多个用户对该物理设备的同时共享。<br />虚拟设备技术常通过在可共享的、高速的磁盘上开辟两个大的存储空间（输入井、输出井）以及预输入、缓输出技术来实现。预输入和缓输出可通过脱机和假脱机技术实现。</p>
</li>
<li><p>SPOOLing系统（假脱机技术）由哪几部分组成？以打印机为例说明如何利用SPOOLing技术实现多个进程对打印机共享。</p>
<p>SPOOLing系统由磁盘上的输入井和输出井、内存中的输入缓冲区和输出缓冲区，输入进程和输出进程以及井管理程序构成。<br />使用SPOOLing技术共享打印机：</p>
<ol>
<li><p>在输出井中为进程申请一空闲缓冲区，放入要打印的数据。</p>
</li>
<li><p>为用户进程申请一张空白的打印申请表，在把该表挂到假脱机文件队列上。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h2><ol>
<li><p>文件系统为什么通常是显式进行文件”打开””关闭”操作？</p>
<ol>
<li>打开文件操作的基本功能是将指定文件的属性信息FCB复制到内存中，并返回指向内存中该文件属性信息的地址（文件描述符）。关闭文件操作是从内存中删除文件的属性信息，并写回外存。</li>
<li>显式进行打开操作，当用户需要对一个文件实施多次读写操作时，只需要使用文件描述符而非路径名。系统则无需对目录进行检索便可通过文件描述符直接找到内存中的文件FCB。避免了重复检索目录，提高了文件的访问速度。</li>
</ol>
</li>
<li><p>文件的逻辑结构和物理结构的概念</p>
<ol>
<li><p>文件的物理结构是文件的存储结构，指系统过将文件存储在外存上的存储形式</p>
</li>
<li><p>文件的逻辑结构指从用户角度出发所观察到的文件组织形式，文件的内部数据在逻辑上是怎么组织的。</p>
<ol>
<li><p>有结构文件</p>
<ol>
<li>顺序文件：与关键字有关的串结构，无关的顺序结构</li>
<li>索引文件：为变长文件建立索引表</li>
<li>索引顺序文件：顺序文件和索引文件的结合</li>
<li>直接文件：通过哈希函数直接决定记录地址</li>
</ol>
</li>
<li><p>无结构文件：将数据按顺序组织成记录并积累保存。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对文件目录管理的要求？</p>
<ol>
<li>能够实现”按名存取”。</li>
<li>能够提供快速的目录查询手段以提高对文件的检索速度。</li>
<li>为文件的共享和重名提供方便</li>
<li>允许文件同名</li>
</ol>
</li>
<li><p>文件系统：文件控制块和索引节点的内容</p>
<img src="https://fastly.jsdelivr.net/gh/konsin/images@main/202207111635837.jpeg" alt="7775FC29-3F7C-47E8-83FB-299E9BD9F51A.jpeg" style="zoom: 10%;" />

<ol>
<li><p>文件控制块：</p>
<ol>
<li>基本信息：包括文件名，文件物理地址，文件逻辑结构，文件物理结构</li>
<li>存取控制信息：文件的存取权限</li>
<li>使用信息：文件的建立时间，修改时间，当前使用信息。</li>
</ol>
</li>
<li><p>索引结点：至少要有索引结点编号、存取权限、文件物理地址、文件大小的信息。</p>
<ol>
<li>优点是：可以减少文件查找时平均启动磁盘的次数，有效提升文件检索速度。</li>
</ol>
</li>
<li><p><del>磁盘索引结点</del></p>
<ol>
<li><del>文件主标识符</del></li>
<li><del>文件类型</del></li>
<li><del>文件存取权限</del></li>
<li><del>文件物理地址</del></li>
<li><del>文件长度</del></li>
<li><del>文件连接计数</del></li>
<li><del>文件存取时间</del></li>
</ol>
</li>
<li><p><del>内存索引结点</del></p>
<ol>
<li><del>索引结点编号</del></li>
<li><del>状态：是否修改</del></li>
<li><del>访问计数</del></li>
<li><del>文件所属文件系统的逻辑设备号</del></li>
<li><del>链接指针，指向空闲链表和散列队列。</del></li>
</ol>
</li>
</ol>
</li>
<li><p>文件系统必要的系统调用</p>
<p>创建文件、删除文件、读文件、写文件。<br />以读文件为例：</p>
<ol>
<li>系统调用给出文件名和读入的内存目标地址<ol>
<li>系统通过查找目录表，找到该文件所对应的索引结点编号，或直接通过指向索引节点的指针找到索引结点。</li>
<li>根据索引结点中的物理地址，找到文件在外存中存放的位置。</li>
<li>将该文件读入内存。</li>
</ol>
</li>
</ol>
</li>
<li><p>树形目录结构中线性检索法的检索过程</p>
<ol>
<li>系统在检索一个文件时，先读入给定文件路径名中的第一个分量名，用它与根目录文件（当前目录文件）中的各目录项中的文件名顺序地进行比较。<ol>
<li>若找到相匹配的目录项，则可获得它的FCB或索引节点编号，从而找到该分量名对应的文件。</li>
<li>然后系统再读入第二个文件分量名，与刚检索到的目录文件中的各目录项的文件名顺序比较，若找到，则重复该过程，逐级检索指定文件分量名，最后会得到指定文件的FCB或索引结点。</li>
</ol>
</li>
</ol>
</li>
<li><p>文件共享方式</p>
<p>目的是提高文件存储空间利用率，方便用户对文件的使用。</p>
<ol>
<li><p>基于索引结点的共享方式（硬链接）：将多个目录项指向同一个磁盘索引结点</p>
</li>
<li><p>利用符号链实现文件共享（软链接）：建立一个类型为LINK，内容为被共享文件路径名的新文件来实现共享。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h2><ol>
<li><p>文件外存分配中，即文件的物理结构，连续分配、链接分配、和索引分配各自的优缺点。</p>
<ol>
<li><p>连续分配方式：为每个文件分配一组相邻的物理块，将文件信息按逻辑顺序存放。</p>
<ol>
<li>适合不经常更新，经常随机访问</li>
<li>优点：管理简单；顺序访问存取速度很快；支持对文件随机存取</li>
<li>缺点：要求连续的存储空间，容易产生碎片，降低存储空间利用率；要求事先知道文件长度；不利于文件的增长扩充。</li>
</ol>
</li>
<li><p>链接分配方式：隐式链接方式类似于单链表；显式链接方式是将链接各物理块的指针显式地登记在系统的一张文件分配表FAT中。</p>
<ol>
<li><p>适合经常更新，经常顺序访问</p>
</li>
<li><p>隐式链接：</p>
<ol>
<li>优点：解决了外部碎片；不需事先知道文件长度；插入删除修改容易；</li>
<li>缺点：只支持顺序访问；可靠性较差</li>
</ol>
</li>
<li><p>显式链接：</p>
<ol>
<li>优点：可显著提高检索的速度；增加了文件系统的可靠性。</li>
<li>缺点：不支持高效的随机存取；文件存储介质较大，则FAT也要占用较大存储空间。</li>
</ol>
</li>
</ol>
</li>
<li><p>索引组织方式：为每个文件建立一个索引表，登记分配给该文件所有的物理块号，文件FCB的物理地址字段为该索引表的指针。</p>
<ol>
<li>适合经常更新，经常随机访问</li>
<li>优点：既支持顺序访问又支持随机访问；查找效率高；便于文件删除</li>
<li>缺点：索引表会占用一定存储空间，对单独的中小文件也需要分配完整的索引表，对外存空间造成严重浪费。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>UNIX系统的混合索引方式：索引地址分为13个地址项。假设每个物理块4KB</p>
<p>优点：既能节省存储地址所占的存储空间，又有较高的查找速度。</p>
<ol>
<li><p>直接地址：0-9共10个地址项，分配相应文件的前十个物理块地址。可存储4KB X 10 = 40KB的文件</p>
</li>
<li><p>一次间址：地址项10为一次间址。登记分配给文件的第10个物理块及后序物理块地址。如果地址长度为4B，则一次间址块可存储4KB / 4B = 1K个物理块号。最大存储文件为40KB+ 1K x 4KB</p>
</li>
<li><p>多次间址：地址项11为二次间址，存储的是1次间址的块号。故可存储40KB+4MB+4GB的文件；地址项12是三次间址，存储的是二次间址的块号。故可存储40KB + 4MB + 4GB + 4TB的文件。</p>
</li>
</ol>
</li>
<li><p>文件存储空间的管理</p>
</li>
</ol>
<ol>
<li><p>位示图法：用1表示分配，0表示清除</p>
</li>
<li><p>成组链接法：适合大型文件。将一个文件卷的所有空闲盘块按固定大小分成若干组，并将每一组的盘块数和该组所有盘块号计入前一组的最后一个盘块中。（最后一组的0标记也算一个）</p>
<ol>
<li><p>分配过程（操作题）：</p>
<ol>
<li>将s_nfree（该组空闲盘块数）减1；</li>
<li>若s_nfee仍大于0，即第一组不只一个空闲盘块，则将s_free[s_nfree]空闲盘块号栈栈顶的空闲盘块分配出去。</li>
<li>若s_nfree为0，即当前空闲盘块号栈中只剩下最后一个空闲盘块，则用唯一所剩的盘块替换掉超级块，再将该盘块分配出去。</li>
<li>若s_nfree为0，且栈底登记盘块号为0；则表示系统已无空闲盘块可分配。</li>
</ol>
</li>
</ol>
</li>
<li><p>磁盘调度算法（计算）</p>
<p>一次磁盘读写操作时间：<br /></p>
<p>​    寻道时间（m x 磁道数 + 启动时间） + 延迟时间（1/2r） + 传输时间（b/(r x 一个磁道上字节数)）</p>
<ol>
<li>先来先服务（FCFS）：根据进程请求访问磁盘的先后顺序进行调度</li>
<li>最短寻找时间优先（SSTF）：选择当前磁头所在磁道距离最近的磁道</li>
<li>电梯算法（SCAN）：在当前移动方向上最近的磁道。</li>
<li>循环扫描算法（CSCAN）：只能一个方向，到达当前方向上最后一个需要访问的磁道后，从头开始。</li>
</ol>
</li>
<li><p>提高磁盘I/O速度的途径。</p>
<ol>
<li><p>磁盘高速缓存</p>
</li>
<li><p>提前读</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>延迟写</p>
</li>
<li><p>优化物理块布局</p>
</li>
<li><p>虚拟盘</p>
</li>
<li><p>提高文件访问速度的途径。</p>
<ol>
<li><p>改进文件的目录结构及检索目录的方法来减少对目录的查询时间</p>
</li>
<li><p>选取好的文件存储结构，以提高对文件访问速度</p>
</li>
<li><p>提高磁盘I/O速度。</p>
</li>
</ol>
</li>
</ol>
<h1 id="组成原理"><a href="#组成原理" class="headerlink" title="组成原理"></a>组成原理</h1><ol>
<li><p>冯·诺伊曼计算机结构的主要特点：</p>
<ol>
<li>计算机由运算器、控制器、存储器、输入设备和输出设备5大部分组成</li>
<li>指令和数据用二进制表示，两者形式上没有差别。</li>
<li>指令和数据存放在存储器中，按地址访问</li>
<li>指令由操作码和地址码组成，操作码指定操作性质，地址码指定操作数地址</li>
<li>采用”存储程序”方式进行工作</li>
</ol>
</li>
<li><p>计算机系统层次结构</p>
</li>
<li><p>指令和数据均以二进制形式存放在存储器中，计算机如何区分？</p>
<p> 时间上说，在取指周期取的是指令，在执行周期取的是数据；<br />空间上说，指令存放在指令寄存器，数据存放在通用寄存器；<br />并且，指令地址在PC中存放，数据地址在指令的地址字段。</p>
</li>
<li><p>控制器设计的两种方式及其各自特点 </p>
<ol>
<li>微程序控制器：微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出，执行速度慢，较规整，应用于CISC，易扩充和修改。指令添加容易，可维护性好。</li>
<li>硬布线控制器：微操作控制信号由组合逻辑电路根据当前指令码、状态和时序即时产生，执行速度快，繁琐不规整，应用于RISC，难易扩充，可维护性差。</li>
</ol>
</li>
<li><p>计算机调用中断服务程序与调用子程序有何区别</p>
<ol>
<li>中断程序：随机的，和主程序有关，从隐指令中取得中断服务地址</li>
<li>子程序：预先设计好的，为主程序服务，由调用服务给出地址。</li>
</ol>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://konsin.gitee.io/2021/09/08/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AE%80%E7%AD%94%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/829%E4%B8%93%E4%B8%9A%E8%AF%BE/" rel="tag">829专业课</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%85%E8%83%8C%E7%AE%97%E6%B3%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            数据结构必背算法
          
        </div>
      </a>
    
    
      <a href="/2021/04/20/RecyclerView/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">安卓RecyclerView封装库</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2023
        <i class="ri-heart-fill heart_icon"></i> Konsin
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="不想当咸鱼王"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.konsin.top/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>