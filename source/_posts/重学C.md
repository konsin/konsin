---
title: 重学C++
date: 2022-08-18 15:08:28
categories: 学习笔记
tags: C++
---

## 第一章

- C++语言的优点，缺点，和主要用途？
  - 优点：
    - 强大的封装抽象能力，强大的开发工程的能力
    - 高性能，运行快，占用资源少
    - 低功耗，特别适合微型嵌入式
  - 缺点
    - 语法相对复杂、细节较多
    - 需要一些好的规范和范式，否则代码难以维护
  - 主要用途
    - 大型桌面应用程序
    - 大型网站后台
    - 游戏和游戏引擎
    - 视觉库和AI引擎
    - 数据库
    - 自动驾驶系统、嵌入式设备等

- 面向对象和面向过程的优缺点

  面向过程

  - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
  - 缺点：没有面向对象易维护、易复用、易扩展 

  面向对象

  - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 
  - 缺点：性能比面向过程低 

## 第二章

### 数据类型

   | 类型               | 位            | 范围                                                         |
   | :----------------- | :------------ | :----------------------------------------------------------- |
   | char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
   | unsigned char      | 1 个字节      | 0 到 255                                                     |
   | signed char        | 1 个字节      | -128 到 127                                                  |
   | int                | 4 个字节      | -2147483648 到 2147483647                                    |
   | unsigned int       | 4 个字节      | 0 到 4294967295                                              |
   | signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
   | short int          | 2 个字节      | -32768 到 32767                                              |
   | unsigned short int | 2 个字节      | 0 到 65,535                                                  |
   | signed short int   | 2 个字节      | -32768 到 32767                                              |
   | long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
   | signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
   | unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
   | float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
   | double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
   | long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
   | wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

### 关键字

   | asm          | else      | new              | this     |
   | ------------ | --------- | ---------------- | -------- |
   | auto         | enum      | operator         | throw    |
   | bool         | explicit  | private          | true     |
   | break        | export    | protected        | try      |
   | case         | extern    | public           | typedef  |
   | catch        | false     | register         | typeid   |
   | char         | float     | reinterpret_cast | typename |
   | class        | for       | return           | union    |
   | const        | friend    | short            | unsigned |
   | const_cast   | goto      | signed           | using    |
   | continue     | if        | sizeof           | virtual  |
   | default      | inline    | static           | void     |
   | delete       | int       | static_cast      | volatile |
   | do           | long      | struct           | wchar_t  |
   | double       | mutable   | switch           | while    |
   | dynamic_cast | namespace | template         |          |

### 命名建议：变量名尽量使用“名词”或“形容词+名词”；函数名用“动词+名词”。原则上长度不超过32位

### 常用命名规则

   1. 匈牙利命名法：开头字母用变量类型缩写后面用变量的英文或缩写
   2. Camel命名法：首单词小写，后面单词首字母大写
   3. Pascal命名法：每个单词第一个字母都大写

### 常量与变量

   1. 常量：在程序运行过程中，值一直保持不变的量

      - 定义方法

        - 使用`#define `方式 `#define PI 3.1415`
        - 使用` const`方式 `const double PI = 3.1415`

        使用const定义常量可以在编译时检查出错误。而define只是宏定义，难以排错

      - 常量类型

        - 整数常量：可以是十进制、八进制或十六进制的常量。

        **前缀**指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

        **后缀**是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。

        - 浮点常量

        小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。

        指数形式表示时， 必须包含小数点、指数，或同时包含两者。e后面指定指数

        - 布尔常量
        - 字符常量

        如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。

## 第三章

**运算符**：告诉编译器执行特定数学或逻辑操作的符号。（算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、杂项运算符）

**表达式**：使用运算符将操作数连接而成的式子，每一个表达式都有自己的值，表达式都有运算结果

**注释的建议**：
  1. 好的命名和代码本身就是最好的注释；如果代码本身很清楚，不需要额外加注释。
  2. 在重要代码段、或复杂代码处先写注释再写代码，这样思路更清晰，同时可以保证代码和注释的一致性。
  3. 注释不是越多越好，它是对代码的提示，如果要写就写清楚，并且保证和代码一致。如果更新的代码，清更新相应的注释。

**补码**：
  有符号数另一种计算方式：![image](https://git.poker/konsin/images/blob/main/image.7ka0cc9pftg0.jpg?raw=true)
  常用计算方式：正数不变；复数 符号位不变，其余位取反，最后加1

**大端方式** 数字高位在低地址
**小段方式** 数字低位在低地址

## 第四章
### 数组
概念：代表内存里一组连续的同类型存储区；可以用来把多个存储区合并成一个整体
C语言中数组下标：从0开始，使用非对称区间`[,)`，下届可以取到值，上界取不到值。
   好处：
      1. 取值范围的大小：上界 - 下届；
      2. 如果这个取值范围为空， 上界值 == 下界值
      3. 即使取值范围为空，上界值永远不可能小于下界值。
使用：
  1. 通过下下标可以直接访问任意一个元素
  2. 下标从0开始到元素个数减一为止
  3. 超过范围的下标不可以使用
  4. 数组名称和下标可以表示数组里的元素

优点：
  1. 可以编写循环依次处理数组里的所有元素
  2. 循环变量依次代表所有有效下标

**差一错误**：high - low + 1

### vector数组
`#include <vector>`
引入原因：使用最简单的数组，无法实现动态扩容插入元素，因为容量有限。
- 查询大小：`s.size()`
- 查询容量：`s.capacity()`
- 使用sort对vector排序
  `sort(num.begin(), num.end());`
- 插入数据的方式
  尾插 `push_back(val)`
  尾删 `pop_back()`
  插入 `insert()`
  删除 `erase()`
  清空 `clear()`

### 字符串
**定义方式**：
  `char str[] = {"hello"}`
  `char str[6] = {'h','e','l','l','o'}`
**字符串变量**：
  - 字符串是以空字符('\0')结束的字符数组
  - 空字符 '\0'自动添加到字符串的内部表示中
**字符串常量**：
  - 字符串常量是一对双引号括起来的字符串数组
  - 字符串中每个字符作为一个数组元素存储


**Unicode编码**：目的->把世界上的文字都映射到一套字符空间中
  1. UTF-8：1byte表示字符，可以兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（可作为外部编码）
  2. UTF-16：分为UTF-16BE（big endian）、UTF-16LE(little endian)。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）
  3. UTF-32：分为UTF-32BE、UTF-32LE。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）

**字符串指针**：
  - 指针表示方法： `char* pStr = "hello";`
  - char[] 和 char* 的区别：
    - 地址和地址存储的信息
    - 可变与不可变。
    如果数组指针初始化指向字符串常量，那么这个指针所指内容不可发生改变。
    ``` cpp
    char *ps = "hello";  //字符串常量指针
    char s[] = {"hello"};
    char *ps2 = s;       //字符串变量指针
    ```
    s不可变，s[i]的值可变；
    ps可变，ps[i]的值可不可变取决于所指区间的存储区域是否可变。

**常见操作**：
  `strlen(s)`：返回s的长度
  `strcmp(s1, s2)`: 自左到右按ASCII值大小比较 s1 == s2 返回 0； s1 < s2 返回 -； s1 > s2 返回+；
  `strcpy(s1, s2)`: 复制s2到s1；
  `strncpy(s1, s2, n)` 将字符串s2中前n个字符拷贝到s1中
  `strcat(s1, s2)` 将字符串s2接到s1后面
  `strchr(s1,ch)` 查找ch在s1中第一次出现位置
  `strstr(s1, s2)` 查找s2在s1中第一次出现位置。

### string字符串
`#include <string>`
使用string可以更为方便和安全的管理字符串。
定义：`string s`; `string s = "hello"`; `string s("hello")`; `string s = string("hello")`;
**常用操作**
  - 获取长度：
    - `s.length()` 
    - `s.size()`
    - `s.capacity()` 容量 != 长度
  - 字符串比较：`==` `!=` `>` `>=` `<` `<=`
  - 转换为C风格字符串 char*
    `const char *c_s = s.c_str(); `
  - 可通过下标进行随机访问。
  - 可通过`=`进行字符串拷贝
  - 可通过`+`、`+=`连接字符串

## 第五章 指针
指针的缺点：使用指针是非常危险的行为，可能存在空指针，野指针的问题，并可能造成内存泄漏问题。
优点：指针非常的高效
**C++中内存单元内容与地址**
指针的本质：内存划分内存单元用来存放各种类型的数据。计算机对内存单元进行编号，称为内存地址，决定内存单元在内存中的位置。C++编译器让我们通过名字来访问这些内存位置。
指针定义的基本形式： 指针本身就是一个变量，其符合变量定义的基本形式，存储的是值的地址。对类型T，T*是‘到T的指针’类型。通过一个指针访问所指向地址的过程称为间接访问或引用指针。
  小结：
  1. 一个变量有三个重要信息：
     1. 变量的地址位置
     2. 变量所存的信息
     3. 变量的类型
  2. 指针变量是一个专门用来记录变量的地址的变量，通过指针变量可以间接的访问改变另一个变量的值
### C++中原始指针
1. 一般类型指针T*
2. 指针的数组与数组的指针
   指针的数组 T* t[]
   数组的指针 T (*t)[]
3. const pointer 和 pointer to const
   `char const` 和 `const char` 是等价的。
   看const修饰部分：
   - 看左侧最近的部分
   - 如果左侧没有则看右侧
4. 指向指针的指针 
   `*`操作符具有从右向左的结合性 
   `**`表达式相当于`*(*c)`，必须从里向外逐层求值
5. 未初始化和非法的指针
   如果定义到了一个非法地址，程序会出错，从而终止。
   如果定位到一个可以访问的地址，无意修改了它，这种错误难以捕捉，引发的错误可能与原先用于操作的代码完全不相干。
6. NULL指针
   一个特殊的指针，表示不指向任何东西。这种方法来表示特定的指针目前未指向任何东西
   注意事项：
   对应于一个指针如果已经知道被初始化为什么地址，如果不赋值就设置为NULL
   引用指针前先判断是否为NULL

**杜绝野指针**
if等判断对野指针不起作用，因为没有置NULL
一般有三种情况：
  1. 指针变量没有初始化
  2. 已经释放不用的指针没有置NULL，如delete和free之后的指针
  3. 指针操作超越了变量的作用范围。

没有初始化的，不用的或者超出范围的指针把值置为NULL

### 指针的基本运算
1. `&`与`*`操作符
   `&ch`取出来的是地址
   `*cp`为右值时是指向地址的内容，为左值时为指针。
        `*CP+1`左值非法，`*(cp+1)`为下一位指针对应的
2. `++`与`--`操作符
3. 关于`++++`与`----`等运算符
   编译程序分解成符号的方法是：一个字符一个字符的读入，如果该字符可能组成一个符号，那么读入下一个字符，一直到读入的字符不能再组成一个有意义的符号。 a+++b 相当于 a++ +b

### CPP程序存储区域划分
全局变量、常量在常量区，变量在栈区，动态申请变量在堆区。
![5-11-CPP程序的存储区域划分总结-00_05_34-2022_09_20_14_23_02-(2)](https://cdn.staticaly.com/gh/konsin/images@main/5-11-CPP程序的存储区域划分总结-00_05_34-2022_09_20_14_23_02-(2).6mgazj6rwp00.jpg)
1. 栈和队列
   栈：先进后出
   队列：先进先出
2. 动态分配资源-堆（heap）
   程序通常需要牵涉到三个内存管理器的操作：
   1. 分配某个大小的内存块；
   2. 释放一个之前分配的内存块；
   3. 垃圾收集操作，寻找不再使用的内存块并予以释放。（这个回收策略需要实现性能、实时性、额外开销等各方面的平衡，很难有统一和高效的做法）
   C++做了1、2，Java做了1、3。

### 资源管理方案--RAII(Resource Acquisition Is Initialization)
1. 主流的编程语言中，C++是唯一一个依赖RAII做资源管理的。
2. RAII依托**栈**和**析构函数**，来对所有的资源——包括堆内存在内进行管理。对RAII的使用，使得C++不需要类似Java那样的垃圾收集方法也能有效地对内存进行管理。
3. RAII有些比较成熟的智能指针代表：`std::auto_ptr`、`boost::shared_ptr`

### C++中几种变量对比
栈和堆中的变量对比
| | 栈区| 堆区|
|:------------|:------------|:--------------|
|作用域|函数体内，语句块{}作用域|整个程序范围内，由`new`,`malloc`开始，`delete`、`free`结束|
|编译间大小确定|变量大小范围确定|变量大小不确定，需要运行期确定|
|大小范围|Windows默认栈大小1M，linux默认栈大小8M或10M|所有系统的堆空间上限是接近内存（虚拟内存）的总大小的|
|内存分配方式|地址由高到低减少|地址由低到高增加|
|内容是否可变|可变|可变|
全局静态存储区和常量存储区的变量对比
||全局静态存储区|常量存储区|
|:-|:-|:-|
|存储内容|全局变量，静态变量|常量|
|编译期间大小是否确定|确定|确定|
|内容是否可变|可变|不可变|

### 内存泄漏（Memory Leak）问题
1. 什么是内存泄漏问题：
   指程序中已动态分配的**堆内存由于某种原因程序未释放或无法释放**，造成系统内存的浪费，导致**程序运行速度减慢甚至系统崩溃等严重后果**。
2. 内存泄漏发生原因和排查方式：
   1. 内存泄漏主要发生在**堆内存分配方式**中，即“配置了内存后，所有指向该内存的指针都遗失了”。若缺乏语言这样的垃圾回收机制，这样的内存片就无法归还系统。
   2. 因为内存泄漏属于程序运行中的问题，无法通过编译识别，**所以只能在程序运行过程中来判别和诊断**。
比指针更安全的解决方案
1. 使用更安全的指针-智能指针
2. 不使用指针，使用更安全的方式-引用

### 智能指针
C++中四种常用智能指针: unique_ptr、shared_ptr、weak_ptr、在C++17中已经废弃的auto_ptr
1. `auto_ptr`
   由`new expression`获取对象，在`auto_ptr`对象销毁时，其所管理的对象也会自动被`delete`掉。
   所有权转移：不小心把它传递给另外的智能指针，原来的指针就不再拥有这个对象了。在拷贝/赋值过程中，会直接剥夺指针对原对象内存的控制权，转交给新对象，然后再将**原对象指针置为`nullptr`**。
   `auto_ptr<int> pl(new int(10))`
2. `unique_ptr`
   `unique_ptr`是**专属所有权**，所以`unique_ptr`管理的内存，只能被一个对象持有，不支持复制和赋值。
   移动语义：`unique_ptr`禁止了拷贝语义，但是可以使用 `std::move()`进行控制所有权的转移。
3. `shared_ptr`
   `shared_ptr`**通过一个引用计数共享一个对象**，`shared_ptr`是为了解决`auto_ptr`在对象所有权上的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针。因为引入了引用计数，所以造成了额外的资源浪费，不如`unique_ptr`轻量。
   当引用计数为0时，说明对象没有被使用，可以析构。
   问题：
   循环引用：引用计数会带来循环引用的问题，循环引用会导致堆里的内存无法正常回收，造成内存泄漏。
4. `weak_ptr`
   **`weak_ptr`被设计为与`shared_ptr`共同工作**，用一种观察者模式工作。
   意味着`weak_ptr`只对`shared_ptr`进行引用而不改变其引用计数。

### C++的引用
引用是一种特殊的指针，不允许修改的指针。
：1. 不存在空引用；2. 必须初始化； 3. 一个引用永远指向它初始化的那个对象。
1. 引用的基本使用：可以认为值指定变量的别名，使用时可以认为是变量本身。
   `int& rx = x`, `cout << rx; `等同于`cout << x;`
2. 有了指针为什么还需要引用？ 为了支持函数运算符重载。
3. 有了引用为什么还需要指针？ 为了兼容C语言。

对内置基础类型（int、double等)而言，在函数中传值（pass by value）更高效。
对OO面向对象中自定义类型而言，在函数中传引用(pass by reference to const)更高效。

## 第六章 C++基础句法
单一语句： 在任何一个表达式后面加上分号`;`
复合语句：用一对花括号`{}`括起来的语句块，在语法上等效于一个单一的语句。
### 分支语句
1. `if`语句
if语句是最常用的一种分支语句，也称为条件语句。
（比较好的编程规范是if的花括号不允许不写，即使只是一个单一语句）
```cpp
if(...)
{
  ...
}
else
{
  ...
}
```

2. `switch`语句
```cpp
switch(表达式)
{
  case 常数1: 语句1;  break;
  case 常数2: 语句2;  break;
  ...
  case 常数n: 语句n;  break;
  default: 语句n+1;
}
```
