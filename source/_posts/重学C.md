---
title: 重学C++
date: 2022-08-18 15:08:28
categories: 学习笔记
tags: C++
---

## 第一章 

- C++语言的优点，缺点，和主要用途？
  - 优点：
    - 强大的封装抽象能力，强大的开发工程的能力
    - 高性能，运行快，占用资源少
    - 低功耗，特别适合微型嵌入式
  - 缺点
    - 语法相对复杂、细节较多
    - 需要一些好的规范和范式，否则代码难以维护
  - 主要用途
    - 大型桌面应用程序
    - 大型网站后台
    - 游戏和游戏引擎
    - 视觉库和AI引擎
    - 数据库
    - 自动驾驶系统、嵌入式设备等

- 面向对象和面向过程的优缺点

  面向过程

  - 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 
  - 缺点：没有面向对象易维护、易复用、易扩展 

  面向对象

  - 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 
  - 缺点：性能比面向过程低 

## 第二章 C++基础语法

### 数据类型

   | 类型               | 位            | 范围                                                         |
   | :----------------- | :------------ | :----------------------------------------------------------- |
   | char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
   | unsigned char      | 1 个字节      | 0 到 255                                                     |
   | signed char        | 1 个字节      | -128 到 127                                                  |
   | int                | 4 个字节      | -2147483648 到 2147483647                                    |
   | unsigned int       | 4 个字节      | 0 到 4294967295                                              |
   | signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
   | short int          | 2 个字节      | -32768 到 32767                                              |
   | unsigned short int | 2 个字节      | 0 到 65,535                                                  |
   | signed short int   | 2 个字节      | -32768 到 32767                                              |
   | long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
   | signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
   | unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
   | float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
   | double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
   | long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
   | wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

### 关键字

   | asm          | else      | new              | this     |
   | ------------ | --------- | ---------------- | -------- |
   | auto         | enum      | operator         | throw    |
   | bool         | explicit  | private          | true     |
   | break        | export    | protected        | try      |
   | case         | extern    | public           | typedef  |
   | catch        | false     | register         | typeid   |
   | char         | float     | reinterpret_cast | typename |
   | class        | for       | return           | union    |
   | const        | friend    | short            | unsigned |
   | const_cast   | goto      | signed           | using    |
   | continue     | if        | sizeof           | virtual  |
   | default      | inline    | static           | void     |
   | delete       | int       | static_cast      | volatile |
   | do           | long      | struct           | wchar_t  |
   | double       | mutable   | switch           | while    |
   | dynamic_cast | namespace | template         |          |

### 命名建议：变量名尽量使用“名词”或“形容词+名词”；函数名用“动词+名词”。原则上长度不超过32位

### 常用命名规则

   1. 匈牙利命名法：开头字母用变量类型缩写后面用变量的英文或缩写
   2. Camel命名法：首单词小写，后面单词首字母大写
   3. Pascal命名法：每个单词第一个字母都大写

### 常量与变量

   1. 常量：在程序运行过程中，值一直保持不变的量

      - 定义方法

        - 使用`#define `方式 `#define PI 3.1415`
        - 使用` const`方式 `const double PI = 3.1415`

        使用const定义常量可以在编译时检查出错误。而define只是宏定义，难以排错

      - 常量类型

        - 整数常量：可以是十进制、八进制或十六进制的常量。

        **前缀**指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

        **后缀**是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。

        - 浮点常量

        小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。

        指数形式表示时， 必须包含小数点、指数，或同时包含两者。e后面指定指数

        - 布尔常量
        - 字符常量

        如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。

## 第三章 C++运算符与表达式
 
**运算符**：告诉编译器执行特定数学或逻辑操作的符号。（算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、杂项运算符）

**表达式**：使用运算符将操作数连接而成的式子，每一个表达式都有自己的值，表达式都有运算结果

**注释的建议**：
  1. 好的命名和代码本身就是最好的注释；如果代码本身很清楚，不需要额外加注释。
  2. 在重要代码段、或复杂代码处先写注释再写代码，这样思路更清晰，同时可以保证代码和注释的一致性。
  3. 注释不是越多越好，它是对代码的提示，如果要写就写清楚，并且保证和代码一致。如果更新的代码，清更新相应的注释。

**补码**：
  有符号数另一种计算方式：![image](https://git.poker/konsin/images/blob/main/image.7ka0cc9pftg0.jpg?raw=true)
  常用计算方式：正数不变；复数 符号位不变，其余位取反，最后加1

**大端方式** 数字高位在低地址
**小段方式** 数字低位在低地址

## 第四章 C++基础容器
### 数组
概念：代表内存里一组连续的同类型存储区；可以用来把多个存储区合并成一个整体
C语言中数组下标：从0开始，使用非对称区间`[,)`，下届可以取到值，上界取不到值。
   好处：
      1. 取值范围的大小：上界 - 下届；
      2. 如果这个取值范围为空， 上界值 == 下界值
      3. 即使取值范围为空，上界值永远不可能小于下界值。
使用：
  1. 通过下下标可以直接访问任意一个元素
  2. 下标从0开始到元素个数减一为止
  3. 超过范围的下标不可以使用
  4. 数组名称和下标可以表示数组里的元素

优点：
  1. 可以编写循环依次处理数组里的所有元素
  2. 循环变量依次代表所有有效下标

**差一错误**：high - low + 1

### vector数组
`#include <vector>`
引入原因：使用最简单的数组，无法实现动态扩容插入元素，因为容量有限。
- 查询大小：`s.size()`
- 查询容量：`s.capacity()`
- 使用sort对vector排序
  `sort(num.begin(), num.end());`
- 插入数据的方式
  尾插 `push_back(val)`
  尾删 `pop_back()`
  插入 `insert()`
  删除 `erase()`
  清空 `clear()`

### 字符串
**定义方式**：
  `char str[] = {"hello"}`
  `char str[6] = {'h','e','l','l','o'}`
**字符串变量**：
  - 字符串是以空字符('\0')结束的字符数组
  - 空字符 '\0'自动添加到字符串的内部表示中
**字符串常量**：
  - 字符串常量是一对双引号括起来的字符串数组
  - 字符串中每个字符作为一个数组元素存储


**Unicode编码**：目的->把世界上的文字都映射到一套字符空间中
  1. UTF-8：1byte表示字符，可以兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（可作为外部编码）
  2. UTF-16：分为UTF-16BE（big endian）、UTF-16LE(little endian)。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）
  3. UTF-32：分为UTF-32BE、UTF-32LE。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）

**字符串指针**：
  - 指针表示方法： `char* pStr = "hello";`
  - char[] 和 char* 的区别：
    - 地址和地址存储的信息
    - 可变与不可变。
    如果数组指针初始化指向字符串常量，那么这个指针所指内容不可发生改变。
    ``` cpp
    char *ps = "hello";  //字符串常量指针
    char s[] = {"hello"};
    char *ps2 = s;       //字符串变量指针
    ```
    s不可变，s[i]的值可变；
    ps可变，ps[i]的值可不可变取决于所指区间的存储区域是否可变。

**常见操作**：
  `strlen(s)`：返回s的长度
  `strcmp(s1, s2)`: 自左到右按ASCII值大小比较 s1 == s2 返回 0； s1 < s2 返回 -； s1 > s2 返回+；
  `strcpy(s1, s2)`: 复制s2到s1；
  `strncpy(s1, s2, n)` 将字符串s2中前n个字符拷贝到s1中
  `strcat(s1, s2)` 将字符串s2接到s1后面
  `strchr(s1,ch)` 查找ch在s1中第一次出现位置
  `strstr(s1, s2)` 查找s2在s1中第一次出现位置。

### string字符串
`#include <string>`
使用string可以更为方便和安全的管理字符串。
定义：`string s`; `string s = "hello"`; `string s("hello")`; `string s = string("hello")`;
**常用操作**
  - 获取长度：
    - `s.length()` 
    - `s.size()`
    - `s.capacity()` 容量 != 长度
  - 字符串比较：`==` `!=` `>` `>=` `<` `<=`
  - 转换为C风格字符串 char*
    `const char *c_s = s.c_str(); `
  - 可通过下标进行随机访问。
  - 可通过`=`进行字符串拷贝
  - 可通过`+`、`+=`连接字符串

## 第五章 指针
指针的缺点：使用指针是非常危险的行为，可能存在空指针，野指针的问题，并可能造成内存泄漏问题。
优点：指针非常的高效
**C++中内存单元内容与地址**
指针的本质：内存划分内存单元用来存放各种类型的数据。计算机对内存单元进行编号，称为内存地址，决定内存单元在内存中的位置。C++编译器让我们通过名字来访问这些内存位置。
指针定义的基本形式： 指针本身就是一个变量，其符合变量定义的基本形式，存储的是值的地址。对类型T，T*是‘到T的指针’类型。通过一个指针访问所指向地址的过程称为间接访问或引用指针。
  小结：
  1. 一个变量有三个重要信息：
     1. 变量的地址位置
     2. 变量所存的信息
     3. 变量的类型
  2. 指针变量是一个专门用来记录变量的地址的变量，通过指针变量可以间接的访问改变另一个变量的值
### C++中原始指针
1. 一般类型指针T*
2. 指针的数组与数组的指针
   指针的数组 T* t[]
   数组的指针 T (*t)[]
3. const pointer 和 pointer to const
   `char const` 和 `const char` 是等价的。
   看const修饰部分：
   - 看左侧最近的部分
   - 如果左侧没有则看右侧
4. 指向指针的指针 
   `*`操作符具有从右向左的结合性 
   `**`表达式相当于`*(*c)`，必须从里向外逐层求值
5. 未初始化和非法的指针
   如果定义到了一个非法地址，程序会出错，从而终止。
   如果定位到一个可以访问的地址，无意修改了它，这种错误难以捕捉，引发的错误可能与原先用于操作的代码完全不相干。
6. NULL指针
   一个特殊的指针，表示不指向任何东西。这种方法来表示特定的指针目前未指向任何东西
   注意事项：
   对应于一个指针如果已经知道被初始化为什么地址，如果不赋值就设置为NULL
   引用指针前先判断是否为NULL

**杜绝野指针**
if等判断对野指针不起作用，因为没有置NULL
一般有三种情况：
  1. 指针变量没有初始化
  2. 已经释放不用的指针没有置NULL，如delete和free之后的指针
  3. 指针操作超越了变量的作用范围。

没有初始化的，不用的或者超出范围的指针把值置为NULL

### 指针的基本运算
1. `&`与`*`操作符
   `&ch`取出来的是地址
   `*cp`为右值时是指向地址的内容，为左值时为指针。
        `*CP+1`左值非法，`*(cp+1)`为下一位指针对应的
2. `++`与`--`操作符
3. 关于`++++`与`----`等运算符
   编译程序分解成符号的方法是：一个字符一个字符的读入，如果该字符可能组成一个符号，那么读入下一个字符，一直到读入的字符不能再组成一个有意义的符号。 a+++b 相当于 a++ +b

### CPP程序存储区域划分
全局变量、常量在常量区，变量在栈区，动态申请变量在堆区。
![5-11-CPP程序的存储区域划分总结-00_05_34-2022_09_20_14_23_02-(2)](https://cdn.staticaly.com/gh/konsin/images@main/5-11-CPP程序的存储区域划分总结-00_05_34-2022_09_20_14_23_02-(2).6mgazj6rwp00.jpg)
1. 栈和队列
   栈：先进后出
   队列：先进先出
2. 动态分配资源-堆（heap）
   程序通常需要牵涉到三个内存管理器的操作：
   1. 分配某个大小的内存块；
   2. 释放一个之前分配的内存块；
   3. 垃圾收集操作，寻找不再使用的内存块并予以释放。（这个回收策略需要实现性能、实时性、额外开销等各方面的平衡，很难有统一和高效的做法）
   C++做了1、2，Java做了1、3。

### 资源管理方案--RAII(Resource Acquisition Is Initialization)
1. 主流的编程语言中，C++是唯一一个依赖RAII做资源管理的。
2. RAII依托**栈**和**析构函数**，来对所有的资源——包括堆内存在内进行管理。对RAII的使用，使得C++不需要类似Java那样的垃圾收集方法也能有效地对内存进行管理。
3. RAII有些比较成熟的智能指针代表：`std::auto_ptr`、`boost::shared_ptr`

### C++中几种变量对比
栈和堆中的变量对比
| | 栈区| 堆区|
|:------------|:------------|:--------------|
|作用域|函数体内，语句块{}作用域|整个程序范围内，由`new`,`malloc`开始，`delete`、`free`结束|
|编译间大小确定|变量大小范围确定|变量大小不确定，需要运行期确定|
|大小范围|Windows默认栈大小1M，linux默认栈大小8M或10M|所有系统的堆空间上限是接近内存（虚拟内存）的总大小的|
|内存分配方式|地址由高到低减少|地址由低到高增加|
|内容是否可变|可变|可变|
全局静态存储区和常量存储区的变量对比
||全局静态存储区|常量存储区|
|:-|:-|:-|
|存储内容|全局变量，静态变量|常量|
|编译期间大小是否确定|确定|确定|
|内容是否可变|可变|不可变|

### 内存泄漏（Memory Leak）问题
1. 什么是内存泄漏问题：
   指程序中已动态分配的**堆内存由于某种原因程序未释放或无法释放**，造成系统内存的浪费，导致**程序运行速度减慢甚至系统崩溃等严重后果**。
2. 内存泄漏发生原因和排查方式：
   1. 内存泄漏主要发生在**堆内存分配方式**中，即“配置了内存后，所有指向该内存的指针都遗失了”。若缺乏语言这样的垃圾回收机制，这样的内存片就无法归还系统。
   2. 因为内存泄漏属于程序运行中的问题，无法通过编译识别，**所以只能在程序运行过程中来判别和诊断**。
比指针更安全的解决方案
1. 使用更安全的指针-智能指针
2. 不使用指针，使用更安全的方式-引用

### 智能指针
C++中四种常用智能指针: unique_ptr、shared_ptr、weak_ptr、在C++17中已经废弃的auto_ptr
1. `auto_ptr`
   由`new expression`获取对象，在`auto_ptr`对象销毁时，其所管理的对象也会自动被`delete`掉。
   所有权转移：不小心把它传递给另外的智能指针，原来的指针就不再拥有这个对象了。在拷贝/赋值过程中，会直接剥夺指针对原对象内存的控制权，转交给新对象，然后再将**原对象指针置为`nullptr`**。
   `auto_ptr<int> pl(new int(10))`
2. `unique_ptr`
   `unique_ptr`是**专属所有权**，所以`unique_ptr`管理的内存，只能被一个对象持有，不支持复制和赋值。
   移动语义：`unique_ptr`禁止了拷贝语义，但是可以使用 `std::move()`进行控制所有权的转移。
3. `shared_ptr`
   `shared_ptr`**通过一个引用计数共享一个对象**，`shared_ptr`是为了解决`auto_ptr`在对象所有权上的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针。因为引入了引用计数，所以造成了额外的资源浪费，不如`unique_ptr`轻量。
   当引用计数为0时，说明对象没有被使用，可以析构。
   问题：
   循环引用：引用计数会带来循环引用的问题，循环引用会导致堆里的内存无法正常回收，造成内存泄漏。
4. `weak_ptr`
   **`weak_ptr`被设计为与`shared_ptr`共同工作**，用一种观察者模式工作。
   意味着`weak_ptr`只对`shared_ptr`进行引用而不改变其引用计数。

### C++的引用
引用是一种特殊的指针，不允许修改的指针。
：1. 不存在空引用；2. 必须初始化； 3. 一个引用永远指向它初始化的那个对象。
1. 引用的基本使用：可以认为值指定变量的别名，使用时可以认为是变量本身。
   `int& rx = x`, `cout << rx; `等同于`cout << x;`
2. 有了指针为什么还需要引用？ 为了支持函数运算符重载。
3. 有了引用为什么还需要指针？ 为了兼容C语言。

对内置基础类型（int、double等)而言，在函数中传值（pass by value）更高效。
对OO面向对象中自定义类型而言，在函数中传引用(pass by reference to const)更高效。

## 第六章 C++基础句法
单一语句： 在任何一个表达式后面加上分号`;`
复合语句：用一对花括号`{}`括起来的语句块，在语法上等效于一个单一的语句。
### 分支语句
1. `if`语句
if语句是最常用的一种分支语句，也称为条件语句。
（比较好的编程规范是if的花括号不允许不写，即使只是一个单一语句）
```cpp
if(...)
{
  ...
}
else
{
  ...
}
```

2. `switch`语句
```cpp
switch(表达式)
{
  case 常数1: 语句1;  break;
  case 常数2: 语句2;  break;
  ...
  case 常数n: 语句n;  break;
  default: 语句n+1;
}
```
### 枚举结构
1. 使用`#define`和const创建符号常量，而使用enum不仅能够创建符号常量，还能**定义新的数据类型**。
2. 枚举类型enum(enumeration)的声明和定义：
   ```cpp
   enum wT {
    Monday, Tuesday, Wednesday, Tursday, Friday, Saturday, Sunday
   }; //声明枚举类型
   wT weekday; //定义枚举变量
   ```
### 结构体和联合体
1. `struct`定义结构体
   各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
   ```cpp
   struct Student 
   {
      char name[6];
      int age;
      Score s;
   };
   ```
2. `union`定义联合体
   各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。
   联合体的内存大小：1、至少要容纳最大的成员变量 2、必须是所有成员变量类型大小的整数倍
   ```cpp
   union Score
   {
    double sc;
    char level;
   }
   ```
**结构体中内存对齐问题**：综合考虑内存对数据的处理及最大的数据类型所占字节
   缺省对齐原则：
   32位cpu：
   - char: 任何地址
   - short: 偶数地址
   - int: 4的整数倍地址
   - double： 4的整数倍地址
  可以修改默认编译选项,设置内存按n字节寻址
  ```cpp
  //Visual C++：
  #pragma pack(n)

  //g++:
  __attribute__(aligned(n))
  __attribute__(__packed__)
  ```
### 循环语句
1. while循环
2. do while循环
3. for循环

### 函数
函数将一段逻辑封装起来便于复用。一个C++程序是由若干个源程序文件构成，而一个源程序是由若干函数构成。
1. 函数组成部分：
   - 返回类型：一个函数可以返回一个值。
   - 函数名称：是函数的实际名称，函数名和参数列表一起构成了函数签名。(SDK提供的`undname.exe`程序的作用就是为我们还原函数签名。)
   - 参数
   - 函数主体：函数主题包含一组定义函数执行任务的语句。
2. 函数重载overload 与C++ Name Mangling：相同函数名称然后不同参数则是不同的函数。
   `int test(int a);`、`int test(double a);`
3. 指向函数的指针与返回指针的函数
  每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。
  - 一般形式：数据类型(*指针变量名)(参数表)； 如`int(*p)(int);`
  - 与返回指针的函数之间的区别：
    ```cpp
    int(*p)(int); //是指针，指向一个函数入口地址
    int* p(int);  //是函数，返回的值是一个指针
    ```
### 命名空间
命名空间这个概念可作为附加信息来区分不同库中相同名称的函数、类、变量等，命名空间即定义了上下文。
本质上，命名空间就是定义了一个范围。
- 定义命名空间
  ```cpp
  namespace konsin
  {
    int test(int a);
  }
  ```
- 使用命名空间，可以再函数内声明这个函数使用的命名空间，也可以全局
  ```CPP
  using namespace konsin; //使用命名空间内所有的函数

  using konsin::test; //使用命名空间内的test函数

  konsin::test(a);  //直接调用命名空间内的test函数
  ```
### 内联函数（inline）
如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。
目的是为了解决程序中函数调用的效率问题。（空间换时间）
注意：内联函数内部不能有太复杂的逻辑，编译器有事会有自己的优化策略，内联不一定起作用。
```cpp
inline int test(){};
```
### 递归
递归背后的数学逻辑是数学归纳法。

递归四个基本准则：
1. 基准情形：无需递归就能解出；
2. 不断推进：每一次递归调用都必须使求解状况朝接近基准情形的方向推进；
3. 设计法则：假设所有的递归调用都能运行；
4. 合成效益法则：求解一个问题的同一个实例时，切勿在不同递归调用中做重复性工作。

递归的缺陷:
1. 空间上需要开辟大量的栈空间。
2. 时间上可能需要有大量的重复运算。
  
递归的优化：
1. 尾递归：所有递归形式的调用都出现在函数的末尾；
2. 使用循环代替
3. 使用动态规划，空间换时间。
  
## 第七章 C++高级语法
### 面向对象
面向对象是软件工程发展到一定阶段为了管理代码和数据提出的一种方法，没有解决以前解决不了的问题，不是万能的。

**面向对象三大特性**：封装，继承，多态。
1. 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问，封装可以使得代码模块化。
2. 继承性：让某种类型对象获得另一个类型对象的属性和方法，继承可以扩展已存在的代码。
3. 多态性：同一事物表现出不同事物的能力，即面向不同对象会产生不同的行为，多态的目的则是为了接口重用。

**面向对象的误区**
1. 对象是对现实世界中具体物体的反映，继承是对物体分类的反映？
   错，类只是一个概念的抽象，而不是对现实世界的反映。
2. 面对变化，尽可能少修改原有的逻辑，要扩充逻辑。

### 类
C++使用struct、class来定义一个类，struct的默认成员权限是public，class的默认成员权限是private。
成员权限有：public、protected、private。
1. 构造类Complex `class Complex{}`
2. 构造函数：定义方法`Complex();`,不需要指定返回值类型。在实例化类对象时会自动调用构造函数创建类对象。系统会自动生成一个无参数的默认构造函数，而手动创建有参数的构造函数之后，则系统不会再去创建默认构造函数，会引起部分情况下错误。因此如果手动创建了构造函数，则也需要手动定义无参数的构造函数。
3. 析构函数：定义方法`virtual ~Complex();`，不需要指定返回值类型。在销毁对象时自动调用。
   `virtual`关键字用于实现多态，子类可以重写父类的函数。
4. 运算符重载：
   如果不需要改变变量的值则需要加`const`，具体区分看`+`号重载和`=`号重载
   - 加、减、乘、除符号重载声明：
   ```cpp 
    Complex operator+ (const Complex& x) const {
      return Complex(ref + x.ref);
    }
    ```
   - 等号重载声明
    ```cpp
    Complex& operator= (const Complex& c) {
	    if (this != &c) {
        ref = c.ref;
	    }
	    return *this;
    };
    ```
     - ++、--重载
     ```cpp
    Complex& Complex::operator++ () {
     	ref++;
     	return *this;
    }

    Complex Complex::operator++ (int) {
     	return Complex(ref++);
    }
     ``` 
    - <<、>>流运算符重载。
    标准流无法直接访问类的private属性，此时可以采用友元来解决。
      - 友元函数：在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。
      - 友元类：一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。

    ```cpp
    friend ostream& operator<<(ostream& os, const Complex &x) {
     	os << "value is  " << x.ref;
     	return os;
    }

    friend istream& operator >> (istream& is, Complex &x) {
     	is >> x.ref;
     	return is;
     }
    ```
   
### IO流
1. C和C++中I/O流对比：
   传统的C中I/O有printf、scanf等函数：
   1. 不可编程，仅仅能识别固有的数据类型
   2. 代码可移植性差，有很多的坑。
   C++中I/O流istream和ostream等：
   1. 可编程，对于类库的设计者来说很有用。
   2. 简化编程，能使得I/O的风格一致。

2. C++中I/O流类层次结构图
|类名|作用|在哪个头文件中声明|
|:-|:-|:-|
|ios|抽象基类|iostream|
||||
|istream|通用输入流和其他输入流的基类|iostream|
|ostream|通用输出流和其他输出流的基类|iostream|
 ||通用输入||
|iostream |输出流和其他输入输出流的基类|iostream|
||||
|ifstream|输入文件流类|fstream|              
|ofstream|输出文件流类|fstream| 
|fstream|输入输出文件流类|fstream|
||||
|istrstream|输入字符串流类|strstream|
|ostrstream|输出字符串流类|strstream|
|strstream|输入输出字符串流类|strstream|
3. IO缓存区
   标准IO提供三种类型的缓存模式：
      1. 按块缓存：如文件系统
      2. 按行缓存：\n
      3. 不缓存。
### 文件操作
1. 文件操作步骤
   1. 打开文件用于读和写 open；
      文件打开方式：
      - ios::in 打开文件进行读操作（ifstream默认模式）
      - ios::out 打开文件进行写操作（ofstream默认模式）
      - ios::ate 打开一个已有输入或输出文件并查找到文件尾
      - ios::app 打开文件以便再文件尾部添加数据
      - ios::nocreate 如果文件不存在则打开失败
      - ios::trunc 如果文件存在，清除文件原有内容
      - ios::binary 以二进制方式打开  
      `fstrream f;`、 `f.open("x.text", ios::app | ios::binary);`。
   2. 检查打开是否成功 fail；
      `if(!f)` 或者 `if(f.fail)`
   3. 读或者写 read，write；
      `streamsize count = f.gcount();`获取读取到数据大小 。
   4. 检查是否读完 EOF (end of file)；
      `while (!f.eof())`
   5. 使用完文件后关闭文件 close;
      `f.close();`

### 头文件重复包含问题
避免同一个文件被include多次的方式：
1. 使用宏来防止同一文件被多次包含
   ```cpp
   #ifndef __SOMEFILE_H__
   #define __SOMEFILE_H__
   ···
   #endif
   ```
   优点：可移植性好；
   缺点：无法防止宏名重复，难以排错。
2. 使用编译器来防止同一文件被多次包含
   `#pragma once`
   优点：可以防止宏名重复，易排错。
   缺点：可移植性不好。

### 深拷贝和浅拷贝
浅拷贝：只拷贝指针地址，C++默认拷贝构造函数与赋值运算符重载都是浅拷贝。节省空间，但容易引发多次释放。
深拷贝：**重新分配堆内存**，拷贝指针指向内容。浪费空间，但不会导致多次释放。

## 第八章 C++编程思想