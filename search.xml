<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM64系统安装softether</title>
    <url>/2019/06/30/ARM64%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85softether/</url>
    <content><![CDATA[<h1 id="ARM64系统安装softether"><a href="#ARM64系统安装softether" class="headerlink" title="ARM64系统安装softether"></a>ARM64系统安装softether</h1><p>官方文档 <a href="https://github.com/SoftEtherVPN/SoftEtherVPN/blob/master/src/BUILD_UNIX.md">https://github.com/SoftEtherVPN/SoftEtherVPN/blob/master/src/BUILD_UNIX.md</a> </p>
<p>安装依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt -y install cmake gcc g ++ libncurses5-dev libreadline-dev libssl-dev make zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>git下载源码包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<p>编辑makefile文件去掉 所有的<code>-m64</code></p>
<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成</p>
<p>启动/停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vpnserver start</span><br><span class="line">vpnserver stop</span><br></pre></td></tr></table></figure>

<p>配置服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vpncmd</span><br><span class="line">1 </span><br></pre></td></tr></table></figure>

<p>输入<code>ServerPasswordSet</code>配置管理员密码.</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
  </entry>
  <entry>
    <title>Android实现Spinner重复监听</title>
    <url>/2021/03/26/Android_%E5%AE%9E%E7%8E%B0Spinner%E9%87%8D%E5%A4%8D%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<p>首先重构Spinner类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.Spinner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重构spinner以实现点击重复的选项仍然监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReSpinner</span> <span class="keyword">extends</span> <span class="title class_">Spinner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isDropDownMenuShown=<span class="literal">false</span>;<span class="comment">//标志下拉列表是否正在显示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReSpinner</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReSpinner</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReSpinner</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">    <span class="title function_">setSelection</span><span class="params">(<span class="type">int</span> position, <span class="type">boolean</span> animate)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameSelected</span> <span class="operator">=</span> position == getSelectedItemPosition();</span><br><span class="line">        <span class="built_in">super</span>.setSelection(position, animate);</span><br><span class="line">        <span class="keyword">if</span> (sameSelected) &#123;</span><br><span class="line">            <span class="comment">// 如果选择项是Spinner当前已选择的项,则 OnItemSelectedListener并不会触发,因此这里手动触发回调</span></span><br><span class="line">            getOnItemSelectedListener().onItemSelected(<span class="built_in">this</span>, getSelectedView(), position, getSelectedItemId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">performClick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isDropDownMenuShown = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.performClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDropDownMenuShown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDropDownMenuShown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDropDownMenuShown</span><span class="params">(<span class="type">boolean</span> isDropDownMenuShown)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.isDropDownMenuShown=isDropDownMenuShown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span></span><br><span class="line">    <span class="title function_">setSelection</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameSelected</span> <span class="operator">=</span> position == getSelectedItemPosition();</span><br><span class="line">        <span class="built_in">super</span>.setSelection(position);</span><br><span class="line">        <span class="keyword">if</span> (sameSelected) &#123;</span><br><span class="line">            getOnItemSelectedListener().onItemSelected(<span class="built_in">this</span>, getSelectedView(), position, getSelectedItemId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDetachedFromWindow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将布局文件的标签修改为重构的View类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里使用了自定义控件的全路径名称 --&gt;</span><span class="tag">&lt;<span class="name">com.example.common.util.ReSpinner</span></span></span><br><span class="line"><span class="tag">      <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C++与正则表达式</title>
    <url>/2022/10/19/C-%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><p>   C++中正则表达式的API基本上都位于<code>&lt;regex&gt;</code>头文件中。<code>#include &lt;regex&gt;</code><br>   引入正则后，定义正则表达式：<code>regex ex(string)</code></p>
<h2 id="基本的正则文法（regex-syntaxes）"><a href="#基本的正则文法（regex-syntaxes）" class="headerlink" title="基本的正则文法（regex syntaxes）"></a>基本的正则文法（regex syntaxes）</h2><p>std::regex默认使用是ECMAScript文法，这种文法比较好用，且威力强大，常用符号的意义如下：</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>^</code></td>
<td align="left">匹配行的开头</td>
</tr>
<tr>
<td align="left"><code>$</code></td>
<td align="left">匹配行的结尾</td>
</tr>
<tr>
<td align="left"><code>.</code></td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left"><code>[…]</code></td>
<td align="left">匹配[]中的任意一个字符</td>
</tr>
<tr>
<td align="left"><code>(…)</code></td>
<td align="left">设定分组</td>
</tr>
<tr>
<td align="left"><code>\</code></td>
<td align="left">转义字符</td>
</tr>
<tr>
<td align="left"><code>\d</code></td>
<td align="left">匹配数字[0-9]</td>
</tr>
<tr>
<td align="left"><code>\D</code></td>
<td align="left">\d 取反</td>
</tr>
<tr>
<td align="left"><code>\w</code></td>
<td align="left">匹配字母[a-z]，数字，下划线</td>
</tr>
<tr>
<td align="left"><code>\W</code></td>
<td align="left">\w 取反</td>
</tr>
<tr>
<td align="left"><code>\s</code></td>
<td align="left">匹配空格</td>
</tr>
<tr>
<td align="left"><code>\S</code></td>
<td align="left">\s 取反</td>
</tr>
<tr>
<td align="left"><code>+</code></td>
<td align="left">前面的元素重复1次或多次</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">前面的元素重复任意次</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">前面的元素重复0次或1次</td>
</tr>
<tr>
<td align="left"><code>&#123;n&#125;</code></td>
<td align="left">前面的元素重复n次</td>
</tr>
<tr>
<td align="left"><code>&#123;n,&#125;</code></td>
<td align="left">前面的元素重复至少n次</td>
</tr>
<tr>
<td align="left"><code>&#123;n,m&#125;</code></td>
<td align="left">前面的元素重复至少n次，至多m次</td>
</tr>
<tr>
<td align="left"><code>|</code></td>
<td align="left">逻辑或</td>
</tr>
</tbody></table>
<h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p>匹配是判断给定的字符串是否符合某个正则表达式。使用<code>regex_match</code>函数，匹配成功返回<code>true</code>。<br><code>bool ret = std::regex_match(string_given, ex);</code><br>如果要获得匹配结果可以使用<code>regex_match</code>的重载形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cmatch cm; <span class="comment">//C风格字符串。</span></span><br><span class="line">std::smatch sm; <span class="comment">//string字符串，sm.str()获取值</span></span><br><span class="line"><span class="keyword">auto</span> ret = std::<span class="built_in">regex_match</span>(string_given, m, ex));</span><br></pre></td></tr></table></figure>
<h2 id="正则搜索"><a href="#正则搜索" class="headerlink" title="正则搜索"></a>正则搜索</h2><p>搜索是在一大段文本中搜索匹配的目标,并非完全匹配。。使用<code>regex_search</code><br>使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">regex_search</span>(string_given, ex);</span><br><span class="line"><span class="built_in">regex_search</span>(string_given, match, ex); <span class="comment">//match保存搜索结果</span></span><br></pre></td></tr></table></figure>
<h2 id="正则分割（Tokenize）"><a href="#正则分割（Tokenize）" class="headerlink" title="正则分割（Tokenize）"></a>正则分割（Tokenize）</h2><p>C++没有提供很快捷的字符串分割算法，可以用正则。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">mail</span><span class="params">(<span class="string">&quot;123@qq.vip.com,456@gmail.com,789@163.com,abcd@my.com&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::sregex_token_iterator <span class="title">pos</span><span class="params">(mail.begin(), mail.end(), reg, <span class="number">-1</span>)</span></span>; <span class="comment">//-1表示获取正则匹配序列之前的字符串。0表示匹配的子串</span></span><br><span class="line">std::sregex_token_iterator end;</span><br><span class="line"><span class="keyword">for</span> (; pos != end; ++pos)   <span class="comment">//遍历分割后的数组</span></span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; pos-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h2><p>正则表达式内容替换为指定内容，使用<code>regex_replace</code>方法。<br><code>string r = regex_replace(pre_str, ex, need_str);</code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian-Pi-arch64 安装nextcloud</title>
    <url>/2019/11/25/Debian-Pi-arch64%20%E5%AE%89%E8%A3%85nextcloud/</url>
    <content><![CDATA[<h1 id="Debian-Pi-arch64-安装nextcloud"><a href="#Debian-Pi-arch64-安装nextcloud" class="headerlink" title="Debian-Pi-arch64 安装nextcloud"></a>Debian-Pi-arch64 安装nextcloud</h1><p>安装nextcloud过程中出现了,工具安装问题,u盘不能读取问题,NTFS格式U盘会提示0770权限问题的错误,下面详细说明下怎么解决的这些问题</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>这里我们使用apache2作为服务器，通过以下命令安装apache2.80端口被封的话自己改端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install apache2</span><br></pre></td></tr></table></figure>

<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>NextCloud可用的数据库有MySQL/MariaDB，PostgreSQL，Oracle。官方推荐MySQL/MariaDB，这里以mysql为例，执行以下指令安装mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install mysql-server</span><br><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>期间会让你设置root密码和密码强度，请自行判断。</p>
<p>进入mysql命令界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database nextcloud;</span><br></pre></td></tr></table></figure>

<p>再为NextCloud创建一个数据库用户:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;your_username&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;your_passwd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>your_username</code>是用户名,<code>localhost</code>指明只能通过本地访问。要想通过远程访问可改为<code>remote</code>同时配置你的mysql访问策略。<code>your_passwd</code>即所对应的密码。<br> 如果遇到<code>Your password does not satisfy the current policy requirements</code> 问题，这是因为你的密码强度级别设置太高，通过<code>set global validate_password_policy=0</code>可以设置为最低级别，关于密码强度的说明请参考百度。</p>
<p>为所创建的用户授予权限:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> nextcloud.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;your_username&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;your_passwd&#x27;</span>;</span><br><span class="line">flush privileges;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>到此数据库的部分已经完成了。</p>
<h3 id="运行环境要求"><a href="#运行环境要求" class="headerlink" title="运行环境要求"></a>运行环境要求</h3><p>执行下面的命令安装php</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install php</span><br></pre></td></tr></table></figure>

<p>官方要求php5.0+，通过以下指令查看php版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure>

<p>然后安装NextCloud所需的其它php依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install php-zip</span><br><span class="line">apt-get install php-dompdf</span><br><span class="line">apt-get install php-xml</span><br><span class="line">apt-get install php-mbstring</span><br><span class="line">apt-get install php-curl</span><br><span class="line">apt-get install php-mysql</span><br></pre></td></tr></table></figure>

<p>到此环境配置已经完成,</p>
<h2 id="配置nextcloud"><a href="#配置nextcloud" class="headerlink" title="配置nextcloud"></a>配置nextcloud</h2><p>已经将从官网下载的安装包上传到服务器</p>
<p>下面进行解压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xjf nextcloud-XX.XX.tar.bz2</span><br></pre></td></tr></table></figure>

<p>更改文件权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown -R root:root nextcloud</span><br></pre></td></tr></table></figure>

<p>移动文件到<code>/var/www/html/</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv nextcloud /var/www/html</span><br></pre></td></tr></table></figure>

<p>这时已经可以在浏览器输入<code>http://localhost/nextcloud</code>访问了</p>
<p>但是还存在一堆问题.现在切换到root用户开始更改配置文件.</p>
<p>打开config.php文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano /var/www/html/nextcloud/config</span><br></pre></td></tr></table></figure>

<p>配置储存盘/数据目录.我是将NTFS格式的U盘挂载到了<code>/home/pi/mydisk/</code>并创建了nextcloud文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;datadirectory&#x27; =&gt; &#x27;/home/pi/mydisk/nextcloud&#x27;,</span><br></pre></td></tr></table></figure>

<p>当提示数据目录要0770权限时:</p>
<p>在nextcloud目录下config/config.php文件中加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;check_data_directory_permissions&#x27; =&gt; false</span><br></pre></td></tr></table></figure>

<p>这一条语句是取消文件权限检测.</p>
<h2 id="添加离线下载功能"><a href="#添加离线下载功能" class="headerlink" title="添加离线下载功能"></a>添加离线下载功能</h2><p>安装ocDownload插件.</p>
<p>安装aria2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install aria2 curl php-curl</span><br></pre></td></tr></table></figure>

<p>配置aria2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/log/aria2c /var/local/aria2c</span><br><span class="line">touch /var/log/aria2c/aria2c.log</span><br><span class="line">touch /var/local/aria2c/aria2c.sess</span><br><span class="line">chown www-data.www-data -R /var/log/aria2c /var/local/aria2c</span><br><span class="line">chmod 770 -R /var/log/aria2c /var/local/aria2c</span><br><span class="line">sudo -u www-data aria2c --enable-rpc --rpc-allow-origin-all -c -D --log=/var/log/aria2c/aria2c.log --check-certificate=false --save-session=/var/local/aria2c/aria2c.sess --save-session-interval=2 --continue=true --input-file=/var/local/aria2c/aria2c.sess --rpc-save-upload-metadata=true --force-save=true --log-level=warn --rpc-listen-all=false</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Debian</tag>
        <tag>Linux</tag>
        <tag>Nextcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>EclipseRCP框架</title>
    <url>/2022/10/24/EclipseRCP%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>基于RCP3.x进行学习。</p>
<h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><ol>
<li><p>Display<br> 应用程序一般只需要一个Display对象，该对象实际是一个SWT对象,代表了底层图形系统的实现。<br> Display的主要任务是事件处理，负责从操作系统的时间队列中读取事件，传递给RCP的事件监听器以便完成具体的任务。<br> <code>Display display = new Display()</code></p>
</li>
<li><p>Shell<br> 每一个窗口都有一个Shell对象。Shell对象代表了与用户交互的窗口框架，并处理与窗口关联的诸如移动、改变大小等常见行为。<br> <code>Shell shell = new Shell(display);</code> 或者 <code>Shell shell = Display.getCurrent().getActiveShell();</code></p>
</li>
<li><p>Workbench<br>Workbench是工作台，代表用户界面的UI元素。有各种窗口、图标、按钮和空间，用户可以在工作台上做各种操作。<br><code>IWorkbench wb = PlatformUI.getWorkbench();</code><br>方法：</p>
<ul>
<li><code>wb.restart()</code>，关闭应用程序并立即重新启动。</li>
<li><code>wb.close()</code>，正常关闭应用程序。</li>
</ul>
</li>
<li><p>Advisor<br> 配置用户主界面宽度、高度、图标、菜单、工具栏、颜色、操作等。</p>
<ul>
<li>WorkbenchAdvisor。应用程序级别。每个应用程序只有一个Workbench，WorkbenchAdvisor负责该工作台生命周期的管理，也负责该Workbench的异常处理，并负责向Workbench提供一些重要参数。</li>
<li>WorkbenchWindowAdvisor。窗口级别。每一个窗口都有一个WorkbenchWindowAdvisor实例。负责具体窗口生命周期的管理，也可以处理窗口的各种事件例程。</li>
<li>ActionBarAdvisor。窗口级别。每一个窗口都有，负责管理窗口菜单栏、状态栏、工具栏的外观和行为。</li>
</ul>
</li>
<li><p>View和Editor<br>用户通过视图和编辑器来与程序交互。视图是可以浮动的工作窗口，负责显示。编辑器提供对数据进行各种操作的交互能力。</p>
</li>
<li><p>Perspective<br>Perspective被称之为透视图，RCP程序通过透视图对窗口内容进行安排和布局，应用程序都有一个默认的透视图，每个工作台窗口则包含一个或多个透视图。透视图需要实现IPerspectiveFactory接口。IPerspectiveFactory可以说是产生初始页面布局和可视性透视图的工厂。</p>
<h2 id="生成的类文件分析"><a href="#生成的类文件分析" class="headerlink" title="生成的类文件分析"></a>生成的类文件分析</h2></li>
<li><p>Application.java<br>RCP程序运行开始于Application，Application实现了IPlatformRunnable接口，在RCP启动时将执行start方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> <span class="keyword">implements</span> <span class="title class_">IApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">start</span><span class="params">(IApplicationContext context)</span> &#123;</span><br><span class="line">	<span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> PlatformUI.createDisplay();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//应用程序主窗口只在该句调用之后才会打开并可视化。主窗口启动之后将处于持续打开状态直到用户关闭程序。</span></span><br><span class="line">           <span class="comment">//在打开主窗口之前可以进行用户登录，连接数据库等操作。</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">returnCode</span> <span class="operator">=</span> PlatformUI.createAndRunWorkbench(display, <span class="keyword">new</span> <span class="title class_">ApplicationWorkbenchAdvisor</span>()); </span><br><span class="line">		<span class="keyword">if</span> (returnCode == PlatformUI.RETURN_RESTART) &#123;</span><br><span class="line">			<span class="keyword">return</span> IApplication.EXIT_RESTART;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> IApplication.EXIT_OK;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		display.dispose();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RCP框架</tag>
      </tags>
  </entry>
  <entry>
    <title>FLASK入门</title>
    <url>/2020/06/10/FLASK%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="FLASK入门"><a href="#FLASK入门" class="headerlink" title="FLASK入门"></a>FLASK入门</h1><ol>
<li><p>装饰器: 函数前使用<code>@app.*</code></p>
<p><code>route(&#39;/&#39;)</code>设置url 路径,’/‘为根目录</p>
</li>
<li><p>变量规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@app.route(&#x27;/user/&lt;username&gt;&#x27;)</span><br><span class="line">def show_user_profile(username):</span><br><span class="line">    # 显示用户名</span><br><span class="line">    return &#x27;User &#123;&#125;&#x27;.format(username)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)</span><br><span class="line">def show_post(post_id):</span><br><span class="line">    # 显示提交整型的用户&quot;id&quot;的结果，注意&quot;int&quot;是将输入的字符串形式转换为整型数据</span><br><span class="line">    return &#x27;Post &#123;&#125;&#x27;.format(post_id)</span><br></pre></td></tr></table></figure>

<p>转换器类型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>默认的数据类型，接受没有任何斜杠“/”的字符串</td>
</tr>
<tr>
<td>int</td>
<td>接受整型</td>
</tr>
<tr>
<td>float</td>
<td>接受浮点类型</td>
</tr>
<tr>
<td>path</td>
<td>和 string 类似，但是接受斜杠“/”</td>
</tr>
<tr>
<td>uuid</td>
<td>只接受 uuid 字符串</td>
</tr>
</tbody></table>
</li>
<li><p>Urls</p>
<p><strong>重定向</strong></p>
<p>在代码的 URL 设置时斜线只可多写不可少写；</p>
<p><code>@app.route(&#39;/about&#39;)</code></p>
<p>当访问 <code>http://127.0.0.1:5000/about</code> 时，页面会显示 <code>The about page</code> ；但是当访问 <code>http://127.0.0.1:5000/about/</code> 时，页面就会报错 <code>Not Found</code> 。</p>
<p><code>@app.route(&#39;/about/&#39;)</code>都可以访问</p>
<p>用 <code>redirect()</code> 函数重定向用户到其它地方。能够用 <code>abort()</code> 函数提前中断一个请求并带有一个错误代码。</p>
<p><strong>URL构建</strong></p>
<p>去构建一个 URL 来匹配一个特定的函数可以使用 <code>url_for()</code> 方法。</p>
<p><code>url_for(&#39;static&#39;, filename=&#39;style.css&#39;)</code>这个文件应该存储在文件系统上的 static/style.css 。</p>
</li>
<li><p>渲染模板</p>
<p> <code>render_template()</code> 来渲染模板,<code>render_template(&#39;hello.html&#39;, name=name)</code></p>
</li>
<li><p>请求对象</p>
<p><code>from flask import request</code></p>
<p><code>@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;, &#39;GET&#39;])</code>装饰器声明方法</p>
<p><code>  if request.method == &#39;POST&#39;:</code>判断方法</p>
<p> <code>log_the_user_in(request.form[&#39;username&#39;]) </code> request请求表单属性</p>
</li>
<li><p>文件上传</p>
<p>HTML表单中需要设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> secure_filename</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/upload&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload_file</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        f = request.files[<span class="string">&#x27;the_file&#x27;</span>]</span><br><span class="line">        f.save(<span class="string">&#x27;/var/www/uploads/&#x27;</span> + secure_filename(f.filename))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-scoketio_API</title>
    <url>/2020/06/10/Flask-scoketio_API/</url>
    <content><![CDATA[<h2 id="API-Reference"><a href="#API-Reference" class="headerlink" title="API Reference"></a>API Reference</h2><ol>
<li><p><em><strong>class</strong></em> flask_socketio.<code>SocketIO(*app=None*, ***kwargs*)</code></p>
<p>创建一个Flask-ScoketIO服务</p>
<p>参数:</p>
<p>​        <strong>app</strong> = flask应用程序实例。如果在实例化此类时不知道应用程序实例，则在应用程序实例可用后调用。<code>socketio.init_app(app)</code></p>
<p>​        <strong>manage_session</strong> = 如果设置为 True，则此扩展将管理Socket.IO事件的用户会话。如果设置为False ，则使用 Flask 自己的会话管理。使用基于 Flask 的 Cookie 会话时，建议您将此集保留为 默认值True 。使用服务器端会话时，设置False 允许在 HTTP 路由和Socket.IO事件之间共享用户会话。</p>
<p>​        <strong>message_queue</strong> = 服务器可用于多进程通信的消息队列服务的连接 URL。使用单个服务器进程时不需要消息队列。</p>
<p>​        <strong>channel</strong>= 使用消息队列时通道名称。如果未指定通道，将使用默认通道。如果多个 SocketIO 进程群集需要使用相同的消息队列而不相互干扰，则每个群集应使用不同的通道。</p>
<p>​        <strong>path</strong>= Socket.IO服务器公开的路径。默认值为<code>&#39;socket.io&#39;</code> 。除非你知道你在做什么，否则请保持默认。</p>
<p>​        <strong>resource</strong> = 同 <code>path</code>.</p>
<p>​        <strong>kwargs</strong> = Socket.IO和Engine.IO服务器选项。</p>
</li>
<li><p>下面详细介绍了Socket.IO服务器选项：</p>
<p>参数:</p>
<p>​        <strong>client_manager</strong> = 将管理客户端列表的客户端管理器实例。省略此选项后，客户端列表存储在内存结构中，因此无法使用多连接的服务器。在大多数情况下，不需要显式设置此参数。</p>
<p>​        <strong>logger</strong> = True启用日志记录集或传递记录器对象才能使用。Fasle禁用日志记录集 。默认值为False 。请注意，即使设置为False，也会记录致命错误。</p>
<p>​        <strong>binary</strong>= 支持二进制有效负载，将所有有效负载视为文本。在 Python 2 上，如果设置为True，则值将被视为文本，并且值将字符串<code>str</code>和字节<code>bytes</code>视为二进制值。此选项对 Python 3 没有影响.</p>
<p>​        <strong>json</strong> = 用于编码和解码数据包的替代 json 模块。自定义 json 模块必须具有与标准库版本兼容的 <code>dumps</code>和<code>loads</code>功能。要使用与 Flask 应用程序相同的 json 编码器和解码器，请使用flask.json 。</p>
<p>​        <strong>async_handlers</strong> = 如果设置为True ，则客户端的事件处理程序在单独的线程中执行。要同步运行客户端的处理程序，应设置为False 。默认值为 True。</p>
<p>​        <strong>always_connect</strong> = 设置为False时，新连接是证明的，直到连接处理程序返回其他连接False，此时它们被接受。当设置为True时，将立即接受连接，然后如果连接处理程序返回False断开连接。如果需要从连接处理程序发出事件，并且客户端在连接接受之前接收事件时，设置为True。在任何其他情况下使用默认值Fasle 。</p>
</li>
<li><p>Engine.IO服务器配置支持以下设置：</p>
<p>参数: </p>
<p>​        <strong>async_mode</strong> = 使用异步模型。有关可用选项的说明，请参阅文档中的”部署”部分。有效的异步模式为<code>threading</code>, <code>eventlet</code>, <code>gevent</code>和<code>gevent_uwsgi</code>。如果未给出此参数，则首先尝试<code>eventlet</code>，然后<code>gevent_uwsgi</code>，<code>gevent</code>,最后<code>threading</code>。安装了其所有依赖项的第一个异步模式是所选的。</p>
<p>​        <strong>ping_timeout</strong> = 客户端等待服务器在断开连接前响应的时间（以秒为单位）。默认值为 60 秒。</p>
<p>​        <strong>ping_interval</strong> = 客户端 ping 服务器的时间间隔（以秒为单位）。默认值为 25 秒。</p>
<p>​        <strong>max_http_buffer_size</strong> = 使用轮询传输时消息的最大大小。默认值为 100，000，000 字节。</p>
<p>​        <strong>allow_upgrades</strong> – 是否允许上传。默认值为 <code>True</code></p>
<p>​        <strong>http_compression</strong> = 使用轮询传输时是否压缩packages。默认值为 <code>True</code></p>
<p>​        <strong>compression_threshold</strong> = 仅当消息的字节大小大于此值时，才压缩消息。默认值为 1024 字节。</p>
<p>​        <strong>cookie</strong> = 包含客户端会话 ID 的 HTTP Cookie 的名称。如果设置为 None，则 Cookie 不会发送到客户端。默认值为 <code>&#39;io&#39;</code></p>
<p>​        <strong>cors_allowed_origins</strong> = 允许连接到此服务器的原点或源列表。默认情况下只允许相同的原点。将此参数设置为<code>&#39;*&#39;</code>允许所有源，或<code>[]</code>禁用 CORS 处理。</p>
<p>​        <strong>cors_credentials</strong> = 是否允许凭据（cookie、身份验证）用于此服务器的请求。默认值为 True</p>
<p>​        <strong>monitor_clients</strong> = 如果设置为True ，后台任务将确保关闭非活动客户端。设置为False禁用监视任务（不推荐）。默认值为 True</p>
<p>​        <strong>engineio_logger</strong> = 若要启用Engine.IO日志记录，请将其设置为True或传递要使用的记录器对象。要禁用日志记录，请设置为False。默认值为False。请注意，即使engineio_logger为False，也会记录致命错误。</p>
</li>
<li><p><strong><code>on</code>(<em>message</em>, <em>namespace=None</em>)</strong></p>
<p>用于注册 SocketIO 事件处理程序的修饰器。</p>
<p>此修饰器必须应用于 SocketIO 事件处理程序。例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on(<span class="params"><span class="string">&#x27;my event&#x27;</span>, namespace=<span class="string">&#x27;/chat&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_my_custom_event</span>(<span class="params">json</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;received json: &#x27;</span> + <span class="built_in">str</span>(json))</span><br></pre></td></tr></table></figure>

<p>参数: </p>
<p>​        <strong>message</strong>–事件的名称。这通常是用户定义的字符串，但已经定义了一些事件名。使用<code>&#39;message&#39;</code>定义接受字符串负载的处理程序，<code>&#39;json&#39;</code>定义接受json blob负载的处理程序，<code>&#39;connect&#39;</code>或<code>&#39;disconnect&#39;</code>为连接和断开连接事件创建处理程序。</p>
<p>​        <strong>namespace</strong>= 要注册处理程序的命名空间。默认值为全局命名空间</p>
</li>
<li><p><strong><code>on_error</code>(<em>namespace=None</em>)</strong></p>
<p>用于为 SocketIO 事件定义自定义错误处理程序。</p>
<p>此修饰器可以应用于充当命名空间的错误处理程序的函数。当 SocketIO 事件处理程序引发异常时，将调用此处理程序。处理程序函数必须接受一个参数，这是引发的异常。例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error(<span class="params">namespace=<span class="string">&#x27;/chat&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_error_handler</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;An error has occurred: &#x27;</span> + <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

<p>参数: </p>
<p>​        <strong>namespace</strong>= 要为其注册错误处理程序的命名空间。默认值为全局命名空间。</p>
</li>
<li><p><strong><code>on_error_default</code>(<em>exception_handler</em>)</strong></p>
<p>用于定义 SocketIO 事件的默认错误处理程序。</p>
<p>此修饰器可以应用于充当没有特定处理程序的任何命名空间的默认错误处理程序的函数。例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@socketio.on_error_default</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error_handler</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;An error has occurred: &#x27;</span> + <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>on_event</code>(<em>message</em>, <em>handler</em>, <em>namespace=None</em>)</strong></p>
<p>注册 SocketIO 事件处理程序。</p>
<p><code>on_event</code>不需要修饰器,例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">on_foo_event</span>(<span class="params">json</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;received json: &#x27;</span> + <span class="built_in">str</span>(json))</span><br><span class="line"></span><br><span class="line">socketio.on_event(<span class="string">&#x27;my event&#x27;</span>, on_foo_event, namespace=<span class="string">&#x27;/chat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>​        <strong>message</strong>= 事件的名称。这通常是用户定义的字符串，但几个事件名称已定义。<code>&#39;message&#39;</code>用于定义采用字符串有效负载的处理程序、<code>&#39;json&#39;</code>定义获取 JSON Blob 负载的处理程序， <code>&#39;connect&#39;</code>  或<code>&#39;disconnect&#39;</code>为连接和断开连接事件创建处理程序。</p>
<p>​        <strong>handler</strong>= 处理事件的函数。</p>
<p>​        <strong>namespace</strong>= 要注册处理程序的命名空间。默认值为全局命名空间</p>
</li>
<li><p><em><em><code>emit</code>(<em>event</em>, args</em>, <em>kwargs</em>)</em>*</p>
<p>发出服务器生成的 SocketIO 事件。</p>
<p>此函数向一个或多个连接的客户端发出 SocketIO 事件。JSON blob 可以作为有效负载附加到事件。此功能可以在 SocketIO 事件上下文之外使用，因此，当服务器是事件的发起者时，在任何客户端上下文之外（如常规 HTTP 请求处理程序或后台任务中）都可以使用。例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/ping&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>():</span><br><span class="line">    socketio.emit(<span class="string">&#x27;ping event&#x27;</span>, &#123;<span class="string">&#x27;data&#x27;</span>: <span class="number">42</span>&#125;, namespace=<span class="string">&#x27;/chat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p>​        <strong>event</strong> = 要发出的用户事件的名称。<br>​        <strong>args</strong>= 包含 JSON 数据作为有效负载发送的字典。<br>​        <strong>namespace</strong>= 要发送消息的命名空间。默认值为全局命名空间。<br>​        <strong>room</strong>= 将消息发送给给定房间中的所有用户。如果未包含此参数，则事件将发送给所有已连接的用户。<br>​        <strong>include_self</strong> - 设置为True在广播或寻址房间时包括发件人，设置为False发送给（除发件人）所有人<br>​        <strong>skip_sid</strong> = 在广播或寻址房间时要忽略的客户端的会话 ID。这通常设置为消息的发起者，以便除客户端外的每个人都收到消息。要跳过多个 sids 传递列表。<br>​        <strong>callback</strong> - 如果给定，将调用此函数以确认客户端已收到消息。将传递给函数的参数是客户端提供的参数。回调函数只能在寻址单个客户端时使用。</p>
</li>
<li><p><strong><code>send</code>(<em>data</em>, <em>json=False</em>, <em>namespace=None</em>, <em>room=None</em>, <em>callback=None</em>, <em>include_self=True</em>, <em>skip_sid=None</em>, <em>**kwargs</em>)</strong></p>
<p>发送服务器生成的 SocketIO 消息。</p>
<p>此函数向一个或多个连接的客户端发送一个简单的 SocketIO 消息。消息可以是字符串或 JSON blob。这是比<code>emit()</code>更简单的版本，应该首选。此功能可以在 SocketIO 事件上下文之外使用，因此当服务器是事件的发起者时，它才适合使用。</p>
<p>参数:</p>
<p>​        <strong>data</strong>= 要发送的消息，字符串或 JSON blob。</p>
<p>​        <strong>json</strong> = 如果<code>massage</code>是 JSON blob为True，否则 False</p>
<p>​        <strong>namespace</strong>= 要发送消息的命名空间。默认值为全局命名空间。</p>
<p>​        <strong>room</strong>= 仅向给定房间中的用户发送消息。如果未包含此参数，则会将消息发送给所有已连接的用户。</p>
<p>​        <strong>include_self</strong> - 设置为<code>True</code>在广播或寻址房间时包括发件人，设置为<code>False</code>发送给（除发件人）所有人</p>
<p>​        <strong>skip_sid</strong> = 在广播或寻址房间时要忽略的客户端的会话 ID。这通常设置为消息的发起者，以便除客户端外的每个人都收到消息。要跳过多个 sids 传递列表。</p>
<p>​        <strong>callback</strong> - 如果给定，将调用此函数以确认客户端已收到消息。将传递给函数的参数是客户端提供的参数。回调函数只能在寻址单个客户端时使用。</p>
</li>
<li><p><strong><code>close_room</code>(<em>room</em>, <em>namespace=None</em>)</strong></p>
<p>关闭房间。</p>
<p>此功能删除给定聊天室中的任何用户，然后从服务器中删除该文件室。此功能可以在 SocketIO 事件上下文之外使用。</p>
<p>参数：    </p>
<pre><code>    **room**= 要关闭的房间的名称。
    **namespace**= 存在房间的命名空间。默认值为全局命名空间。
</code></pre>
</li>
<li><p>**<code>run</code>(<em>app</em>, <em>host=None</em>, <em>port=None</em>, *<em>kwargs)</em>*</p>
<p>运行 SocketIO Web 服务器。</p>
<p>参数:</p>
<p>​        <strong>app</strong>= Flask应用程序实例。<br>​        <strong>host</strong>= 要侦听的主机名或 IP 地址。默认值为 127.0.0.1。<br>​        <strong>port</strong>= 服务器要侦听的端口号。默认值为 5000。<br>​        <strong>debug</strong>= <code>True</code>在调试模式下启动服务器，<code>False</code>在正常模式下启动。<br>​        <strong>use_reloader</strong> – <code>True</code>启用 Flask 重装程序，<code>False</code>以禁用它。<br>​        <strong>extra_files</strong> = Flask 重新加载程序应监视的其他文件的列表。默认值为None<br>​        <strong>log_output</strong> = 如果<code>True</code>，服务器将记录所有连接。如果<code>False</code>禁用日志记录。默认为<code>True</code>在调试模式下，在正常模式下<code>False</code>。使用线程异步模式时不使用。<br>​        <strong>kwargs</strong> = 其他 Web 服务器选项。Web 服务器选项特定于每个受支持异步模式中使用的服务器。请注意，在使用外部 Web 服务器（如 gunicorn）时，不会看到此处提供的选项，因为在这种情况下不会调用此方法。</p>
</li>
<li><p><strong>stop()</strong></p>
<p>停止正在运行的 SocketIO Web 服务器。</p>
<p>必须从 HTTP 或 SocketIO 处理程序函数调用此方法。</p>
</li>
<li><p><strong><code>sleep</code>(<em>seconds=0</em>)</strong></p>
<p>使用适当的异步模型休眠请求的时间量。</p>
<p>这是一个实用程序函数，应用程序可以使用该函数将任务置于睡眠状态，而不必担心对所选异步模式使用正确的调用。</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Git强制上传本地分支</title>
    <url>/2022/07/11/Git%E5%BC%BA%E5%88%B6%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>采用这个方法可以让一个仓库存储不同的软件代码。如主分支存Hexo的网页代码，一个存Hexo的源代码。</p>
<p>现在git上建立分支新source。</p>
<p>如果还未建立本地git仓库。先执行如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://github.com/XXXX/XXXXX.git </span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;XXXX&#x27;</span><br></pre></td></tr></table></figure>

<p>创建好本地仓库并关联远程仓库后执行如下指令.其中master替换为本地分支名，source替换为远程分支名。<code> -f</code>表示清空远程分支。如果不加<code> -f</code> 则会提示<code>error: failed to push some refs to</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master:source -f</span><br></pre></td></tr></table></figure>

<p>这样处理以后再拉取仓库，并设置追踪</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin source:master</span><br><span class="line">git branch --set-upstream-to origin/source</span><br></pre></td></tr></table></figure>

<p>后续更新文件后<code>git push</code>就不会提示 <code>To push the current branch and set the remote as upstream, use git push --set-upstream origin master</code>及<code>error: failed to push some refs to</code>了。</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础知识</title>
    <url>/2020/06/30/HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="HTML学习"><a href="#HTML学习" class="headerlink" title="HTML学习"></a>HTML学习</h1><p>[TOC]</p>
<h2 id="HTML基础知识"><a href="#HTML基础知识" class="headerlink" title="HTML基础知识"></a>HTML基础知识</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><p>标签不区分大小写,推荐小写</p>
<h4 id="标签种类"><a href="#标签种类" class="headerlink" title="标签种类"></a>标签种类</h4><ol>
<li><p><strong>双标签</strong>(体标记)  :格式如<code>&lt;标记名&gt;&lt;/标记名&gt;  </code>.由开始和结束两个标记符组成的标记.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">例子:<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.shiyanlou.com&quot;</span>&gt;</span>实验楼<span class="tag">&lt;/<span class="name">a</span>&gt;</span> (第一个尖括号内科对属性进行设置)</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>        //html是根标记</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>        //头部标记;定义文档头部信息,一个 HTML 文档只能含有一对 <span class="tag">&lt;<span class="name">head</span>&gt;</span>标记</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>        //<span class="tag">&lt;<span class="name">title</span>&gt;</span>标记用于定义 HTML 页面的标题，必须位于<span class="tag">&lt;<span class="name">head</span>&gt;</span>标记之内。只能有一对</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>        //<span class="tag">&lt;<span class="name">body</span>&gt;</span>标记用于定义 HTML 文档所要显示的内容.在<span class="tag">&lt;<span class="name">head</span>&gt;</span>之后.是用户所看到的.</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span>            //用于对齐文字</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>                //<span class="tag">&lt;<span class="name">p</span>&gt;</span> 标签定义段落。</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>                //<span class="tag">&lt;<span class="name">a</span>&gt;</span> 标签定义超链接，用于从一张页面链接到另一张页面。</span><br><span class="line">                    //<span class="tag">&lt;<span class="name">a</span>&gt;</span> 元素最重要的属性是 href 属性，它指示链接的目标(指向标签)。</span><br><span class="line">                        例子:<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.shiyanlou.com&quot;</span>&gt;</span>实验楼<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    //另一个属性是name属性,创建文档内的书签</span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#winter&quot;</span>&gt;</span>查看冬天。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;winter&quot;</span>&gt;</span>冬<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                        点击查看冬天则跳转到冬所在行</span><br><span class="line">                    //target 属性：用于指定链接页面的打开方式，其取值有 _self(默认)                         和_blank(新开一个页面)</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span><span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>单标签</strong>(空标记) :格式如:<code>&lt;标记名/&gt;  </code> ;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>     <span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>    <span class="comment">&lt;!--水平分隔线--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h4><ol>
<li><p>嵌套关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;  </span><br><span class="line">    &lt;title&gt;  </span><br><span class="line">    &lt;/title&gt;  </span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>并列关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h3><p>有序列表（ol），无序列表（ul）以及自定义列表（dl）。</p>
<ol>
<li><p>有序列表(ol)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">语法格式:</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">value1</span> <span class="attr">start</span>=<span class="string">value2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>属性有 type start两种.type默认为数字列表(可设为”1”,”a”,”A”,”i”,”I”);</li>
</ol>
</li>
<li><p>无序列表(ul)</p>
<p>ul 的 type 属性：默认值(实心圆): disc，方块: square，空心圆: circle。</p>
</li>
<li><p>自定义列表（dl）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>                        自定义列表以<span class="tag">&lt;<span class="name">dl</span>&gt;</span> 标签开始。</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>            每个自定义列表项以 <span class="tag">&lt;<span class="name">dt</span>&gt;</span> 开始。</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>            每个自定义列表项的定义以 <span class="tag">&lt;<span class="name">dd</span>&gt;</span> 开始。</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HTML-元数据"><a href="#HTML-元数据" class="headerlink" title="HTML 元数据"></a>HTML 元数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta&gt;标签提供关于 HTML 文档的元数据：描述（description）、关键词（keywords）、文档的作者（author）等其他元数据。在&lt;head&gt;标签中</span><br></pre></td></tr></table></figure>

<h3 id="HTML-块"><a href="#HTML-块" class="headerlink" title="HTML 块"></a>HTML 块</h3><ol>
<li>块级元素<ol>
<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示。宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制。</li>
<li>常见块级元素： <h1>,<p>, <ul>, <table>。</li>
</ol>
</li>
<li>内联元素<ol>
<li>常见内联元素：<b>, <td>, <a>, <img>。</li>
<li>内联元素在显示时通常不会以新行开始。</li>
</ol>
</li>
</ol>
<h3 id="HTML-布局（div，span）"><a href="#HTML-布局（div，span）" class="headerlink" title="HTML 布局（div，span）"></a>HTML 布局（div，span）</h3><p>table 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>理解比较简单。</li>
<li>不同的浏览器看到的效果一般相同。</li>
<li>table 在显示数据时更加方便</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>显示样式和数据绑定在一起。</li>
<li>布局的时候灵活度不高。</li>
<li>一个页面可能会有大量的 table 元素，代码冗余度高。</li>
<li>增加带宽。</li>
<li>搜索引擎不喜欢这样的布局。</li>
</ol>
<p>div 元素布局：</p>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>符合 W3C 标准。</li>
<li>搜索引擎更加友好。</li>
<li>样式的调整更加方便，内容和样式的分离，使页面和样式的调整变得更加方便。</li>
<li>节省代宽，代码冗余度低。</li>
<li>表现和结构分离，在团队开发中更容易分工合作而减少相互关联性。</li>
</ol>
<h3 id="一些其他的属性"><a href="#一些其他的属性" class="headerlink" title="一些其他的属性"></a>一些其他的属性</h3><ol>
<li>lang 属性:规定元素内容的语言。在以下标签中无效：<code>&lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt; 以及 &lt;script&gt;。</code></li>
<li>style属性也比较常见</li>
</ol>
<h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><b></td>
<td>定义粗体文本   <code>&lt;b&gt;新华网&lt;/b&gt;</code>         <b>新华网</b></td>
</tr>
<tr>
<td><big></td>
<td>定义大号字      <code>&lt;big&gt;新华网&lt;/big&gt;  </code>    <big>新华网</big></td>
</tr>
<tr>
<td><em></td>
<td>定义着重文字   <code>&lt;em&gt;新华网&lt;/em&gt;</code>     <em>新华网</em></td>
</tr>
<tr>
<td><i></td>
<td>定义斜体字       <code>&lt;i&gt;新华网&lt;/i&gt;</code>         <i>新华网</i></td>
</tr>
<tr>
<td><small></td>
<td>定义小号字       <code>&lt;small&gt;新华网&lt;/small&gt;</code>       <small>新华网</small></td>
</tr>
<tr>
<td><strong></td>
<td>定义加重语气   <code>&lt;strong&gt;新华网&lt;/strong&gt;</code>   <strong>新华网</strong></td>
</tr>
<tr>
<td><sub></td>
<td>定义下标字        <code>&lt;sub&gt;新华网&lt;/sub&gt;</code>     <sub>新华网</sub></td>
</tr>
<tr>
<td><sup></td>
<td>定义上标字        <code>&lt;sup&gt;新华网&lt;/sup&gt;</code>      <sup>新华网</sup></td>
</tr>
<tr>
<td><ins></td>
<td>定义插入字     <code>&lt;ins&gt;新华网&lt;/ins&gt;</code>     <ins>新华网</ins></td>
</tr>
<tr>
<td><del></td>
<td>定义删除字     <code>&lt;del&gt;新华网&lt;/del&gt;</code>     <del>新华网</del></td>
</tr>
<tr>
<td><font></td>
<td>定义字体属性   <code>&lt;font color=&quot;red&quot; size=&quot;4&quot;&gt;新华网&lt;/font&gt;</code>   <font color="red" size="4">新华网</font></td>
</tr>
</tbody></table>
<h3 id="文档和网站架构"><a href="#文档和网站架构" class="headerlink" title="文档和网站架构"></a>文档和网站架构</h3><p>专用标签:</p>
<ul>
<li>标题：<header></li>
<li>导航栏：<nav></li>
<li>主要内容：<main>具有代表性的内容段落主题可以使用 <article>, <section>，<div>元素。</li>
<li>侧栏：<aside>经常嵌套在<main>中</li>
<li>页脚：<footer></li>
</ul>
<h2 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h2><h3 id="表格基本标签"><a href="#表格基本标签" class="headerlink" title="表格基本标签"></a>表格基本标签</h3><ol>
<li><code>&lt;table&gt;标签</code> :用于在 HTML 文档中创建表格。它包含表名和表格本身内容的代码。<ol>
<li>语法：<code>&lt;table&gt;... &lt;/table&gt;</code>；</li>
<li>属性: <ol>
<li>border 边框厚度</li>
<li>cellspacing:单元格与单元格间距离</li>
<li>cellpadding:文字与单元格之间距离</li>
<li>width;height 宽度,高度</li>
<li>bgcolor:颜色</li>
</ol>
</li>
</ol>
</li>
<li><code>&lt;tr&gt;标签</code>          用于定义每一行。</li>
<li><code>&lt;td&gt;标签</code>    用于定义每一列。</li>
<li><code>&lt;th&gt;标签</code>    用于定义标题;<ol>
<li>colspan（合并行）和 rowspan（合并列）属性</li>
</ol>
</li>
</ol>
<h2 id="多媒体与嵌入概述"><a href="#多媒体与嵌入概述" class="headerlink" title="多媒体与嵌入概述"></a>多媒体与嵌入概述</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol>
<li>图像标签    <code>&lt;img&gt; </code>标签(单标签)    语法为：`<img src="url" alt="" />，<ol>
<li>src 的值是图像文件路径。</li>
<li>alt 规定图像的替代文本即当图片未成功显示的时候显示的文本信息。</li>
<li>title 设置鼠标悬停时显示的内容（一般不用设置）</li>
<li>设置 width 和 height 的值来设置图片的宽和高</li>
</ol>
</li>
<li>相对路径:位于上一级目录就用”../“</li>
<li>绝对路径:</li>
<li><strong>自适应图片</strong>:width和height设置值为auto</li>
</ol>
<h3 id="视频和音频"><a href="#视频和音频" class="headerlink" title="视频和音频"></a>视频和音频</h3><ol>
<li><p><code>&lt;video&gt;标签</code>和<code>&lt;audio&gt;标签</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_autoplay.asp">autoplay</a></td>
<td>autoplay</td>
<td>如果出现该属性，则视频在就绪后马上播放。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_controls.asp">controls</a></td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_height.asp">height</a></td>
<td><em>pixels</em></td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_loop.asp">loop</a></td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_preload.asp">preload</a></td>
<td>preload</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_src.asp">src</a></td>
<td><em>url</em></td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/html5/att_video_width.asp">width</a></td>
<td><em>pixels</em></td>
<td>设置视频播放器的宽度。</td>
</tr>
</tbody></table>
</li>
<li><p><code>&lt;source&gt; 标签</code>:</p>
<ol>
<li><code>&lt;source&gt;</code> 标签为媒介元素（比如<code>&lt;video&gt;</code>和<code> &lt;audio&gt;</code>）定义媒介资源。</li>
</ol>
</li>
</ol>
<h3 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h3><p>1.图库</p>
<ul>
<li>阿里巴巴矢量图标库 <a href="http://iconfont.cn/">http://iconfont.cn/</a></li>
<li>谷歌浏览器里的矢量图库 <a href="https://icomoon.io/">https://icomoon.io/</a></li>
</ul>
<h3 id="iframe嵌入技术"><a href="#iframe嵌入技术" class="headerlink" title="iframe嵌入技术"></a>iframe嵌入技术</h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<p>属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_align.asp">align</a></td>
<td>leftrighttopmiddlebottom</td>
<td>不赞成使用。请使用样式代替。规定如何根据周围的元素来对齐此框架。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_frameborder.asp">frameborder</a></td>
<td>10</td>
<td>规定是否显示框架周围的边框。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_height.asp">height</a></td>
<td><em>pixels</em><em>%</em></td>
<td>规定 iframe 的高度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_longdesc.asp">longdesc</a></td>
<td><em>URL</em></td>
<td>规定一个页面，该页面包含了有关 iframe 的较长描述。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_marginheight.asp">marginheight</a></td>
<td><em>pixels</em></td>
<td>定义 iframe 的顶部和底部的边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_marginwidth.asp">marginwidth</a></td>
<td><em>pixels</em></td>
<td>定义 iframe 的左侧和右侧的边距。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_name.asp">name</a></td>
<td><em>frame_name</em></td>
<td>规定 iframe 的名称。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_sandbox.asp">sandbox</a></td>
<td>“”allow-formsallow-same-originallow-scriptsallow-top-navigation</td>
<td>启用一系列对 <iframe> 中内容的额外限制。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_scrolling.asp">scrolling</a></td>
<td>yesnoauto</td>
<td>规定是否在 iframe 中显示滚动条。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_seamless.asp">seamless</a></td>
<td>seamless</td>
<td>规定 <iframe> 看上去像是包含文档的一部分。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_src.asp">src</a></td>
<td><em>URL</em></td>
<td>规定在 iframe 中显示的文档的 URL。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_srcdoc.asp">srcdoc</a></td>
<td><em>HTML_code</em></td>
<td>规定在 <iframe> 中显示的页面的 HTML 内容。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/tags/att_iframe_width.asp">width</a></td>
<td><em>pixels</em><em>%</em></td>
<td>定义 iframe 的宽度。</td>
</tr>
</tbody></table>
<h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><h4 id="lt-form-gt-标签"><a href="#lt-form-gt-标签" class="headerlink" title="&lt;form&gt; 标签"></a><code>&lt;form&gt;</code> 标签</h4><p>​    定义html表单</p>
<ol>
<li><p>组成部分:</p>
<ol>
<li>表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL 以及数据提交到服务器的方法。</li>
<li>表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。</li>
<li>表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。</li>
</ol>
</li>
<li><p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form name=&quot;form_name&quot; method=&quot;get/post&quot; action=&quot;url&quot;&gt; &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>name：定义表单的名字。</p>
</li>
<li><p>method：定义表单结果从浏览器传送到服务器的方式，默认参数为：get 。post 安全性更高，因此常用作传输密码等，而 get 安全性较低，一般用于查询数据。<strong>使用 get 请求用户将在他们的 URL 栏中看到数据，但是使用 post 请求用户将不会看到。</strong></p>
</li>
<li><p>action：用来指定表单处理程序的位置(服务器端脚本处理程序）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;https:.com/&quot;&gt;</span><br><span class="line">&lt;!--数据发送到一个绝对URL：https:.com/--&gt;</span><br><span class="line">&lt;form action=&quot;/somewhere_else&quot;&gt;</span><br><span class="line">&lt;!-- 数据发送到一个相对URL --&gt;</span><br><span class="line">&lt;form action=&quot;#&quot;&gt;</span><br><span class="line">&lt;!-- 数据被发送到表单出现的相同页面上 --&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><h5 id="lt-input-gt-元素"><a href="#lt-input-gt-元素" class="headerlink" title="&lt;input /&gt;元素"></a><code>&lt;input /&gt;</code>元素</h5><ol>
<li><p><code>&lt;input&gt; </code>标签规定了用户可以在其中输入数据的输入字段。单标签用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>type属性</p>
<p>type的值有</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">text</td>
<td align="left">定义常规文本输入。</td>
</tr>
<tr>
<td align="left">radio</td>
<td align="left">定义单选按钮输入（选择多个选择之一）</td>
</tr>
<tr>
<td align="left">submit</td>
<td align="left">定义提交按钮（提交表单）</td>
</tr>
</tbody></table>
</li>
<li><p>required:输入值不能为空,如果输入值为空，将会提示错误信息。</p>
</li>
</ol>
<h5 id="lt-select-gt-元素和-lt-option-gt-元素"><a href="#lt-select-gt-元素和-lt-option-gt-元素" class="headerlink" title="&lt;select&gt; 元素和&lt;option&gt;元素"></a><code>&lt;select&gt; </code>元素和<code>&lt;option&gt;</code>元素</h5><p> <code>&lt;select&gt;</code>元素定义下拉列表;<code>option</code>元素定义待选择选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span> <span class="attr">selected</span> &gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span> //selected属性定义默认项</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="lt-textarea-gt-元素"><a href="#lt-textarea-gt-元素" class="headerlink" title="&lt;textarea&gt; 元素"></a><code>&lt;textarea&gt; </code>元素</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素定义多行输入字段（文本域）：</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">The cat was playing.</span><br><span class="line">in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex公式入门</title>
    <url>/2022/09/22/Latex%E5%85%AC%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL ERROR 1698 (28000) 解决方案</title>
    <url>/2022/06/30/MySQL%20ERROR%201698%20(28000)%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="MySQL-ERROR-1698-28000-解决方案"><a href="#MySQL-ERROR-1698-28000-解决方案" class="headerlink" title="MySQL ERROR 1698 (28000) 解决方案"></a>MySQL ERROR 1698 (28000) 解决方案</h1><p>解决步骤：<br>1、停止MySQL服务</p>
<p>~$ sudo service mysql stop</p>
<p>2、以安全模式启动MySQL</p>
<p>~$ sudo mysqld_safe –skip-grant-tables &amp;</p>
<p>3、然后无需密码直接进入MySQL</p>
<p>~$ mysql -u root</p>
<p>4、查看user表，发现错误原因user表被修改了</p>
<p>命令：mysql&gt; select user ,plugin from mysql.user</p>
<p>错误：</p>
<p>5、root的plugin应该和剩下的三种一样为 mysql_native_password</p>
<p>即正确为：</p>
<p>6、所以我们只需要修改过来就可以了</p>
<p>mysql&gt; update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;</p>
<p>mysql&gt; flush privileges;</p>
<p>mysql&gt; quit；</p>
]]></content>
      <categories>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ocaml语言学习笔记</title>
    <url>/2019/11/07/Ocaml%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Ocaml语言学习笔记"><a href="#Ocaml语言学习笔记" class="headerlink" title="Ocaml语言学习笔记"></a>Ocaml语言学习笔记</h1><h2 id="unit类型和简单的输入输出"><a href="#unit类型和简单的输入输出" class="headerlink" title="unit类型和简单的输入输出"></a>unit类型和简单的输入输出</h2><ol>
<li><p>unit类型只有一个值();</p>
</li>
<li><p>从标准输入上读取整数: read_int    浮点数,字符串类似 (没有单独读取一个字符的),read_line</p>
</li>
<li><p>打印函数为 print_int ; 浮点数,字符,字符串类似.还有print_newline() 打印新行</p>
<p>print_endline 也可以打印字符串,并换行</p>
</li>
<li><p>合并字符串 操作符 str1 ^ str2</p>
</li>
<li><p>字符串换    int_of_string   /float_of_string</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Python批处理文档为Hexo格式</title>
    <url>/2022/07/11/Python%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3%E4%B8%BAHexo%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>需要将要处理的文件放到同一个文件夹，并在该文件夹下创建python文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;./&quot;</span>	<span class="comment">#采用相对路径读取当前目录md文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(path, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&quot;.md&quot;</span> <span class="keyword">in</span> name: <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        _path = os.path.join(root, name)</span><br><span class="line">        <span class="comment">#editTime = time.strptime(os.path.getmtime(_path), &quot;%Y-%m-%d %H:%M:%S&quot;)</span></span><br><span class="line">        editTime = time.localtime(os.path.getmtime(_path)) <span class="comment">#获取文档最后修改时间</span></span><br><span class="line">        editTime = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, editTime) <span class="comment">#格式化时间戳</span></span><br><span class="line">        _name = name[:<span class="built_in">len</span>(name)-<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(_path, <span class="string">&quot;r+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            old = f.read()</span><br><span class="line">            f.seek(<span class="number">0</span>)</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;title: %s\n&quot;</span> %_name)</span><br><span class="line">            f.write(<span class="string">&quot;date: %s\n&quot;</span> %editTime)</span><br><span class="line">            f.write(<span class="string">&quot;categories:\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;tags:\n&quot;</span>)</span><br><span class="line">            f.write(<span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">            f.write(old) <span class="comment">#将文件原内容追加到前缀后面</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>qt学习（一）基本模块</title>
    <url>/2022/10/24/QT%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="基本模块："><a href="#基本模块：" class="headerlink" title="基本模块："></a>基本模块：</h2><table>
<thead>
<tr>
<th align="left">模块</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Qt Core</td>
<td align="left">其他模块都用到的核心非图形类</td>
</tr>
<tr>
<td align="left">Qt GUI</td>
<td align="left">设计GUI的基础类，包括OpenGL</td>
</tr>
<tr>
<td align="left">Qt Multimedia</td>
<td align="left">音频、视频、摄像头及广播功能的类</td>
</tr>
<tr>
<td align="left">Qt Multimedia Widgets</td>
<td align="left">实现多媒体功能的界面组件类</td>
</tr>
<tr>
<td align="left">Qt Network</td>
<td align="left">使网络编程更简单和轻便的类</td>
</tr>
<tr>
<td align="left">Qt QML</td>
<td align="left">用于QML和JavaScript的类</td>
</tr>
<tr>
<td align="left">Qt Quick</td>
<td align="left">用于构建具有定制用户界面的动态应用程序的声明框架</td>
</tr>
<tr>
<td align="left">Qt Quick Controls</td>
<td align="left">创建桌面样式用户界面</td>
</tr>
<tr>
<td align="left">Qt Quick Dialogs</td>
<td align="left">通过Qt Quick创建系统对话框并与之交互的类型</td>
</tr>
<tr>
<td align="left">Qt Quick Layouts</td>
<td align="left">用于Qt Quick2界面元素的布局项</td>
</tr>
<tr>
<td align="left">Qt SQL</td>
<td align="left">使用SQL用于数据库操作的类</td>
</tr>
<tr>
<td align="left">Qt Test</td>
<td align="left">用于应用程序和库进行单元测试的类</td>
</tr>
<tr>
<td align="left">Qt Widgets</td>
<td align="left">用于构建GUI的C++图形组件类</td>
</tr>
</tbody></table>
<h2 id="常用控件："><a href="#常用控件：" class="headerlink" title="常用控件："></a>常用控件：</h2><h3 id="QlineEdit-单行文本框控件"><a href="#QlineEdit-单行文本框控件" class="headerlink" title="QlineEdit 单行文本框控件"></a>QlineEdit 单行文本框控件</h3><p>QLineEdit类是一个单行文本框控件，可以输入单行字符串。<br>常用方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setText()</td>
<td align="left">设置文本框的内容</td>
</tr>
<tr>
<td align="left">setPlaceholderText()</td>
<td align="left">设置文本框显示的文字</td>
</tr>
<tr>
<td align="left">setAlignment()</td>
<td align="left">按固定值方式对齐文本</td>
</tr>
</tbody></table>
<h3 id="QGridLayout-网格布局控件"><a href="#QGridLayout-网格布局控件" class="headerlink" title="QGridLayout 网格布局控件"></a>QGridLayout 网格布局控件</h3><p>QGridLayout可将窗口分割成行和列的网格来进行排列，类似于控件的容器。<br>用户可使用<code>addWidget()</code>函数将被管理的控件添加到窗口中。<br>或使用<code>addLayout()</code>函数将布局添加到窗口中。</p>
<ol>
<li><code>addWidget()</code>函数：<br>给网格布局添加部件，设置指定的行数和列数，起始位置默认值为(0,0)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">addWidget</span>(Qwdget Widget, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> alignment = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>widget：表示所添加的控件</li>
<li>row：表示控件的行数，默认从0开始</li>
<li>col：标示空间的列数，默认从0开始</li>
<li>alignment：表示对其方式</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习（二）QObject及信号和槽机制</title>
    <url>/2022/10/25/QT%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="QObject"><a href="#QObject" class="headerlink" title="QObject"></a>QObject</h2><h3 id="MOC-与-QObject"><a href="#MOC-与-QObject" class="headerlink" title="MOC 与 QObject"></a>MOC 与 QObject</h3><p>元对象系统是一个C++扩展，使该语言更适合真正的组件化GUI编程。<br>QObject类是所有使用元对象系统的类的基类。</p>
<ul>
<li>并不是所有Q开头的类都是Object的派生类，例如QString</li>
</ul>
<p>在一个类的private部分声明Q_OBJECT宏。</p>
<blockquote>
<p>使用信号与槽机制，只有添加Q_OBJECT宏，moc才能对类里的信号与槽进行预处理</p>
</blockquote>
<p>MOC（元对象编译器）为每个QObject的子类提供必要的代码。</p>
<blockquote>
<p>元对象编译器（Meta-Object Compiler，MOC）是一个预处理器，先将Qt的特性程序转换为标准C++程序，在由标准C++编译器进行编译</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(源代码)--&gt;B[预处理]--Q_OBJECT宏--&gt;C((MOC))--&gt;D[编译器]--&gt;E[链接器]--&gt;F(应用程序)</span><br></pre></td></tr></table></figure>
<h3 id="QObject-1"><a href="#QObject-1" class="headerlink" title="QObject"></a>QObject</h3><p>QObject是Qt对象模型的核心。<br>标准的C++对象模型在某些领域不够灵活。图形用户界面编程是一个<strong>既需要运行效率又需要高度灵活性</strong>的领域。QObject提供了灵活性。</p>
<blockquote>
<p>QObject不支持拷贝！QObject 的拷贝构造函数和赋值运算符是私有的，并且使用了Q_DISABLE_COPY()宏</p>
</blockquote>
<p>QObject在对象树中组织自己。</p>
<ul>
<li>当以另一个对象作为父对象创建QObject时，该对象将自动将自身添加到父对象的子对象列表中。</li>
<li>父对象删除时，它将自动删除其子对象。可以使用findChild（）或findChildren（）按名称和可选类型查找对象。</li>
</ul>
<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>槽的本质是类的成员函数。参数任意，可以是虚函数。槽通常和信号连接在一起，当信号被发出时，与这个信号连接的槽函数就会被调用。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h3><ol>
<li>使用SIGNAL和SLOT宏: <code>connect(sender, SIGNAL(signal), reveiver, SLOT(slot));</code><br> 参数如下：<ul>
<li>sender：发出信号的对象，指向发送信号对象的指针。</li>
<li>signal：发送对象发出的信号。不带参数的函数名，SIGNAL()将函数名转为字符串并传入connect()中</li>
<li>receiver：接收信号的对象，指向包含槽函数的对象的指针。</li>
<li>slot：接收对象在接收到信号之后需要调用的函数。不带参数的函数名，SLOT()将函数名转为字符串并传入connect()中</li>
</ul>
</li>
<li>使用成员函数指针（<strong>推荐</strong>）: <code>connect(sender, &amp;QObject::destroyed, this, &amp;MyObject::objectDestroyed);</code><br>优点：1、允许编译器检查信号是否与槽的参数兼容。2、编译器可以隐式转换参数。</li>
<li>使用仿函数或lambda表达式作为slot: <code>connect(sender, &amp;QObject::destroyed, this, [=]()&#123; this-&gt;m_objects.remove(sender); &#125;);</code></li>
</ol>
<p>connect还可以添加第五个参数为Qt::ConnectionType类型的参数，表示信号与槽之间的关联方式：</p>
<ul>
<li>Qt::AutoConnection（缺省值）：自动确定关联方式。</li>
<li>Qt::DirectConnection：信号被发射时，槽立即执行，槽函数与信号在同一线程</li>
<li>Qt::QueuedConnection：事件循环回到接收者线程后执行槽，槽与信号在不同线程</li>
<li>Qt::BlockingQueueConnection：与Qt::QueuedConnection相似，信号线程会被阻塞直到槽执行完毕。当槽函数与信号在同一线程，会造成死锁。</li>
</ul>
<p><strong>信号与槽的连接移除示例：</strong></p>
<ol>
<li>一个信号连接多个槽<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signal), reveiverA, <span class="built_in">SLOT</span>(slotA));</span><br><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signal), reveiverB, <span class="built_in">SLOT</span>(slotB));</span><br></pre></td></tr></table></figure></li>
<li>多个信号连接同一个槽<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(senderA, <span class="built_in">SIGNAL</span>(signalA), reveiverA, <span class="built_in">SLOT</span>(slotA));</span><br><span class="line"><span class="built_in">connect</span>(senderB, <span class="built_in">SIGNAL</span>(signalB), reveiverA, <span class="built_in">SLOT</span>(slotA));</span><br></pre></td></tr></table></figure></li>
<li>一个信号连接另一个信号<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(signalA), reveiver, <span class="built_in">SIGNAL</span>(signalB));</span><br></pre></td></tr></table></figure></li>
<li>移除信号与槽的连接<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(sender, <span class="built_in">SIGNAL</span>(signal), reveiver, <span class="built_in">SLOT</span>(slot));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="QT信号槽机制的优缺点："><a href="#QT信号槽机制的优缺点：" class="headerlink" title="QT信号槽机制的优缺点："></a><strong>QT信号槽机制的优缺点：</strong></h3><ul>
<li>可减少程序员编写的代码量。</li>
<li>信号可以对应多个槽，也可以多个槽映射一个信号。</li>
<li>信号和槽的建立与解除绑定十分自由。</li>
<li>信号和槽相对于回调函数时间损耗很大。</li>
<li>信号和槽参数限定很多，不能携带模板类参数，不能出现宏定义等。</li>
</ul>
<p>示例代码文件解读：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *widget.h 头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span> <span class="comment">//引入按钮模块</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE <span class="comment">//定义自己命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">Widget</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget <span class="comment">//继承自基类QWidget</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//Q_OBJECT宏，只有继承了QOBJECT类的宏才具有信号和槽。该宏是任何实现信号、槽或属性的强制性要求。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    QPushButton button1; <span class="comment">//声明一个按钮</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ui-&gt;setupUi(this);</span></span><br><span class="line">    button1.<span class="built_in">setParent</span>(<span class="keyword">this</span>); <span class="comment">//绑定窗口和按钮</span></span><br><span class="line">    button1.<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>); <span class="comment">//按钮中文本</span></span><br><span class="line">    button1.<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//定义按钮的位置，以左上角为原点。</span></span><br><span class="line">    <span class="built_in">connect</span>(&amp;button1, &amp;QPushButton::pressed, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//delete ui;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码中在类定义的第一行写上了<code>Q_OBJECT</code>来声明<code>Q_OBJECT</code>宏。这个宏为类提供了信号和槽机制、国际化机制、以及Qt提供的不基于C++ RTTI（Runtime Type Identification）的反射能力。其他很多操作都会依赖这个宏，即使类中不需要使用信号和槽也需要添加这个宏。</p>
</blockquote>
<h3 id="自定义槽函数和自定义信号"><a href="#自定义槽函数和自定义信号" class="headerlink" title="自定义槽函数和自定义信号"></a><strong>自定义槽函数和自定义信号</strong></h3><p>要点：</p>
<ul>
<li>发送者和接受者都需要QObject的派生类（槽函数是全局函数、Lambda表达式等无需接收者的时候除外）</li>
<li>使用<code>signals</code>标记信号，信号是一个函数声明，返回void，不需要实现函数代码。</li>
<li>使用<code>emit</code>在恰当位置发送信号。</li>
<li>可以在main.cpp中使用<code>QObject::connect()</code>函数连接信号和槽函数。</li>
<li>槽函数可以传入参数，但是没有返回值。</li>
<li>任何成员函数、静态成员函数、全局函数及Lambda表达式都可以作为参函数。与信号函数不同，槽函数必须自己完成实现代码。槽函数就是普通的成员函数。<blockquote>
<p>信号函数的参数数量要大于等于槽函数，这样才能传递参数给槽函数，且信号函数多余的参数会槽函数接收时自动忽略</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * newspaper.h文件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NEWSPAPER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWSPAPER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">NewsPaper</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPaper</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewsPaper</span>(<span class="type">const</span> QString name):<span class="built_in">m_name</span>(name)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">NewsPaper</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sent</span><span class="params">()</span></span>;    <span class="comment">//定义发送自定义信号的函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newPaper</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>; <span class="comment">//定义信号，无需实现，可以有参数，返回类型必须为void</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::NewsPaper *ui;</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// NEWSPAPER_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reader.h文件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> READER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reader</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveNews</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>; <span class="comment">//简单函数，负责输出接收到的参数name。</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// READER_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * newspaper.cpp文件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;newspaper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./ui_newspaper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NewsPaper::~<span class="built_in">NewsPaper</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewsPaper::sent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reader.cpp文件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QDebug&quot;</span><span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">Reader::Reader()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">void Reader::receiveNews(const QString &amp;name)&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    qDebug() &lt;&lt; &quot;</span>reveive news: <span class="string">&quot; &lt;&lt; name;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/**</span></span></span><br><span class="line"><span class="string"><span class="meta"> * main.cpp文件</span></span></span><br><span class="line"><span class="string"><span class="meta"> **/</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &quot;</span>newspaper.h<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &quot;</span>reader.h<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;QApplication&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main(int argc, char *argv[])</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    QApplication a(argc, argv);</span></span></span><br><span class="line"><span class="string"><span class="meta">    NewsPaper newsPaper(&quot;</span>NewsPaper:A <span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">    Reader reader;</span></span></span><br><span class="line"><span class="string"><span class="meta">    QObject::connect(&amp;newsPaper,&amp;NewsPaper::newPaper, &amp;reader, &amp;Reader::receiveNews);</span></span></span><br><span class="line"><span class="string"><span class="meta">    newsPaper.sent();</span></span></span><br><span class="line"><span class="string"><span class="meta">    return a.exec();</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文输出采用了qDebug，这是因为std::cout不支持QString字符串的输出，如果要用cout需要把字符串转为stdString</p>
</blockquote>
</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p>基本语法:</p>
<blockquote>
<p>[函数对象参数] (操作符重载函数参数) mutable或exception -&gt;返回值{函数体}</p>
</blockquote>
<ol>
<li>函数对象参数：<br>以<code>[]</code>标识一个Lambda表达式的开始。函数对象参数是传递给编译器自动生成桉树对象类的构造函数的。函数对象参数只能使用那些到定义Lambda表达式为止时Lambda所在作用范围内可见的局部变量（包括所在类的this）。参数形式：<ul>
<li>空，没有使用任何函数对象参数。</li>
<li>“=”，函数体内可以使用Lambda表达式所在作用范围内所有可见的局部变量（包括所在类的this）。是值传递方式</li>
<li>“&amp;”，函数体内可以使用Lambda表达式所在作用范围内所有可见的局部变量（包括所在类的this）。是引用传递方式</li>
</ul>
</li>
<li>操作符重载函数参数、<br>以<code>()</code>标识重载的操作符的参数，没有参数时，可以省略。参数可以通过按值和按引用两种方式进行传递。</li>
<li>可修改标识符<br>mutable声明，可省略。按值传递函数对象参数时，加上mutable后可以修改按值传递进来的副本。</li>
<li>错误抛出标识符<br>exception声明，这部分也可以声乐。exception声明用于指定函数抛出的异常，使用throw()方法</li>
<li>函数返回值<br>以<code>-&gt;</code>标识函数返回值类型。当返回值为void或者只有一处返回时可以省略，因为编译器可以自动推导类型。</li>
<li>函数体<br>不可省略，但可为空。<br>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">connect</span>(&amp;button1, &amp;QPushButton::pressed,<span class="keyword">this</span>,</span><br><span class="line">            [=]()-&gt; <span class="type">void</span> &#123;</span><br><span class="line">        button1.<span class="built_in">setText</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="键盘鼠标事件示例"><a href="#键盘鼠标事件示例" class="headerlink" title="键盘鼠标事件示例"></a>键盘鼠标事件示例</h2></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);  <span class="comment">//设置一直跟踪鼠标</span></span><br><span class="line">    <span class="keyword">auto</span> *quitBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Quit&quot;</span>, <span class="keyword">this</span>); <span class="comment">//设置一个Quit控件</span></span><br><span class="line">    quitBtn-&gt;<span class="built_in">setGeometry</span>(<span class="number">50</span>,<span class="number">25</span>,<span class="number">100</span>,<span class="number">50</span>); <span class="comment">//设置控件坐标及大小</span></span><br><span class="line">    <span class="built_in">connect</span>(quitBtn,&amp;QPushButton::clicked, qApp, &amp;QApplication::quit); <span class="comment">//关联控件点击到界面单例对象的退出操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::keyPressEvent</span><span class="params">(QKeyEvent *event)</span>    <span class="comment">//响应键盘事件，在父类中提供了虚函数接口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>() == Qt::Key_Escape) &#123;    <span class="comment">//判断键值</span></span><br><span class="line">        qApp-&gt;<span class="built_in">quit</span>();   <span class="comment">//单例对象退出操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span>     <span class="comment">//响应鼠标事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = event-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y = event-&gt;<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">statusBar</span>()-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;坐标&quot;</span>+QString::<span class="built_in">number</span>(x) +<span class="string">&quot;, &quot;</span>+ QString::<span class="built_in">number</span>(y));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>qApp是一个宏，包含在头文件QApplication或者QCoreapplication中，指向一个当前实例。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓RecyclerView封装库</title>
    <url>/2021/04/20/RecyclerView/</url>
    <content><![CDATA[<p>代码仓库: <a href="https://github.com/yanzhenjie/SwipeRecyclerView">https://github.com/yanzhenjie/SwipeRecyclerView</a></p>
<p>基于RecyclerView的封装，特性如下：</p>
<ol>
<li>Item侧滑菜单，支持水平分布、垂直分布</li>
<li>Item长按拖拽、侧滑删除</li>
<li>添加/移除HeaderView/FooterView</li>
<li><strong>自动/点击</strong>加载更多的功能</li>
<li>支持二级列表，List形式、Grid形式、Staggered形式</li>
<li>Sticky普通布局黏贴和ReyclerView分组黏贴</li>
<li>支持AndroidX</li>
</ol>
]]></content>
      <categories>
        <category>工具资源</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用deb包安装JDK</title>
    <url>/2019/09/14/Ubuntu%E4%BD%BF%E7%94%A8deb%E5%8C%85%E5%AE%89%E8%A3%85JDK/</url>
    <content><![CDATA[<h1 id="Ubuntu使用deb包安装JDK"><a href="#Ubuntu使用deb包安装JDK" class="headerlink" title="Ubuntu使用deb包安装JDK"></a>Ubuntu使用deb包安装JDK</h1><h2 id="1-在oracle下载所需版本的jdk的deb包"><a href="#1-在oracle下载所需版本的jdk的deb包" class="headerlink" title="1.在oracle下载所需版本的jdk的deb包"></a>1.在oracle下载所需版本的jdk的deb包</h2><h3 id="2-安装jdk包"><a href="#2-安装jdk包" class="headerlink" title="2. 安装jdk包"></a>2. 安装jdk包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i jdk-12.0.2_linux-x64_bin.deb (替换成自己的包的名称)</span><br></pre></td></tr></table></figure>

<p>出现依赖问题,使用 <code>sudo apt install -f</code>修复</p>
<h3 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h3><ol>
<li><p>首先导入安装路径,<code>/jdk12.0.2/</code>这里替换成自己的版本的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk12.0.2/bin/java 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk12.0.2/bin/javac 1</span><br></pre></td></tr></table></figure></li>
<li><p>环境配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4.验证安装"></a>4.验证安装</h3><p>​        <code>java -version</code></p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Java</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>apache2添加验证</title>
    <url>/2019/11/24/apache2%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>如果希望将某些或所有网站限制仅允许特定用户或组访问，使用HTTP Auth（基于apache2）方式很容易实现。<br> 一、在CentOS上，httpd的配置文件默认在/etc/httpd/conf/httpd.conf文件，</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;Directory <span class="string">&quot;/var/www/html&quot;</span>&gt;</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line"><span class="meta"># 下面这3行是默认的，可以直接改，或者注释掉</span></span><br><span class="line"><span class="meta">#    AllowOverride ALL</span></span><br><span class="line"><span class="meta">#    Order allow,deny</span></span><br><span class="line"><span class="meta">#    Allow from all</span></span><br><span class="line"><span class="meta"># 改成下面这样</span></span><br><span class="line">    AllowOverride authconfig</span><br><span class="line">    Order allow,deny</span><br><span class="line">    Allow <span class="keyword">from</span> all</span><br><span class="line">    AuthName <span class="string">&quot;Web Access&quot;</span></span><br><span class="line"><span class="meta">#名字随意</span></span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthUserFile /<span class="keyword">var</span>/www/html/.htpasswd</span><br><span class="line"><span class="meta">#认证文件名字和位置和下面生成的要一致</span></span><br><span class="line">    Require valid-user</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>这里存放用户密码的文件就是.htpasswd， 位置和名称可以改。<br> 生成用户密码文件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">htpasswd <span class="operator">-</span>c <span class="operator">/</span><span class="keyword">var</span><span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>.htpasswd <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br><span class="line">#创建第一个认证用户的时候用<span class="operator">-</span>c，其他用户要把<span class="operator">-</span>c去掉，否则会被覆盖掉</span><br><span class="line">重启httpd服务即可</span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure>

<p>也可使用用户组来控制，也是编辑httpd配置文件，这里不写了。<br> 二、Ubuntu的apache配置文件编辑/etc/apache2/sites-enabled/目录下的文件，根据虚拟站点有不同的名称，比如我的nagios配置文件就叫nagios.conf，看起来是这样子的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Alias /nagios <span class="string">&quot;/usr/local/nagios/share&quot;</span></span><br><span class="line">&lt;<span class="built_in">Directory</span> <span class="string">&quot;/usr/local/nagios/share&quot;</span>&gt;</span><br><span class="line"><span class="comment">#  SSLRequireSSL</span></span><br><span class="line">   Options None</span><br><span class="line">   AllowOverride None</span><br><span class="line">   &lt;IfVersion &gt;= <span class="number">2.3</span>&gt;</span><br><span class="line">      &lt;RequireAll&gt;</span><br><span class="line">         Require all granted</span><br><span class="line"><span class="comment">#        Require host 127.0.0.1</span></span><br><span class="line">         AuthName <span class="string">&quot;Nagios Access&quot;</span></span><br><span class="line">         AuthType Basic</span><br><span class="line">         AuthUserFile /usr/local/nagios/etc/htpasswd.users</span><br><span class="line">         Require valid-user</span><br><span class="line">      &lt;/RequireAll&gt;</span><br><span class="line">   &lt;/IfVersion&gt;</span><br><span class="line"> &lt;IfVersion &lt; <span class="number">2.3</span>&gt;</span><br><span class="line">      Order allow,deny</span><br><span class="line">      Allow <span class="keyword">from</span> all</span><br><span class="line">     Order deny,allow</span><br><span class="line">     Deny <span class="keyword">from</span> all</span><br><span class="line">      AuthName <span class="string">&quot;Nagios Access&quot;</span></span><br><span class="line">      AuthType Basic</span><br><span class="line">      AuthUserFile /usr/local/nagios/etc/htpasswd.users</span><br><span class="line">      Require valid-user</span><br><span class="line">   &lt;/IfVersion&gt;</span><br><span class="line">&lt;/<span class="built_in">Directory</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Ubuntu如果默认没有安装htpasswd工具的话，要先安装apache2-utils包：<br> sudo apt install apache2-utils<br> 生成用户密码的用法和CentOS是一样的。</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>kodexplorer不修改版权改标签</title>
    <url>/2019/07/10/kodexplorer%E4%B8%8D%E4%BF%AE%E6%94%B9%E7%89%88%E6%9D%83%E6%94%B9%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="kodexplorer不修改版权改标签"><a href="#kodexplorer不修改版权改标签" class="headerlink" title="kodexplorer不修改版权改标签"></a>kodexplorer不修改版权改标签</h1><ol>
<li><p>自定义可道云名称和描述:</p>
<p>这个很简单,在admin账号下,右上角下拉菜单选择系统设置就可以修改了</p>
</li>
<li><p>隐藏 页面底部版权信息 </p>
<p>admin账号-&gt;系统设置-&gt;其他-&gt;自定义css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.copyright-content</span>&#123;<span class="attribute">display</span>:none&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以自定义在页面底部显示自己的信息,方法是` admin账号-&gt;系统设置-&gt;其他-&gt;自定义html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var html = document.getElementsByClassName(&quot;common-footer&quot;)[0].innerHTML;</span><br><span class="line">document.getElementsByClassName(&quot;common-footer&quot;)[0].innerHTML = html + &quot;Copyright@ 1611253728@qq.com&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>隐藏设置界面和下拉菜单中的<code>免费版</code>字样</p>
<p>这里我通过添加自定义css没有效果所以是直接修改的css文件.请做好备份</p>
<ol>
<li><p>右键选择<code>免费版</code>,在右键菜单中选择<code>检查</code>;</p>
</li>
<li><p>复制标签名(我的是<code> version-vip</code> ),鼠标移到下图位置会显示改页面的css位置.</p>
</li>
<li><p>找到这个文件进行编辑.</p>
</li>
<li><p>ctrl+f 输入刚才复制的标签名进行搜索.</p>
</li>
<li><p>在属性中添加<code>visibility: hidden;</code>,并将<code>height</code>值改为0.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.version-vip</span>&#123;<span class="attribute">visibility</span>: hidden;<span class="attribute">height</span>:<span class="number">0px</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>保存后就可以看到效果了</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>KodExplorer</tag>
      </tags>
  </entry>
  <entry>
    <title>openwrt折腾笔记</title>
    <url>/2022/09/01/openwrt%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文记录使用Winserver环境下使用Hyper-V安装OpenWRT的过程。</p>
<h2 id="下载OpenWRT固件"><a href="#下载OpenWRT固件" class="headerlink" title="下载OpenWRT固件"></a>下载OpenWRT固件</h2><p>推荐下载别人已经编译好的OpenWRT固件。我这里使用的是由<a href="https://op.supes.top/firmware/x86_64/">Kiddin</a>二次编译过的LuCI的固件。</p>
<h2 id="转为虚拟磁盘文件"><a href="#转为虚拟磁盘文件" class="headerlink" title="转为虚拟磁盘文件"></a>转为虚拟磁盘文件</h2><p>下载安装<code>StarWind V2V Converter</code>软件。然后点击Local File转换镜像文件<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.3o033mqvamo0.jpg" alt="image"><br>然后继续选择Local File，在之后的界面选择VHD/VHDX，最后再选择磁盘镜像的具体格式即可选择导出路径进行转换。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.oyaxaxxqs28.jpg" alt="image"></p>
<h2 id="导入Hyper-V"><a href="#导入Hyper-V" class="headerlink" title="导入Hyper-V"></a>导入Hyper-V</h2><p>正常创建虚拟机，但是再连接虚拟硬盘这一步要选择使用现有虚拟硬盘。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4vu9ma90l5k0.jpg" alt="image"></p>
<h2 id="配置OpenWRT的IP"><a href="#配置OpenWRT的IP" class="headerlink" title="配置OpenWRT的IP"></a>配置OpenWRT的IP</h2><p>打开虚拟机，在终端输入<code>vim /etc/config/network</code>使用vim手动编辑IP设置。<br>修改lan口设置为固定ip<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.5ihqux07rhs0.jpg" alt="image"></p>
<h2 id="进入OpenWRT网页管理界面继续设置"><a href="#进入OpenWRT网页管理界面继续设置" class="headerlink" title="进入OpenWRT网页管理界面继续设置"></a>进入OpenWRT网页管理界面继续设置</h2><p>在浏览器输入刚才修改的IP即可进入管理界面。默认密码为空。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.jsw8wd2cop8.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2020/03/27/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li><p>每调用一次 <code>print()</code> 就会换一次行，你可以通过 <code>print()</code> 的另一个参数 <code>end</code> 来替换这个换行符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;my name is %s.I am %d years old&quot; % (&#x27;Shixiaolou&#x27;,4))</span><br></pre></td></tr></table></figure></li>
<li><p><code>print(&quot;&#123;:5d&#125;&quot;.format(a)) </code> 格式化输出语句.{:5d} 输出长度5的整型,str.format()传递参数</p>
</li>
<li><p>```<br>print(“-“ * 50)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   字符串若是乘上整数 n，将返回由 n 个此字符串拼接起来的新字符串。</span><br><span class="line"></span><br><span class="line">4. **while** </span><br><span class="line">   </span><br><span class="line">   ```python</span><br><span class="line">   while n &lt;= 100:</span><br><span class="line">       term *= x / n</span><br><span class="line">       result += term</span><br><span class="line">       n += 1</span><br><span class="line">       if term &lt; 0.0001: </span><br><span class="line">           break            </span><br></pre></td></tr></table></figure></li>
<li><p>for语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in a:</span><br><span class="line">for x in a[:]:</span><br><span class="line">for i in range(5):  range(i,j,k) 以间隔K访问第i到第j个的数据.i和 k可省略</span><br></pre></td></tr></table></figure>

<ol>
<li>可以在循环后面使用可选的 <code>else</code> 语句。它将会在循环完毕后执行，除非有 <code>break</code> 语句终止了循环。</li>
</ol>
</li>
<li><p><strong>列表/序列(有点像数组?)  竟然还可以当作栈和队列使用</strong></p>
<ol>
<li><p>```<br>a[0],访问第一个.<br>a[-1],访问末尾第一个<br>切片: 切片并不会改变正在操作的列表，切片操作返回其子列表</p>
<pre><code>省略的第一个索引默认为零，省略的第二个索引默认为切片的字符串的大小：a[:]
a[i:j],访问第i到第j个的.
a[i:j:k]:以间隔K访问第i到第j个的数据.
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   列表也支持连接这样的操作，它返回一个新的列表：</span><br><span class="line">    a + [36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure></li>
<li><p>切片赋值，此操作可以改变列表的尺寸，或清空它</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 替换某些值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 现在移除他们</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 通过替换所有元素为空列表来清空这个列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:] = []</span><br></pre></td></tr></table></figure></li>
<li><p><code>len()</code> 可查看长度 ; <code>type()</code> 可查看类型</p>
</li>
<li><p>检查某值是否在列表中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&#x27;ShiYanLou&#x27;, &#x27;is&#x27;, &#x27;cool&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;cool&#x27; in a</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li>
<li><p>检查列表是否为空 <code>if list_name:</code></p>
</li>
<li><p>列表允许嵌套</p>
</li>
<li><p>```<br>a.append(45) 在列表末尾添加数字45</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">9. ```</span><br><span class="line">   a.insert(1, 2) 在索引1处插入数字2</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>a.count(45)  统计 45 这个元素在列表中出现了多少次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11. ```</span><br><span class="line">    a.remove(234) 移除列表中 值为234的数据</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>a.reverse()  反转列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">13. ```</span><br><span class="line">    a.extend(b) # 添加 b 的元素而不是 b 本身  类似于a + b</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>del a[-1]   删除a[-1]位置的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">15. ```</span><br><span class="line">    遍历两个序列类型，你可以使用 zip() 函数。</span><br><span class="line">    for x, y in zip(a, b):</span><br><span class="line">    ...     print(&quot;&#123;&#125; uses &#123;&#125;&quot;.format(x, y))</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 enumerate()。<br>for i, j in enumerate([‘a’, ‘b’, ‘c’]):<br>…     print(i, j)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">17. ```</span><br><span class="line">    当作栈或队列时</span><br><span class="line">    a.append() 类似于push</span><br><span class="line">    a.pop()   栈的pop</span><br><span class="line">    a.pop(0)   队列的pop</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>列表推导式</strong></p>
<ol>
<li><p>```<br>for x in range(10):</p>
<pre><code> squares.append(x**2)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   squares = list(map(lambda x: x**2, range(10)))</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>squares = list(map(lambda x: x**2, range(10)))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">8. **元组**</span><br><span class="line">   </span><br><span class="line">   1. 元组是由数个逗号分割的值组成。</span><br><span class="line">   2. 元组是不可变类型</span><br><span class="line">   3. divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</span><br><span class="line"></span><br><span class="line">9. **集合**  集合是一个**无序不重复元素**的集。</span><br><span class="line">   </span><br><span class="line">   1. 集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算</span><br><span class="line">   </span><br><span class="line">   2. 大括号或 set() 函数可以用来创建集合。</span><br><span class="line">      </span><br><span class="line">      **注意**：想要创建空集合，你必须使用 set() 而不是 &#123;&#125;。后者用于创建空字典，</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>a.pop()  # pop 方法随机删除一个元素并打印<br>‘h’<br>a.add(‘c’)    #插入一个元素 字符c</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">10. **字典**(dict)  是无序的键值对（`key:value`）集合</span><br><span class="line">    </span><br><span class="line">    1. ```</span><br><span class="line">       创建字典: data = &#123;&#x27;kushal&#x27;:&#x27;Fedora&#x27;, &#x27;kart_&#x27;:&#x27;Debian&#x27;, &#x27;Jace&#x27;:&#x27;Mac&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建新的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data[&#x27;parthan&#x27;] = &#x27;Ubuntu&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><code>del</code> 关键字删除任意指定的键值对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del 关键字删除任意指定的键值对</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>in</code> 关键字查询指定的键是否存在于字典中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;ShiYanLou&#x27; in data</span><br></pre></td></tr></table></figure></li>
<li><p><code>dict()</code> 可以从包含键值对的元组中创建字典。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dict(((&#x27;Indian&#x27;,&#x27;Delhi&#x27;),(&#x27;Bangladesh&#x27;,&#x27;Dhaka&#x27;)))</span><br><span class="line">&#123;&#x27;Indian&#x27;: &#x27;Delhi&#x27;, &#x27;Bangladesh&#x27;: &#x27;Dhaka&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遍历字典用<code>items()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x, y in data.items():</span><br></pre></td></tr></table></figure></li>
<li><p>往字典中的元素添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data.setdefault(&#x27;names&#x27;, []).append(&#x27;Ruby&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>dict.get(key, default)</code> 来索引键，如果键不存在，那么返回指定的 default 值。</p>
</li>
</ol>
</li>
<li><p><strong>字符串</strong></p>
<ol>
<li><p>字符串标识 “…”和’…’都能表示,<strong>区别?</strong></p>
</li>
<li><p>如果你想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;&quot;\</span><br><span class="line"> Usage: thingy [OPTIONS]</span><br><span class="line">      -h                        Display this usage message</span><br><span class="line">      -H hostname               Hostname to connect to</span><br><span class="line"> &quot;&quot;&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>方法 <code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写。</p>
</li>
<li><p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写</p>
</li>
<li><p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本 :</p>
</li>
<li><p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字</p>
</li>
<li><p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母。</p>
</li>
<li><p>使用 <code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>）</p>
</li>
<li><p>方法 <code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;-&quot;.join(&quot;GNU/Linux is great&quot;.split())</span><br><span class="line">&#x27;GNU/Linux-is-great&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><code>strip(chars)</code>，用来剥离字符串首尾中指定的字符,不指定参数则默认剥离掉首尾的空格和换行符</p>
</li>
<li><p>使用 <code>lstrip(chars)</code> 或 <code>rstrip(chars)</code> 只对字符串左或右剥离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.lstrip(&quot;cwsd.&quot;) #删除在字符串左边出现的&#x27;c&#x27;,&#x27;w&#x27;,&#x27;s&#x27;,&#x27;d&#x27;,&#x27;.&#x27;字符</span><br></pre></td></tr></table></figure></li>
<li><p>文本搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.find(&quot;fora&quot;)   #find() 找到第一个匹配的子字符串，没有找到则返回 -1。</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; s.startswith(&quot;fa&quot;) # 检查字符串是否以 fa 开头</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; s.endswith(&quot;reason&quot;) # 检查字符串是否以 reason 结尾</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li>
<li><p>z = s[::-1]  #把输入的字符串s 进行倒序处理形成新的字符串z</p>
</li>
</ol>
</li>
<li><p><strong>函数</strong></p>
<ol>
<li><p>定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名(参数):</span><br><span class="line">    语句1</span><br><span class="line">    语句2</span><br></pre></td></tr></table></figure></li>
<li><p>函数可以通过关键字参数的形式来调用，形如 keyword = value。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(a, b=5, c=10):</span><br><span class="line">...     print(&#x27;a is&#x27;, a, &#x27;and b is&#x27;, b, &#x27;and c is&#x27;, c)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; func(12, 24)</span><br><span class="line">a is 12 and b is 24 and c is 10</span><br><span class="line">&gt;&gt;&gt; func(12, c = 24)</span><br><span class="line">a is 12 and b is 5 and c is 24</span><br><span class="line">&gt;&gt;&gt; func(b=12, c = 24, a = -1)</span><br><span class="line">a is -1 and b is 12 and c is 24</span><br><span class="line">在上面的例子中你能看见调用函数时使用了变量名，比如 func(12,c = 24)，这样我们将 24 赋给 c 且 b 具有默认值。</span><br></pre></td></tr></table></figure></li>
<li><p>强制关键字参数</p>
<p>函数的参数标记为只允许使用关键字参数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def hello(*, name=&#x27;User&#x27;)</span><br><span class="line">输入hello(&#x27;shiyanlou&#x27;)报错</span><br><span class="line">hello(&#x27;shiyanlou&#x27;) 正确</span><br></pre></td></tr></table></figure></li>
<li><p><strong>文档字符串</strong>????不太懂,继续看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__doc__ 属性表示函数中中的注释部分</span><br></pre></td></tr></table></figure></li>
<li><p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个函数，将参数列表中每个元素都变成全大写</span><br><span class="line">&gt;&gt;&gt; def high(l):</span><br><span class="line">...     return [i.upper() for i in l]</span><br><span class="line">...</span><br><span class="line"># 创建高阶函数，接受一个函数和一个列表作为参数</span><br><span class="line">&gt;&gt;&gt; def test(h, l):</span><br><span class="line">...     return h(l)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; l = [&#x27;python&#x27;, &#x27;Linux&#x27;, &#x27;Git&#x27;]</span><br><span class="line"># 运行高阶函数，返回预期的结果</span><br><span class="line">&gt;&gt;&gt; test(high, l)</span><br><span class="line">[&#x27;PYTHON&#x27;, &#x27;LINUX&#x27;, &#x27;GIT&#x27;]</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>map</code>函数</strong></p>
<p>接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器）</p>
</li>
</ol>
<p> <code>if __name__ == &#39;__main__&#39;:</code> 这条语句，它的作用是，只有在当前模块名为 <code>__main__</code> 的时候（即作为脚本执行的时候）才会执行此 <code>if</code> 块内的语句。</p>
</li>
<li><p><strong>文件</strong></p>
<ol>
<li><p>打开文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fobj = open(&quot;sample.txt&quot;)</span><br><span class="line">或者</span><br><span class="line">with open(&#x27;sample.txt&#x27;) as fobj:使用 with 语句处理文件对象，它会在文件用完后会自动关闭</span><br></pre></td></tr></table></figure></li>
<li><p>关闭文件 <code>fobj.close()</code></p>
</li>
<li><p>读取文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 read() 方法一次性读取整个文件。 可是传入参数size</span><br><span class="line">readline() 能帮助你每次读取文件的一行。</span><br><span class="line">使用 readlines() 方法读取所有行到一个列表中。</span><br><span class="line">循环遍历文件对象来读取文件中的每一行。    for x in fobj:</span><br><span class="line">                                ...     print(x, end = &#x27;&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>文件写入 <code>write()</code>添加到文末</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fobj.write(&#x27;powerpork\n&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝文件</p>
<ol>
<li><p>sys模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys.argv包含所有命令行参数.</span><br><span class="line">sys.argv[0]是命令自身的名字</span><br></pre></td></tr></table></figure></li>
<li><pre><code>enumerate(iterableobject)索引位置和对应值可以使用它同时得到
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 文本统计</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
count()函数 str.count(&quot;char&quot;, start,end),统计在start-end中字符char的次数
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    7. with语句</span><br><span class="line">       </span><br><span class="line">       它会在文件用完后会自动关闭，就算发生异常也没关系。它是 try-finally 块的简写</span><br><span class="line"></span><br><span class="line">14. **异常处理**</span><br><span class="line">    </span><br><span class="line">    1. `try...except`块处理异常</span><br><span class="line">       </span><br><span class="line">       `except  SyntaxError`语法异常</span><br><span class="line">       </span><br><span class="line">       `except NameError`未定义变量异常</span><br><span class="line">       </span><br><span class="line">       `except TypeError` 类型异常</span><br><span class="line">       </span><br><span class="line">       一个空的 except 语句能捕获任何异常</span><br><span class="line">    </span><br><span class="line">    2. raise抛出异常</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
try:
...     raise ValueError(&quot;A value error happened.&quot;)
... except ValueError:
...     print(&quot;ValueError in our code.&quot;)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. finally清理行为</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
不管有没有发生异常，finally 子句 在程序离开 try 后都一定会被执行。
在真实场景的应用程序中，finally 子句用于释放外部资源
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">15. **类**</span><br><span class="line">    </span><br><span class="line">    1. 定义简单的类</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
class nameoftheclass(parent_class):
 statement1
 statement2
 statement3
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. `__init__ `方法</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
def __init__(self):
 self.data = []
类定义了 __init__() 方法的话，类的实例化操作会自动为新创建的类实例调用 __init__() 方法。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. Python 中的继承</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
class Student(Person): Student类继承Person
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 多继承</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
class MyClass(Parentclass1, Parentclass2,...):
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 删除对象</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
关键字 del 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 属性读取方法</span><br><span class="line"></span><br><span class="line">7. `@property` 装饰器</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
@property 装饰器就是负责把一个方法变成属性调用的。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">16. **模块**</span><br><span class="line">    </span><br><span class="line">    1. 模块的导入</span><br><span class="line">       </span><br><span class="line">       1. 可以由全局变量 `__name__` 得到模块的模块名</span><br><span class="line">       2. 从模块中导入指定的函数。`from bars import simplebar, starbar`</span><br><span class="line">    </span><br><span class="line">    2. 包</span><br><span class="line">       </span><br><span class="line">       1. 含有 `__init__.py` 文件的目录可以用来作为一个包</span><br><span class="line">    </span><br><span class="line">    3. 默认/第三方模块介绍</span><br><span class="line">       </span><br><span class="line">       1. os 模块    </span><br><span class="line">          </span><br></pre></td></tr></table></figure>
getuid() 函数返回当前进程的有效用户 id。
getpid() 函数返回当前进程的 id。getppid() 返回父进程的 id。
uname() 函数返回识别操作系统的不同信息
getcwd() 函数返回当前工作目录
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. Requests 模块  http库</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
可以使用 get() 方法获取任意一个网页
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       </span><br><span class="line">       3. argparse 命令行参数处理模块</span><br><span class="line">    </span><br><span class="line">    4. 命令行参数</span><br><span class="line"></span><br><span class="line">17. **Collections 模块**</span><br><span class="line">    </span><br><span class="line">    1. `Counter` 是一个有助于 *hashable* 对象计数的 dict 子类</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
elements() 的方法，其返回的序列中，依照计数重复元素相同次数
most_common() 方法返回最常见的元素及其计数，顺序为最常见到最少。
</code></pre>
</li>
</ol>
</li>
<li><p><code>defaultdict</code> 是内建 <code>dict</code> 类的子类，它覆写了一个方法并添加了一个可写的实例变量。</p>
<p>defaultdict() 第一个参数提供了 default_factory 属性的初始值，默认值为 None，default_factory</p>
</li>
<li><p><code>namedtuple</code>    命名元组有助于对元组每个位置赋予意义，并且让我们的代码有更好的可读性和自文档性。</p>
</li>
</ol>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>为code-server配置c++环境</title>
    <url>/2022/08/27/%E4%B8%BAcode-server%E9%85%8D%E7%BD%AEcpp%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>code-server默认是不支持运行和调试C++的，并且在插件库中也找不到C++的环境插件。但是我们可以通过手动安装的方式来让IDE支持C++的调试运行。</p>
<h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>gcc是一定要安装的，没安装的话执行<code>sudo apt install build-essential</code>安装</p>
<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>由于插件库没有内置C/C++插件，所以我们需要去VSCode插件网站下载插件。</p>
<ul>
<li>浏览器打开<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">插件页面</a></li>
<li>进入插件页面后点击右下角的<code>Download Extension</code>选择对应平台进行下载。</li>
<li>将下载的插件上传到服务器。<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3>推荐使用IDE在线安装。具体流程如下</li>
<li>IDE资源管理器打开插件上传目录</li>
<li>在插件条目上右键选择<code>从VSIX安装</code>即可安装插件。如果提示<code>Corrupt ZIP: end of central directory record signature not found</code>则说明插件安装包有错误，重新下载即可。<h3 id="配置launch-json和task-json"><a href="#配置launch-json和task-json" class="headerlink" title="配置launch.json和task.json"></a>配置launch.json和task.json</h3>这里推荐使用C/C++ Config插件。安装完插件后按下<code>Ctrl + Shift + P</code>组合键，在弹出输入框输入<code>Generate C++ Config Files</code>即可一键生成配置文件。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果安装C/C++插件后进行插件设置时提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IntelliSense-related commands cannot be executed when `C_Cpp.intelliSenseEngine` is set to `Disabled`.</span><br></pre></td></tr></table></figure>
<p>可以通过修改<code>/home/ubuntu/.local/share/code-server/User/settings.json</code>文件将<code>&quot;C_Cpp.intelliSenseEngine&quot;: &quot;Disable&quot;,</code>修改为<code>&quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;,</code>解决。</p>
<p>同时如果打开cpp文件后右上角没有三角形的运行图标，此方法也是部分情况下的解决方式。</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>code-server</tag>
      </tags>
  </entry>
  <entry>
    <title>为code-server配置https解决Markdown无法预览的问题</title>
    <url>/2022/08/27/%E4%B8%BAcode-server%E9%85%8D%E7%BD%AEhttps%E8%A7%A3%E5%86%B3Markdown%E6%97%A0%E6%B3%95%E9%A2%84%E8%A7%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>首先为IDE安装<code>Markdown All in One</code>插件启用Markdown编辑预览支持。<br>但是此时右键选择预览时发现预览栏空白，没有渲染。查看浏览器控制台发现浏览器拒绝了预览显示的请求。<br>为网站配置SSL证书可以解决这个问题。</li>
<li>申请SSL证书，如果没有为服务器绑定域名可以通过<a href="https://zerossl.com/">ZeroSSL</a>为服务器IP申请SSL证书，证书有效期3个月。当然该网站也支持为域名下发证书。申请证书流程不做赘述。</li>
<li>为Nginx配置HTTPS。<ul>
<li>首先需要将证书文件上传至服务器，包括两个<code>.crt</code>文件和一个<code>.key</code>文件。</li>
<li>接着配置证书。进入nginx安装目录，执行<code>sudo vim conf/nginx.conf</code>编辑配置文件<br>https最基本配置内容如下,<code># #</code>内要修改为自己的实际环境<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen               443 ssl;</span><br><span class="line">    </span><br><span class="line"> ssl                  on;</span><br><span class="line"> ssl_certificate      # certificate.crt路径 #; </span><br><span class="line"> ssl_certificate_key  # private.key 路径 #;</span><br><span class="line"></span><br><span class="line"> server_name  # 你的ip地址或者域名 #;</span><br><span class="line"></span><br><span class="line"> location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
配置完成后重启nginx，之后就可以在浏览器通过https访问了。</li>
</ul>
</li>
<li>配置code-server通过https访问。<br>由于https默认不允许<code>ip:port</code>的方式访问网站，所以需要通过Nginx进行反代设置。<ul>
<li>继续修改上文的nginx配置文件，主要是将<code>location /</code>中内容替换<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen               443 ssl;</span><br><span class="line">    </span><br><span class="line"> ssl                  on;</span><br><span class="line"> ssl_certificate      # certificate.crt路径 #; </span><br><span class="line"> ssl_certificate_key  # private.key 路径 #;</span><br><span class="line"></span><br><span class="line"> server_name  # 你的ip地址或者域名 #;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection upgrade;</span><br><span class="line">        proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改code-server的配置文件<br><code>sudo vim /home/ubuntu/.config/code-server/config.yaml</code><br>将最后一行修改为如下内容，<code># #</code>中的内容要替换<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cert:</span> <span class="comment"># certificate.crt路径 #</span></span><br><span class="line"><span class="attr">cert-key:</span> <span class="comment"># private.key 路径 #</span></span><br></pre></td></tr></table></figure>
此时重启服务就可以通过访问<code>https://ip:8080</code>在https下打开IDE了。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>code-server</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo及Gitee搭建博客</title>
    <url>/2022/07/09/%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AGitee%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p> Hexo官方文档地址：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p>
<h1 id="Step1：安装Node-Js"><a href="#Step1：安装Node-Js" class="headerlink" title="Step1：安装Node.Js"></a>Step1：安装Node.Js</h1><p>前往<a href="%5Bnodejs.org%5D(https://nodejs.org/)">NPM官网</a>下载适合自己系统的Node.Js。</p>
<p>更换为国内镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>查看当前镜像是否修改成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm get registry</span><br></pre></td></tr></table></figure>

<h1 id="Step2-安装Git"><a href="#Step2-安装Git" class="headerlink" title="Step2: 安装Git"></a>Step2: 安装Git</h1><p>可以在安装git后设置SSH公钥。</p>
<p>Gitee生成/添加SSH公钥教程：<a href="https://gitee.com/help/articles/4181#article-header0">生成/添加SSH公钥 - Gitee.com</a></p>
<h1 id="Step3：安装Hexo"><a href="#Step3：安装Hexo" class="headerlink" title="Step3：安装Hexo"></a>Step3：安装Hexo</h1><p>使用 npm 安装 Hexo。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>同时为了推送到Gitee需要安装如下插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h1 id="Step4：Hexo生成blog目录"><a href="#Step4：Hexo生成blog目录" class="headerlink" title="Step4：Hexo生成blog目录"></a>Step4：Hexo生成blog目录</h1><p>使用如下指令在指定文件夹中新建所需要的文件，<code>&lt;folder&gt;</code>为指定的空文件夹名</p>
<p>如果是Window操作系统，需要设置PoweShell允许脚本运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Step5：修改网站配置信息"><a href="#Step5：修改网站配置信息" class="headerlink" title="Step5：修改网站配置信息"></a>Step5：修改网站配置信息</h1><p>进入网站文件目录下，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>对<code> _config.yml</code>进行修改。</p>
<p>在配置文件最后进行如下修改以推送到gitee仓库,github同理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: git@gitee.com:XXXXXX.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>如果需要同时添加多个仓库则如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: &#x27;git&#x27;</span><br><span class="line">  repo: git@gitee.com:xxxx.git</span><br><span class="line">  branch: xxx</span><br><span class="line"></span><br><span class="line">- type: &#x27;git&#x27;</span><br><span class="line">  repo: git@github.com:xxxx.git</span><br><span class="line">  branch: xxx</span><br></pre></td></tr></table></figure>

<h1 id="配置结束"><a href="#配置结束" class="headerlink" title="配置结束"></a>配置结束</h1><p>之后要对网站进行修改都需要进入博客所在目录进行终端操作。</p>
<h1 id="创建新文档"><a href="#创建新文档" class="headerlink" title="创建新文档"></a>创建新文档</h1><p>使用如下指令创建文档，而后在<code>source/_posts</code>文件下生成md文件。<code>[layout]</code>可省略使用默认布局.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<h1 id="生成并部署"><a href="#生成并部署" class="headerlink" title="生成并部署"></a>生成并部署</h1><p>使用如下命令使，Hexo 在生成完毕后自动部署网站</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate --deploy</span><br></pre></td></tr></table></figure>

<p>该命令也可简写为<code>hexo g -d</code></p>
<p>如未安装<code>hexo-deployer-git</code>插件则会出现<code># ERROR Deployer not found</code>错误。</p>
<h1 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h1><p>在博客目录下打开终端输入如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>创建成功打开<code>source/tags</code>目录下的<code>index.md</code>文件添加type属性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: XXX</span><br><span class="line"><span class="built_in">date</span>: XXX-XXXX</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在文章中使用分类只需要在抬头中添加<code>tags</code>属性即可，Hexo会自动创建分类索引。</p>
<p>一篇文章只能设置多个标签。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用Hexo及Gitee搭建博客</span><br><span class="line">date: <span class="number">2022</span>-<span class="number">07</span>-<span class="number">09</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">06</span></span><br><span class="line">tags: </span><br><span class="line">    - Hexo</span><br><span class="line">    - Git</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h1><p>在博客目录下打开终端输入如下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>创建成功打开<code>source/categories</code>目录下的<code>index.md</code>文件添加type属性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: XXXX</span><br><span class="line"><span class="built_in">date</span>: XXX-XXXX</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在文章中使用分类只需要在抬头中添加<code>categories: XXX</code>即可，Hexo会自动创建分类索引。</p>
<p>一篇文章只能设置一个分类。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用Hexo及Gitee搭建博客</span><br><span class="line">date: <span class="number">2022</span>-<span class="number">07</span>-<span class="number">09</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">06</span></span><br><span class="line">categories: 配置教程</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="图床问题"><a href="#图床问题" class="headerlink" title="图床问题"></a>图床问题</h1><p>可以自建Github仓库作为图床，使用<a href="https://picx.xpoet.cn/">PicX</a>方便快速的管理。</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开启代理上传Git</title>
    <url>/2022/07/11/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E4%B8%8A%E4%BC%A0Git/</url>
    <content><![CDATA[<p>如果Git上传时出现<code>Failed to connect to github.com port 443: Timed out</code>，则说明当前网络环境连不上Github，需要开启代理。</p>
<p>以代理工具Clash为例。</p>
<p>先开启Clash的系统代理<code>System Proxy</code></p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111803521.png" alt="image-20220711180300486"></p>
<p>然后再终端执行如下代码开启代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>等上传结束后再执行指令关闭代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Clash</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置VsCode_Online踩坑记录</title>
    <url>/2022/08/26/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEVsCode-Online%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本来使用腾讯云的theia IDE轻量应用服务器当作云端IDE的，但是无奈太难用了，launch.json的语法支持貌似和VSC也不一样。然后偶然发现VSC已经有Web版本了，折腾了一下终于安装成功，这里记录一下踩坑经历。</p>
<h2 id="安装方式选择"><a href="#安装方式选择" class="headerlink" title="安装方式选择"></a>安装方式选择</h2><p>配置VSCode Online有几种方法：</p>
<ul>
<li>微软官方提供一个收费版本（含azure的服务器费用，捆绑销售），不推荐</li>
<li>下载 VSCode 源代码，编译以后通过yarn web启动。配置难度大，不推荐</li>
<li>通过 Code-Server 安装: <a href="https://coder.com/">https://coder.com</a></li>
<li>使用/修改现成的 docker 镜像：linuxserver/docker-code-server</li>
</ul>
<p>我选择的是通过Code-Server安装,这里要注意第一个坑。<strong>通过上边这个coder网站首页下载的并非是我们所需要的Code-Server</strong>。<br>我们需要点进去文档界面，再左上角产品选择位置选择Code-Server（默认为Coder-OSS）。<br>在文档中提供了多种安装方式说明。这里推荐两种：</p>
<ol>
<li>通过脚本一键安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://code-server.dev/install.sh | sh</span><br></pre></td></tr></table></figure>
如果要查看安装过程中的输出可以采用如下指令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run</span><br></pre></td></tr></table></figure>
需要注意的是通过脚本安装方式，由于国内服务器访问github较慢，耗费时间很长。</li>
<li>下载安装包进行安装<br>进入Code-server的github发布页下载最新版本的deb安装包<br><code>https://github.com/coder/code-server/releases/</code><br>这里下载安装包也有两种方式;<ul>
<li>直接下载到本地再上传到服务器</li>
<li><code>curl -fOL </code> 后加下载链接直接下载到服务器。下载链接可以通过转换工具转换为CDN加速后的链接，下载速度更快。<br>然后就可以安装程序了(XXX替换为自己的安装包名)<br><code>sudo dpkg -i code-server_XXXX.deb</code><br>然后再执行指令添加到系统服务执行($USER换为自己的用户名)<br><code>sudo systemctl enable --now code-server@$USER</code></li>
</ul>
</li>
</ol>
<h1 id="配置Code-server"><a href="#配置Code-server" class="headerlink" title="配置Code-server"></a>配置Code-server</h1><p>安装完成后Code-server默认是在 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a> 访问的且只能本地访问.<br>登入的密码可以在 <code>~/.config/code-server/config.yaml</code>查看，同时该文件也包含了其他必要的配置内容。<br>该文件默认格式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: afiaoskjfiojaoa468546</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure>
<p>只需要简单修改<code>bind-addr</code>和<code>password</code>即可外网通过<code>IP:8080</code>访问</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">bind-addr: 0.0.0.0:8080</span><br><span class="line">auth: password</span><br><span class="line">password: （你的密码）</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure>
<p>接下来就可以安装插件使用你的WebIDE编程了</p>
]]></content>
      <categories>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>code-server</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim简单使用</title>
    <url>/2020/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h1><ul>
<li><p><code>vi</code>启动后，进入普通模式</p>
<p>控制屏幕光标的移动; 删除字符或行; 复制、粘贴; 查找文本</p>
<ul>
<li>输入键<code>i</code>，进入插入模式</li>
<li>输入键<code>:</code>，进入命令模式</li>
</ul>
</li>
<li><p>在插入模式下</p>
<p>输入字符; 在命令模式下的命令，作为普通字符被插入到光标当前位置</p>
<ul>
<li>输入键<code>Esc</code>(不是<code>E</code> <code>s</code> <code>c</code>3个键)，返回普通模式</li>
</ul>
</li>
<li><p>在命令模式下</p>
<p>替换文本; 保存文件; 退出程序</p>
<ul>
<li>输入键<code>Esc</code>(不是<code>E</code> <code>s</code> <code>c</code>3个键)，返回普通模式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构必背算法</title>
    <url>/2021/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BF%85%E8%83%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="矩阵快速转置"><a href="#矩阵快速转置" class="headerlink" title="矩阵快速转置"></a>矩阵快速转置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*稀疏矩阵用三元组表示。</span></span><br><span class="line"><span class="comment">需要设置num和cpot两个向量。</span></span><br><span class="line"><span class="comment">num[col]表示矩阵M中第col列中非零元的个数。</span></span><br><span class="line"><span class="comment">copt[col]指示M中第col列的第一个非零元在转置后的三元组的位置。</span></span><br><span class="line"><span class="comment">cpot[1] = 1; cpot[col] = cpot[col - 1] + num[col - 1],2&lt;=col&lt;=列数nu；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">( TSMatrix M, TSMatrix &amp;T)</span> </span>&#123;</span><br><span class="line">    T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; <span class="comment">//T的行数列数=M的列数行数，非零元个数相同</span></span><br><span class="line">    <span class="keyword">if</span>(T.tu) &#123;</span><br><span class="line">        <span class="keyword">for</span>(col = <span class="number">1</span>; col &lt; M.nu; ++col) num[col] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">1</span>; t &lt;= M.nu; ++t) ++num[M.data[t].j]; <span class="comment">//求M中每一列含非零元个数</span></span><br><span class="line">        cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(col =  <span class="number">2</span>; col &lt;= M.nu; ++col)</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">1</span>; p &lt;= M.tu; ++p) &#123;</span><br><span class="line">            col = M.data[p].j; q = cpot[col];</span><br><span class="line">            T.data[q].i = M.data[p].j; T.data[q].j = M.data[p].i;</span><br><span class="line">            T.data[q].e = M.data[p].e; ++cpot[col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li><p>先序遍历：根左右<br />递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="built_in">visit</span>(T) ; <span class="comment">//访问根结点</span></span><br><span class="line">     <span class="built_in">PreOrder</span>(T-&gt;lchild) ; <span class="comment">//递归遍历左子树</span></span><br><span class="line">     <span class="built_in">PreOrder</span>(T-&gt;rchild) ; <span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">InitStack</span>(S); BiTree p=t;     <span class="comment">//初始化栈S，p是遍历指针</span></span><br><span class="line"> <span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S)) &#123;     <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">     <span class="keyword">if</span>(p) &#123;                    <span class="comment">//遍历左子树</span></span><br><span class="line">         <span class="built_in">visit</span>(p); <span class="built_in">Push</span>(S, p);<span class="comment">//访问当前节点并入栈</span></span><br><span class="line">         p = p-&gt;lchild;        <span class="comment">//左孩子非空下一次继续遍历左孩子</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;                <span class="comment">//出栈，访问栈结点右子树</span></span><br><span class="line">         <span class="built_in">Pop</span>(S, p);            <span class="comment">//栈顶元素出栈</span></span><br><span class="line">         p=p-&gt;rchild;        <span class="comment">//访问右子树</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历：左根右</p>
</li>
</ol>
<p>递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild) ; <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T) ; <span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild) ; <span class="comment">//递归遍历右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S); BiTree p=t;     <span class="comment">//初始化栈S，p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S)) &#123;     <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p) &#123;                    <span class="comment">//遍历左子树</span></span><br><span class="line">            <span class="built_in">Push</span>(S, p);            <span class="comment">//当前节点入栈</span></span><br><span class="line">            p = p-&gt;lchild;        <span class="comment">//左孩子非空下一次继续遍历左孩子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">//出栈，访问栈结点右子树</span></span><br><span class="line">            <span class="built_in">Pop</span>(S, p); <span class="built_in">visit</span>(p); <span class="comment">//栈顶元素出栈,并访问</span></span><br><span class="line">            p=p-&gt;rchild;        <span class="comment">//下一次循环，访问右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>后序遍历：左右根</li>
</ol>
<p>递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild) ; <span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild) ; <span class="comment">//递归遍历右子树</span></span><br><span class="line">          <span class="built_in">visit</span>(T) ; <span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    p = T;                        <span class="comment">//p是遍历指针</span></span><br><span class="line">    r = <span class="literal">NULL</span>;                    <span class="comment">//r指向最近访问过的结点，以分清从左子树返回还是右子树返回</span></span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;                    <span class="comment">//走到最左边</span></span><br><span class="line">            <span class="built_in">push</span>(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">//向右</span></span><br><span class="line">            <span class="built_in">GetTop</span>(S, p);        <span class="comment">//读栈顶结点</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild!=r) &#123; <span class="comment">//若左子树存在且未被访问过</span></span><br><span class="line">                p = p-&gt;rchild;    <span class="comment">//转向右</span></span><br><span class="line">                <span class="built_in">push</span>(S, p);        <span class="comment">//压入栈</span></span><br><span class="line">                p = p-&gt;lchild;    <span class="comment">//再走到左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            <span class="comment">//否则</span></span><br><span class="line">                <span class="built_in">pop</span>(S, p);        <span class="comment">//将结点弹出</span></span><br><span class="line">                <span class="built_in">visit</span>(p-&gt;data);    <span class="comment">//访问该结点</span></span><br><span class="line">                r = p;             <span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;        <span class="comment">//结点访问完毕后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>层次遍历</li>
</ol>
<p>层次遍历常用来求每个元素所在层数、某层结点个数、树的最大宽度、树的高度等<br />求树的高度的算法，借助队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BtDepth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//树空，高度为0</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>, level = <span class="number">0</span>;    <span class="comment">//last指向当前层的最右结点</span></span><br><span class="line">    BiTree Q[MaxSize];            <span class="comment">//设置队列Q</span></span><br><span class="line">    Q[++rear] = T;                <span class="comment">//根结点入队</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear) &#123;        <span class="comment">//队不空，则循环</span></span><br><span class="line">        p=Q[++front];            <span class="comment">//队列元素出队，访问当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild) </span><br><span class="line">            Q[++rear] = p-&gt;lchild;    <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">            Q[++rear] = p-&gt;rchild;    <span class="comment">//右孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(front == last) &#123;</span><br><span class="line">            level++;                <span class="comment">//层数加一</span></span><br><span class="line">            last = rear;            <span class="comment">//last指向下层最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>记忆非递归算法更为合适，因为仅仅是把队列和栈替换。<br />全局变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Boolean visited[MAX];            <span class="comment">//访问标志数组</span></span><br><span class="line"><span class="built_in">Status</span> (*VisitFunc)(<span class="type">int</span> V);        <span class="comment">//函数变量</span></span><br></pre></td></tr></table></figure>

<ol>
<li>广度优先搜索：</li>
</ol>
<p>类似于树的按层次遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按广度优先非递归遍历图G。使用辅助队列Q和访问标志数组visited</span></span><br><span class="line"><span class="comment">//辅助队列Q保存正在访问顶点的下一层顶点</span></span><br><span class="line"><span class="comment">//visited标志顶点是否被访问过，防止被多次访问。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G, Status (*Visit)(<span class="type">int</span> v) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v) visited[v] = FALSE;</span></span></span><br><span class="line"><span class="params"><span class="function">    InitQueue(Q);                    <span class="comment">//置空的辅助队列Q</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v) </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span>(!visited[v]) &#123;            <span class="comment">//v未被访问</span></span></span></span><br><span class="line"><span class="params"><span class="function">            visited[v] = TRUE; </span></span></span><br><span class="line"><span class="params"><span class="function">            EnQueue(Q, v);            <span class="comment">//v入队列</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                DeQueue(Q, u);        <span class="comment">//队头元素出队并置为u</span></span></span></span><br><span class="line"><span class="params"><span class="function">                Visit(u);            <span class="comment">//访问u</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">for</span>(w = FirstNeighbor(G, u); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, u, w))</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">if</span>(!visited[w]) &#123;        <span class="comment">//w为u的尚未访问的临接顶点</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        visited[w] = TRUE;</span></span></span><br><span class="line"><span class="params"><span class="function">                        EnQueue(Q, w);</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>深度优先搜索：<br> 递归算法</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G, Status (*Visit)(<span class="type">int</span> v))</span> </span>&#123;</span><br><span class="line">VisitFunc = Visit;        <span class="comment">//使用全局变量VisitFunc，使DFS不必设函数指针参数。</span></span><br><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v) visited[v] = FALSE; <span class="comment">//访问标志数组初始化</span></span><br><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">  <span class="keyword">if</span>(!visited[v]) <span class="built_in">DFS</span>(G, v);    <span class="comment">//对未访问的顶点调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第v个顶点出发递归地深度优先遍历图G</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    visited[v] = TRUE; <span class="built_in">VisitFunc</span>(v);    <span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) <span class="built_in">DFS</span>(G, w);    <span class="comment">//对v的尚未访问的邻接顶点w递归调用DFS</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p> 非递归算法</p>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按深度优先非递归遍历图G，使用辅助栈S和访问标记数组visited</span></span><br><span class="line"><span class="comment">//栈S来记忆下一步可能访问的顶点</span></span><br><span class="line"><span class="comment">//visited标记顶点是否被访问过，防止多次访问。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w;            <span class="comment">//顶点序号</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);    <span class="comment">//初始化栈S</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++) visited[i] = FALSE;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v) </span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, v); visited[v] = TRUE;    <span class="comment">//v入栈</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S)) &#123;</span><br><span class="line">                k = <span class="built_in">Pop</span>(S); <span class="built_in">visit</span>(k);    <span class="comment">//访问栈顶结点</span></span><br><span class="line">                <span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G, k); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, k, w))</span><br><span class="line">                <span class="keyword">if</span>(!visited[w]) &#123;</span><br><span class="line">                    <span class="built_in">Push</span>(S, w);</span><br><span class="line">                    visited[w] = TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><ol>
<li>Prim算法：适合边稠密的图<ol>
<li><p>算法思想：初始时从图中任取一顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中顶点数和边数都增1.以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。</p>
</li>
<li><p>所需添加的数据结构closedge[]，记录从U到V-U具有最小代价的边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">VertexType adjvex;    <span class="comment">//最小代价的边在U中依附的顶点</span></span><br><span class="line">VRType lowcost;        <span class="comment">//最小代价的边的权值；</span></span><br><span class="line">&#125; closedge[ MAX_VERTEX_NUM ]</span><br></pre></td></tr></table></figure></li>
<li><p>算法实现（一般不考）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PRIM</span><span class="params">(MGraph G, VertexType u)</span> </span>&#123;</span><br><span class="line">k = <span class="built_in">LocateVex</span>(G, u);</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j)     <span class="comment">//初始化辅助数组</span></span><br><span class="line">  <span class="keyword">if</span>(j != k) closedge[j] = &#123;u, G.arcs[k][j].adj&#125;;</span><br><span class="line">closedge[k].lowcost = <span class="number">0</span>;        <span class="comment">//初始，U=&#123;u&#125;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">  k = <span class="built_in">minimum</span>(closedge);        <span class="comment">//离当前生成树距离最短的点作为下一顶点</span></span><br><span class="line">  <span class="built_in">printf</span>(closedge[k].adjvex, G.vexs[k]);    <span class="comment">//输出生成树的边</span></span><br><span class="line">  closedge[k].lowcost = <span class="number">0</span>;    <span class="comment">//将该点并入生成树U集</span></span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; ++j) <span class="comment">//更新未并入U的点离生成树的距离。</span></span><br><span class="line">      <span class="keyword">if</span>(G.arcs[k][j].adj &lt; closedge[j].lowcost)    </span><br><span class="line">          closedge[j] = &#123;G.vexs[k], G.arcs[k][j].adj&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每一步的状态表（重要）</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1379805/1632216066656-3768a3d0-a6bb-4826-aca9-2077804df767.jpeg" alt="1A18DDB3-14CA-433F-8F92-A97B744CB996.jpeg"></p>
<ol start="2">
<li>Kruskal算法：适合边稀疏而顶点较多的图<ol>
<li>算法思想：初始时为只有n个顶点而无边的非连通图T={V, {} }，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃此边而选取下一条权值最小的边。以此类推，直至T中所有顶点都在一个连通分量上。</li>
</ol>
</li>
</ol>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><ol>
<li><p>Dijkstra算法，求单个点到其他点的最短路径。</p>
<ol>
<li><p>所需辅助数组</p>
<ol>
<li>dist[]：记录从源点到其他各顶点当前的最短路径长度，如两个点未直接相连置为∞</li>
<li>path[]：表示从源点到顶点i之间最短路径上i之前的一个结点。用于最后追溯最短路径。</li>
</ol>
</li>
<li><p>算法过程：贪心策略，按长度递增的次序产生各最短路径。</p>
<ol>
<li><p>初始化dist，和集合S={0}</p>
</li>
<li><p>从顶点集合V-S中选出dist最小的点 j ，并入S</p>
</li>
<li><p>更新dist[k] = dist[j] + arcs[j][k] &lt; dsit[k] ? dist[j]+arcs[j][k] : dsit[k]</p>
</li>
<li><p>重复2-3步，直到所有点都并入S</p>
</li>
</ol>
</li>
<li><p>求解过程表（重要）</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111632152.jpeg" alt="850BE2D4-C874-45CF-B587-1C2E74312442.jpeg"></p>
<ol start="2">
<li>Floyd算法，求所有点间的最短距离。<ol>
<li><p>算法思想：用每个顶点作为中间结点计算路径长度并与原路径长度进行比较，更新矩阵为较小的值。重复n次就得到所有的最短路径长度。</p>
</li>
<li><p>算法伪代码（不重要）要会算每次迭代的矩阵，初始的矩阵为邻接矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLOYD</span><span class="params">(Mgraph G, DistancMatrix D)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(u = <span class="number">0</span>; u &lt; G.vexnum; ++u)</span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">      <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">          <span class="keyword">if</span>(D[v][u] + D[u][w] &lt; D[v][w]) &#123; <span class="comment">//从v经过u到w的一条路径更短。</span></span><br><span class="line">              D[v][w] = D[v][u] + D[u][w];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ol start="3">
<li>直接插入排序</li>
</ol>
<p>思想：假设前部分序列已经有序，从后部分无序序列中选择元素插入到前面有序序列的合适位置，最终整体有序。是稳定的排序方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A[0] 用作哨兵, n为数组长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)        <span class="comment">// 依次将A[2]-A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>]) &#123;        <span class="comment">//若A[i]&lt;A[i-1]</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];        <span class="comment">//把A[i]复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)    <span class="comment">//在前端有序队列中查找插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];    <span class="comment">//将前面有序序列的元素后移，空出位置。</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];        <span class="comment">//插入到空出来的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>折半插入排序</li>
</ol>
<p>思想：将直接插入排序中移位操作中的比较单独提出来。变成，折半查找出元素的待插入位置，然后再移动元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        low = <span class="number">1</span>; high = i - <span class="number">1</span>;    <span class="comment">//设置折半查找范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;    <span class="comment">//折半查找</span></span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>];    <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>希尔排序</li>
</ol>
<p>思想（重要）：先将待排序表分割成若干由相隔某个增量的记录组成的一个子表，对各个子表分别进行直接插入排序，当整个表中元素已经基本有序时，再对全体记录进行一次直接插入排序。<br />不稳定的排序方法。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ol start="4">
<li>冒泡排序</li>
</ol>
<p>思想：从后往前两两比较相邻元素的值，若为逆序，则交换他们，直到序列比较完。若第n趟结束时没有交换，则冒泡排序结束。是一种稳定的排序方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt; i; j--)     <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>], A[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;    <span class="comment">//本趟遍历后没有发生交换，已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>快速排序（重要）</li>
</ol>
<p>思想：基于分治思想。通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，再分别对这两部分记录继续进行快速排序。 不稳定的排序方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一趟快速排序的过程，划分算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(ElemTYpe A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    pivot = A[low];            <span class="comment">//用子表的第一个记录作枢轴记录，用pivot记录枢轴关键字</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;        <span class="comment">//从表两边交替地向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;</span><br><span class="line">        A[low] = A[high];    <span class="comment">//将比枢轴小的记录移到低端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;</span><br><span class="line">        A[high] = A[low];    <span class="comment">//比枢轴大的记录移到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;            <span class="comment">//枢轴记录到位</span></span><br><span class="line">    <span class="keyword">return</span> low;                <span class="comment">//返回枢轴位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归主程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">Partition</span>(A, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol start="6">
<li>简单选择排序</li>
</ol>
<p>思想：第i趟排序从L[i···n]中选择关键字最小的元素与L(i)交换。经过n-1次就得到有序。不稳定的排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; n; ++j) </span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) min = j;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>堆排序</li>
</ol>
<p>堆：是一颗完全二叉树，所有根结点小于等于或大于等于其孩子节点值。为方便运算，A[0]为空。<br />思想：若在输出堆顶的最小值后，使得剩余n-1个元素的序列重又建成一个堆，则输出n个元素的次小值。如此反复执行，便得到一个有序序列，这个过程称为堆排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立大根堆的算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)    <span class="comment">//从非叶子结点开始调整</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整以元素k为根的子树为堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                        <span class="comment">//A[0]暂存子树的根结点。</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;    <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">            i++;                        <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;            <span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;                            </span><br><span class="line">            A[k] = A[i];                <span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k = i;                        <span class="comment">//修改k，继续向下筛选。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];                        <span class="comment">//被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A, len);</span><br><span class="line">    <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol start="8">
<li>归并排序</li>
</ol>
<p>思想：将两个或两个以上的有序表组合成一个新的有序表。稳定的排序方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ElemType *B = (ElemTYpe *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; k++) </span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid+<span class="number">1</span>; k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j])</span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span> A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">while</span>(i &lt;= mid) A[k++] = B[i++];    <span class="comment">//如果表1未检测完，直接复制</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) A[k++] = B[j++];    <span class="comment">//如果表2未检测完，直接复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>基数排序</li>
</ol>
<p>思想：一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。<br />链式基数排序：收集时是从下往上收集的。<br /><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111633646.jpeg" alt="AFA561CF-09F2-4A79-823D-B99981F78B38.jpeg"></p>
<h2 id="真题中的多次考到的算法"><a href="#真题中的多次考到的算法" class="headerlink" title="真题中的多次考到的算法"></a>真题中的多次考到的算法</h2><h3 id="树的孩子兄弟表示法的遍历"><a href="#树的孩子兄弟表示法的遍历" class="headerlink" title="树的孩子兄弟表示法的遍历"></a>树的孩子兄弟表示法的遍历</h3><p>以求家族中共有多少代并输出最后一代的所有成员为例。<br />思想：根据孩子兄弟表示法，创建结构体，包括名字，第一个孩子节点和兄弟节点。再将此结构体与其结点高度组成一个新结构体（在不同类型的题目中，该结构体内容根据需要进行修改）。通过求层次遍历最后一个结点的高度得到共有多少代，再通过遍历所有结点找到高度最大的结点，即最后一代。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *firstchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *brother;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> lno; <span class="comment">//表示结点高度;</span></span><br><span class="line">    BTNode *p;</span><br><span class="line">&#125;NodeInfo;         <span class="comment">//这个结构体及后续队列的变形应用是精髓。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FamilyTree</span><span class="params">(BTNode &amp;b)</span> </span>&#123;</span><br><span class="line">    NodeInfo Q[maxsize];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>; <span class="comment">//初始化自定义队列</span></span><br><span class="line">    <span class="type">int</span> Lno;        <span class="comment">//暂存结点高度；</span></span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;    <span class="comment">//j记录最后一代人数</span></span><br><span class="line">    BTNode *q;</span><br><span class="line">    ++rear;</span><br><span class="line">    Q[rear].p = b; Q[rear].lno=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (rear != front) &#123;</span><br><span class="line">        ++front;</span><br><span class="line">        q = Q[front].p; Lno = Q[front].lno;    <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;brother != null) &#123;</span><br><span class="line">            ++rear;</span><br><span class="line">            Q[rear].p = q-&gt;brother;</span><br><span class="line">            Q[rear].lno = Lno;        <span class="comment">//兄弟结点与该结点高度一致；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;firstchild != null) &#123;</span><br><span class="line">            ++rear;</span><br><span class="line">            Q[rear].p = q-&gt;firstchild;</span><br><span class="line">            Q[rear].lno = Lno + <span class="number">1</span>;    <span class="comment">//孩子结点比当前结点高1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(Lno); <span class="comment">//输出共有多少代</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= rear; i++) &#123;    <span class="comment">//输出最后一代成员并计算人数</span></span><br><span class="line">        <span class="keyword">if</span>(Q[i].lno == Lno) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="built_in">print</span>(Q[i].p-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>829专业课</tag>
      </tags>
  </entry>
  <entry>
    <title>机载软件设计技术思维和技术基础</title>
    <url>/2022/07/18/%E6%9C%BA%E8%BD%BD%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4%E5%92%8C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="机载软件设计技术思维和技术基础"><a href="#机载软件设计技术思维和技术基础" class="headerlink" title="机载软件设计技术思维和技术基础"></a>机载软件设计技术思维和技术基础</h1><h2 id="机载软件设计技术的思想（计算的原理）"><a href="#机载软件设计技术的思想（计算的原理）" class="headerlink" title="机载软件设计技术的思想（计算的原理）"></a>机载软件设计技术的思想（计算的原理）</h2><h3 id="计算与计算机器"><a href="#计算与计算机器" class="headerlink" title="计算与计算机器"></a>计算与计算机器</h3><ol>
<li>机载软件设计技术核心要求</li>
</ol>
<p>    机载软件核心：高可靠，高安全<br>    设计技术核心：建模、分析、验证</p>
<ol start="2">
<li>什么是计算？</li>
</ol>
<p>    个人回答：根据输入从开始状态经过有限步的状态转换，并对这个输入进行修改最终到达结束状态或停机状态得到输出的这个过程。并且这个过程无二义性。</p>
<p>    图灵眼中的计算：就是一个读写头在一条纸带上按照一个状态转移图进行操作的过程。</p>
<p>    1:  计算通过在一条被划分成方格的纸带上写下符号来进行<br>    2: 执行计算的人在每一步都只注意其中一个方格的符号<br>    3: 她的下一步仅仅取决与这个符号 和 她的头脑中的状态<br>    4: 她的下一下将做:<br>       她在当前注意的方格里写下一个符号,<br>       然后 把注意力转向它的左边或者右边的相邻方格</p>
<ol start="3">
<li>以运算器为中心的冯诺依曼计算机</li>
</ol>
<h3 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a>计算思维</h3><ol>
<li><p>定义</p>
<p>计算思维是运用计算机科学的基础概念进行问题求解、系统设计、以及人类行为理解等涵盖计算机科学之广度的一系列思维活动。</p>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111228897.png" title="" alt="" data-align="left"></li>
</ol>
<h3 id="机载系统"><a href="#机载系统" class="headerlink" title="机载系统"></a>机载系统</h3><p>机载软件不能脱离系统。把机载软件当作复杂的系统来考量。</p>
<p><strong>机载软件系统属于复杂安全关键系统</strong></p>
<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111234989.png" alt="" width="533">

<p><strong>发展趋势</strong>：综合模块化，分布式体系化，可软件定义</p>
<p><strong>机载软件的重要性</strong>：</p>
<p>       1. 软件规模越来越大<br>          2. 软件比重越来越大<br>                    3. 软件复杂度越来越高<br>                       4. 软件问题越来越突出</p>
<h3 id="计算与系统工程"><a href="#计算与系统工程" class="headerlink" title="计算与系统工程"></a>计算与系统工程</h3><ol>
<li><p>系统与系统工程</p>
<ol>
<li>系统</li>
</ol>
<p>    我们把极其复杂的研制对象称为“系统”，即由相互作用和相互依赖的若干组成部分结合成的具有特定功能的有机整体，而且这个“系统”本身又是它所从属的一个更大系统的组成部分。</p>
<ol start="2">
<li>系统工程</li>
</ol>
<p>    “系统工程”是组织管理“系统”的规划、研究、设计、制造、试验和使用的科学方法，是一种对所有“系统”都具有普遍意义的科学方法。</p>
<ol start="3">
<li>强有力的工具<br>系统工程不仅需要科学理论工具，而且需要强有力的运算手段——电子数字计算机</li>
</ol>
</li>
<li><p>基于模型的系统工程（MBSE:model-based systems engineering method）</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111234529.png"></p>
<p><strong>研发思路</strong></p>
<ol>
<li><p>基于MBSE的基本V型模型</p>
</li>
<li><p>通过<strong>数字模型</strong>对系统进行描述，实现方案的<strong>早期动态仿真</strong></p>
</li>
<li><p>实现以模型为核心的研发<strong>模型数据中心</strong>建立研发数据的关联</p>
</li>
<li><p>实现<strong>继承性设计</strong>，设计数据通过模型方式传递，可自动生成设计文档</p>
</li>
<li><p>实现<strong>可追溯性验证</strong>，验证数据来自上游设计结果，验证结果可以自动反馈到设计需求，可自动生成验证文档</p>
</li>
<li><p>建立具备支撑上述过程的<strong>工具链</strong>体系</p>
</li>
</ol>
</li>
</ol>
<h3 id="软件设计的工程化"><a href="#软件设计的工程化" class="headerlink" title="软件设计的工程化"></a>软件设计的工程化</h3><p>SysML是对UML的一个扩展。</p>
<p>软件的过程管理与控制： CMM / CMMI</p>
<h2 id="需求建模（思想、标准、建模）"><a href="#需求建模（思想、标准、建模）" class="headerlink" title="需求建模（思想、标准、建模）"></a>需求建模（思想、标准、建模）</h2><h3 id="机载软件的适航标准（DO-178B-C）"><a href="#机载软件的适航标准（DO-178B-C）" class="headerlink" title="机载软件的适航标准（DO-178B/C）"></a>机载软件的适航标准（DO-178B/C）</h3><p><strong>适航</strong></p>
<ul>
<li><p>航空器能在<strong>预期的环境</strong>中<strong>安全飞行</strong>（起飞和着陆）的<strong>固有品质</strong>，这种品质可以通过<strong>合适的</strong>维修而继续保持。</p>
</li>
<li><p>要考虑： 飞机的运行环境、正常操作下的安全、使用寿命内的安全性，符合标准的维修。</p>
</li>
<li><p>如何确定民机的安全标准：安全水平应等同于人的自然意外死亡率。</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111234622.png" title="" alt="" width="623">

<p>DO-178B是”机载系统和设备合格审定中对软件的考虑”，是做什么而不是怎么做。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111234767.png"></p>
<h3 id="DO-178C"><a href="#DO-178C" class="headerlink" title="DO-178C"></a>DO-178C</h3><p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235958.png"></p>
<p><strong>目的</strong>：为机载软件的研制提供指南，保证其按照适航要求的安全性实现其预期功能</p>
<p><strong>内容</strong>：各软件生命周期过程中所要达到的目标；<br>            为达到目标实施的工作和设计考虑；<br>            表明目标已满足的以软件生命周期数据的形式描述的证据；<br>            因等级不同，在目标（objectives）、独立性（independence,）、数据（software life cycle data）、构型控制（control categories）上的不同；<br>            各项特殊考虑（PDS（previously developed software）等）；<br>            定义和术语</p>
<p><strong>66个目标</strong>：</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235925.png"></p>
<p><strong>6个过程</strong>：</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235829.png"></p>
<p><strong>20个资料</strong>：</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235158.png"></p>
<h4 id="与软件开发相关的系统方面"><a href="#与软件开发相关的系统方面" class="headerlink" title="与软件开发相关的系统方面"></a>与软件开发相关的系统方面</h4><h5 id="分配给软件的系统需求"><a href="#分配给软件的系统需求" class="headerlink" title="分配给软件的系统需求"></a>分配给软件的系统需求</h5><p>包括与安全相关的需求，被开发并细化为软件需求，通过软件验证过程活动验证并验证。</p>
<ul>
<li><p>功能和操作方面的要求。</p>
</li>
<li><p>接口要求。</p>
</li>
<li><p>性能要求。</p>
</li>
<li><p>系统安全目标。</p>
</li>
<li><p>与安全相关的要求，包括安全策略、设计约束和设计方法，如分区、差异、冗余或安全监控。如果系统是另一个系统的组成部分，则该其他系统的需求和故障条件也可以构成分配给软件的系统需求的一部分。</p>
</li>
<li><p>安全要求。</p>
</li>
<li><p>维护要求。</p>
</li>
<li><p>认证要求，包括任何适用的认证机构规定、签发文件等</p>
</li>
<li><p>辅助系统生命周期过程所需的额外要求。</p>
</li>
</ul>
<h5 id="系统和软件生命周期过程之间的信息流"><a href="#系统和软件生命周期过程之间的信息流" class="headerlink" title="系统和软件生命周期过程之间的信息流"></a>系统和软件生命周期过程之间的信息流</h5><p>包括：从系统流程到软件流程的信息流、从软件流程到系统流程的信息流以及软件与硬件之间的信息流。</p>
<p>软件生命周期过程分析确定的系统需求不充分或不正确可能会影响系统安全评估和系统需求细节和修改</p>
<h5 id="系统安全评估流程和软件级别"><a href="#系统安全评估流程和软件级别" class="headerlink" title="系统安全评估流程和软件级别"></a>系统安全评估流程和软件级别</h5><p>软件错误可能是潜在的，因此，不会立即产生故障。导致从软件错误到故障状态的事件序列可能很复杂，并且不容易用一系列事件来表示。</p>
<h6 id="故障状态分类"><a href="#故障状态分类" class="headerlink" title="故障状态分类"></a>故障状态分类</h6><ol>
<li><p>灾难级（Catastrophic）：会导致多人死亡，通常是由于飞机的失事。</p>
</li>
<li><p>危险级（Hazardous）：会降低飞机能力或机组人员应对不利操作条件的能力。（大幅降低、会造成严重或致命伤害）</p>
</li>
<li><p>严重级（Major）：会降低飞机能力或机组人员应对不利操作条件的能力。（显著降低、可能受伤）</p>
</li>
<li><p>轻微级（Minor）：不会显著降低飞机安全的故障条件及机组人员在其能力范围内的行动。（轻微、不适）</p>
</li>
<li><p>无影响级（No Effect）：对安全没有影响。</p>
</li>
</ol>
<h6 id="软件等级"><a href="#软件等级" class="headerlink" title="软件等级"></a>软件等级</h6><p>用后续软件开发的生命周期数据来验证应用程序具有更高的软件级别可能是困难的。</p>
<p>如果一个软件组件的异常导致了多个故障条件以最严重的评级</p>
<p>对于由操作规程规定的，但不影响飞机的适航性的机载系统和设备。在某些情况下，软件级别可以在设备的最低性能标准中指定。</p>
<ol>
<li><p>Level A：系统安全评估过程中显示的异常会导致或加剧系统功能故障并导致飞机出现灾难级故障。</p>
</li>
<li><p>Level B：系统安全评估过程中显示的异常会导致或加剧系统功能故障并导致飞机出现灾难级故障。</p>
</li>
<li><p>Level C：系统安全评估过程中显示的异常会导致或加剧系统功能故障并导致飞机出现严重级故障。</p>
</li>
<li><p>Level D：系统安全评估过程中显示的异常会导致或加剧系统功能故障并导致飞机出现轻微级故障。</p>
</li>
<li><p>Level E：系统安全评估过程所显示的异常将导致或加剧系统功能故障，而不影响飞机操作能力或飞行员工作量。</p>
</li>
</ol>
<h4 id="软件规划过程"><a href="#软件规划过程" class="headerlink" title="软件规划过程"></a>软件规划过程</h4><p><strong>目标</strong>：定义生产能够满足系统需求的软件的方法，并提供与软件水平相一致的置信度水平。</p>
<h4 id="软件开发过程"><a href="#软件开发过程" class="headerlink" title="软件开发过程"></a>软件开发过程</h4><p>软件开发过程要保证可追溯性。</p>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235194.png" style="zoom:50%;" />

<ol>
<li><strong>软件需求过程</strong></li>
</ol>
<p>通过对系统需求和系统架构的分析，直接产生<strong>高级需求</strong>。通常，这些高级需求会在软件设计过程中得到进一步的开发，从而产生一个或多个连续的、较低级别的需求。但是，如果源代码是直接从高级需求生成的，那么高级需求也被认为是低级需求。<strong>低级需求</strong>是指软件需求，其中源代码可以直接实现，而不需要进一步的信息。</p>
<ol start="2">
<li><strong>软件设计过程</strong></li>
</ol>
<p>高级需求通过软件设计过程中的一个或多次迭代进行改进，以开发软件体系结构和可用于实现源代码的低级需求。</p>
<ol start="3">
<li><strong>软件编码过程</strong></li>
</ol>
<p>在软件编码过程中，源代码是从软件架构和低级需求中实现的。</p>
<p>开发的源代码是可追踪的、可验证的、一致的，并正确地实现了低级需求。</p>
<ol start="4">
<li><strong>软件集成过程</strong></li>
</ol>
<p>将软件编码过程中的目标计算机、源代码和目标代码与链接和加载数据一起使用，以开发集成的系统或设备。</p>
<p>可执行对象代码将被加载到目标硬件中，以进行硬件/软件集成。</p>
<h4 id="软件验证过程"><a href="#软件验证过程" class="headerlink" title="软件验证过程"></a>软件验证过程</h4><p>软件验证过程按照软件规划过程和软件验证计划的定义对输出进行的技术评估。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235306.png"></p>
<h2 id="系统设计建模-（Enterprise-Architect软件）"><a href="#系统设计建模-（Enterprise-Architect软件）" class="headerlink" title="系统设计建模 （Enterprise Architect软件）"></a>系统设计建模 （Enterprise Architect软件）</h2><h3 id="SysML（System-Modeling-Language）复杂系统的建模语言"><a href="#SysML（System-Modeling-Language）复杂系统的建模语言" class="headerlink" title="SysML（System Modeling Language）复杂系统的建模语言"></a>SysML（System Modeling Language）复杂系统的建模语言</h3><p>SysML 是一种表述（Specifying）、分析、设计以及验证复杂系统的通用图形化建模语言；复杂系统可能包括软件、硬件、信息、人员、过程和设备等其他系统元素。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235689.png"></p>
<p><strong>静态视图</strong>：定义结构化的元素 (模块) 和他们之间的关系</p>
<p><strong>动态视图</strong>：定义系统范围• 组织需求到用例中    (“内容表”)</p>
<p>SysML通用结构（<strong>外框</strong>、<strong>内容框</strong>、<strong>头部</strong>）</p>
<p><strong>头部</strong>包含（图的类型：图的缩写即表示图的类型；模型元素类型：图所表示的模型元素是模型层级关系；模型元素名称：用户自定义；图的名称：用户自定义。）示例：<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235117.png"></p>
<h3 id="SysML中的结构模型（Structure）"><a href="#SysML中的结构模型（Structure）" class="headerlink" title="SysML中的结构模型（Structure）"></a>SysML中的结构模型（Structure）</h3><h4 id="模块定义图-（BDD：Block-Definition-Diagram）"><a href="#模块定义图-（BDD：Block-Definition-Diagram）" class="headerlink" title="模块定义图 （BDD：Block Definition Diagram）"></a>模块定义图 （BDD：Block Definition Diagram）</h4><p>类似UML中的<strong>类图</strong>，可以通过该图展示不同类型的模型元素和组合来说明<strong>系统结构的信息</strong>。</p>
<p>在模块定义图中显示的模型元素有：<strong>模块、执行者、值类型、约束模块、流说明、接口</strong>等。</p>
<p><strong>不同时期的作用</strong>：</p>
<ul>
<li><p>在系统分析阶段：模块定义图主要用于表达 角色和提供系统行为的实体的职责；</p>
</li>
<li><p>在系统设计阶段：模块图主要用于表达 组成系统体系结构的模块结构；</p>
</li>
<li><p>系统编码阶段：根据模块定义图中的模块及它们之间的关系实现系统的功能。</p>
</li>
</ul>
<p>模块可通过<strong>分割框</strong>划分不同属性。分割框属性分为：组成部分、参考、值、约束、操作、接收、标准端口、流端口、完整端口、代理端口、流属性等</p>
<p>模块<strong>结构属性</strong>：</p>
<ol>
<li><p>组成部分属性(parts)</p>
<p>模块的组成部分；组成部分属性代表模块的内部结构。表示一种从属关系。</p>
</li>
<li><p>引用属性（reference）</p>
<p>表示模块外部的一种结构。通常可以用于描述“需求的关系”。</p>
</li>
<li><p>值属性（value）</p>
<p>本质上就是表示一个模块中所包含的变量信息。</p>
<p><strong>原始值类型</strong>：String、Boolean、Integer和Real。</p>
<p><strong>结构值类型</strong>：拥有内部结构的值类型，以一个定义好的模块为类型的类型。</p>
<p><strong>枚举值类型</strong>：定义一系列数值。</p>
</li>
<li><p>约束属性（constraint）</p>
<p>一般代表一种数学关系。</p>
<p>此外约束属性可以作为一个**约束模块(constraint module)**：扩展了基本模块，其也是一种定义元素，它定义了一种布尔型的约束表达式。</p>
<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235560.png" alt="" width="430"></li>
<li><p>端口（port）</p>
<p>代表模块与外部环境进行交互的不同出入口的性质。又可分为流端口和标准端口。</p>
<ul>
<li><p>流端口（flow port）：为在边界交互点流入、流出模块的事件、能量或者数据建模。</p>
</li>
<li><p>标准端口：模块在边界交互点上提供或者请求的服务的模型。（类似于标准库函数调用）</p>
</li>
</ul>
</li>
</ol>
<h3 id="SysML中的行为模型（Behavior）"><a href="#SysML中的行为模型（Behavior）" class="headerlink" title="SysML中的行为模型（Behavior）"></a>SysML中的行为模型（Behavior）</h3><h4 id="SysML-BDD图中"><a href="#SysML-BDD图中" class="headerlink" title="SysML BDD图中"></a>SysML BDD图中</h4><p>SysML BDD图中提供了两种类型的行为特性：操作和接收。</p>
<ol>
<li>操作（operation）：表示客户端调用模块的时候它所执行的行为。操作由调用事件触发，操作代表的是一种同步行为。</li>
<li>接收（receive ）：当客户端发送信号(signal)来触发的时候，模块就会执行该行为。接收是由信号事件触发的，它是一种异步的行为。</li>
</ol>
<p><strong>执行者(actor)</strong>: 表示人、组织或者其他系统在与当前系统交互时所扮演的角色。</p>
<p><strong>注释</strong>：一种模型元素。它包含唯一的属性：一段文字。‘</p>
<p><strong>关系</strong>：</p>
<ul>
<li>模块之间关联关系<ul>
<li>引用关联：两个模块之间的引用关联意味着系统的模块实例可以存在一种彼此访问的连接。</li>
<li>组合关联关系：是一种特殊的关联关系：两个模块之间的组合关联表示<strong>结构上的分解</strong></li>
</ul>
</li>
<li>模块之间泛化关系：泛化是模块中的继承关系，子模块完全继承父模块的所有保护和公有的属性、操作等。</li>
<li>模块之间依赖关系：依赖表示当提供者元素发生改变时，客户端元素可能也需要改变。</li>
</ul>
<h4 id="系统内部模块图-IBD：Internal-Block-Diagram"><a href="#系统内部模块图-IBD：Internal-Block-Diagram" class="headerlink" title="系统内部模块图(IBD：Internal Block Diagram)"></a>系统内部模块图(IBD：Internal Block Diagram)</h4><p>是模块定义图（BDD）中模块内容的补充。组成部分属性和引用部分属性之间的连接；在连接之间流动的事件、能量和数据的类型；以通过连接提供和请求服务。</p>
<p>BDD：首先定义模块和它的属性；IBD：显示对某个模块的合法配置</p>
<h4 id="系统约束参数图（Par：Parametric-Diagrams）"><a href="#系统约束参数图（Par：Parametric-Diagrams）" class="headerlink" title="系统约束参数图（Par：Parametric Diagrams）"></a>系统约束参数图（Par：Parametric Diagrams）</h4><p>参数图用于说明系统的约束。参数图与BDD的关系，就类似于IBD与BDD的关系，是互补的视图。</p>
<h3 id="活动图（act：Activity-Diagrams）"><a href="#活动图（act：Activity-Diagrams）" class="headerlink" title="活动图（act：Activity Diagrams）"></a>活动图（act：Activity Diagrams）</h3><p>活动图可以表达复杂的控制逻辑，这要比序列图和状态图更强；且活动图是唯一能够说明连续系统行为的图；（动作执行顺序、动作执行结构、动作触发结构）</p>
<h4 id="Petri-Nets-Petri网"><a href="#Petri-Nets-Petri网" class="headerlink" title="Petri Nets  Petri网"></a>Petri Nets  Petri网</h4><p>**Place(库所)**：表示系统部件及其状态，如：一个磁盘驱动器，一个程序，某种资源等等；<br><strong>Transition（变迁）</strong>：表示能够改变系统状态的动作/事件；如：从磁盘读取数据动作，向磁盘写入数据，等等；<br><strong>Arc（有向弧）</strong>：表示Place和Transition之间的关系；<br><strong>Token（令牌）</strong>：表示了整个Petri Nets的状态。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111235862.png"></p>
<p><strong>形式化定义</strong>：</p>
<p>A Petri net as a five tuple, M= (P, T,I, O,MP)：<br>P represents a set of places, P = {P<sub>l</sub>, P<sub>2</sub>…. ,P<sub>n</sub>},<br>T represents a set of transitions, T= {t<sub>1</sub>, t<sub>2</sub>, … ,t<sub>m</sub>},<br>I represents a bag of sets of input functions for all transitions, I = {I<sub>(t1)</sub>,I<sub>t2</sub>. . . . . I<sub>tm</sub>}, mapping places to transitions;<br>O represents a bag of sets of output functions for all transitions, O = {O<sub>tl</sub>, O<sub>t2</sub>, … ,O<sub>tm</sub>},；<br>MP represents the marking of places with tokens. </p>
<p><strong>作用</strong>：系统中多个进程进行资源共享的行为建模。</p>
<h4 id="活动图与Petri网对应"><a href="#活动图与Petri网对应" class="headerlink" title="活动图与Petri网对应"></a>活动图与Petri网对应</h4><p>直角方框表示place；需要特殊强调的place用大直角框；一般的也可用小方框依附在Transition圆角框并在旁用文字标注。如图有三个place。</p>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236986.png" title="" alt="" width="508">

<p>圆角方框表示Transition</p>
<p>Token不直接在活动图中显示</p>
<h4 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h4><ol>
<li><p>动作节点：一个动作表示：某种类型的处理或者转换；</p>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236032.png" title="" alt="" width="248"></li>
<li><p>对象节点：出现在<strong>两个动作之间</strong>，以表示第一个动作会产生出对象令牌作为输出，第二个动作会将这些对象令牌作为输入。</p>
<ul>
<li><p>一般的对象节点：<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236319.png" alt="" width="327"></p>
</li>
<li><p>栓（Pin）：是一种特殊类型的对象节点。栓可以附加到动作上<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236169.png" alt="" width="306"></p>
</li>
<li><p>活动参数：附加在活动图的外框上，表示整个活动图的输入或输出。</p>
<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236051.png" title="" alt="" width="309"></li>
<li><p>流与非流：非流要等动作结束才能继续，流直接传递token。</p>
<p>流行为要在栓旁标注{Stream}<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236242.png" title="" alt="" width="243"></p>
</li>
</ul>
</li>
<li><p>边：</p>
<ul>
<li><p><strong>对象流</strong>是一种边，用于传输对象令牌（传数据？）</p>
</li>
<li><p><strong>控制流</strong> 常用虚线箭头来表示控制流，当对象流无法有效表示活动/动作的传递序列的时候，可以使用控制流来表示一系列动作的序列约束；（不传数据？）</p>
</li>
</ul>
</li>
<li><p>特殊的动作：</p>
<ul>
<li><p>调用行为动作：将一个高层次的行为分解成一系列低层次的行为。</p>
</li>
<li><p>发送信号动作、接受信号动作<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236150.png" alt="" width="316"></p>
</li>
<li><p>发送信号动作、接受事件动作</p>
</li>
<li><p>等待时间动作<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236295.png" title="" alt="" width="294"></p>
</li>
</ul>
</li>
<li><p>控制节点：引导活动沿着路径执行，可以指引活动中控制令牌的流，也可以指引活动中对象令牌的流。</p>
<ul>
<li><p>初始节点标记活动的起点 <img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236367.png" style="zoom:67%;" />：如果活动图有活动参数（在外框上的），可以不需要初始节点</p>
</li>
<li><p>活动最终节点 <img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236495.png" title="" alt="" width="50" style="zoom:67%;" >： 表示整个该活动图的流程结束</p>
</li>
<li><p>流最终节点<img title="" src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236720.png" alt="" width="50" style="zoom: 50%;" >：表示活动图中的该动作流结束。</p>
</li>
<li><p>判定节点、合并节点<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236408.png">：都用菱形表示，但是出入边数量不同，且判定节点输出边要有条件。</p>
</li>
<li><p>分支节点：拥有一条输入边和多条输出边。当一个令牌——可能是对象令牌，也可能是控制令牌——到达分支节点的时候，它会被复制到所有输出边上。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236891.png" title="" alt="" width="278"><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207111236627.png" title="" alt="" width="266"></p>
</li>
<li><p>汇聚（集合）节点：标记活动中并发序列的结束（同步点）。汇聚节点一般拥有两条或多条输入边，而只有一条输出边。</p>
</li>
</ul>
</li>
<li><p>活动分区：用泳道</p>
</li>
</ol>
<h3 id="状态机图-stm-state-machine-diagram"><a href="#状态机图-stm-state-machine-diagram" class="headerlink" title="状态机图 (stm: state machine diagram)"></a>状态机图 (stm: state machine diagram)</h3><p>通常用于模块的详细设计阶段，可以自动生成代码框架；</p>
<ol>
<li><p>初始状态和终止状态：</p>
<ul>
<li>一个状态只能有一个初态；复合状态中可以使用新的初态；</li>
<li>终态的数目可以不确定。</li>
</ul>
</li>
<li><p>简单状态：</p>
<ul>
<li>状态名（name）</li>
<li>进入/退出动作（entry/exit）：原子动作</li>
<li>执行动作（do）：非原子动作</li>
<li>内部转换（internal transition）：不导致状态改变的转换，不会执行 entry 和 exit 动作</li>
</ul>
</li>
<li><p>复合状态：（圆角方框表示；可选extry,exit和do行为；拥有内嵌的子状态）</p>
<p>复合状态可以从其边界跳出；也可以从其中的某个子状态直接跳出；</p>
</li>
<li><p>伪状态</p>
<p>引入伪状态的目的：在状态转换之间增加较为复杂的逻辑控制，伪状态用于更为简便的表示。不能在伪状态上停留</p>
</li>
</ol>
<h4 id="转换："><a href="#转换：" class="headerlink" title="转换："></a>转换：</h4><p>状态之间的变化联系：</p>
<ul>
<li>触发器（trigger）:某个事件，能够触发状态发生变化</li>
<li>守卫（guard）：布尔表达式，T/F</li>
<li>影响（effect）：转换过程中的执行行为（原子行为）</li>
</ul>
<p>转换中的事件：</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207141553115.png" alt="image-20220714155339020"></p>
<ol>
<li><p>信号事件(signal)：接受到别人发生的信号从而调用这个事件。如上图的commLinkLost</p>
</li>
<li><p>调用事件(call)：如上图的 acquireTarget( orderedAttitude :Attitude )</p>
</li>
<li><p>时间事件(time)：</p>
<p>相对时间事件：用关键词at 开头<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207141556027.png" alt="image-20220714155617002" style="zoom: 50%;" /></p>
<p>绝对时间事件：用关键词 after 开头<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207141556140.png" alt="image-20220714155620118" style="zoom:50%;" /></p>
</li>
<li><p>改变事件(change)：定义为一个布尔表达式。在系统执行过程中，每当某个特定的布尔表达式从假切换为真的时候，其对应的改变事件就会发生。（对比：不变式，断言）<code>when（。。。）/ 。。。</code></p>
</li>
</ol>
<p>特殊的转换-&gt;内部转换：是改变事件的直接应用，表示系统在某个状态内部的细节变化，但不会触发entry/exit行为。</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区的作用：与活动图中类似，用于表示并发的行为。</p>
<h3 id="系统建模之序列图（sd：-sequence-diagram）"><a href="#系统建模之序列图（sd：-sequence-diagram）" class="headerlink" title="系统建模之序列图（sd： sequence diagram）"></a>系统建模之序列图（sd： sequence diagram）</h3><p>目的：序列图的目的在于描述系统中各个模块实例按照时间顺序的<strong>交互</strong>过程。</p>
<p>在系统的详细设计阶段也常常会用到序列图，用于仿真和代码框架的自动生成。</p>
<h4 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h4><ol>
<li><p>生命线：表示参与交互场景的系统、模块、子系统等的实例；</p>
<ol>
<li>头部：矩形方框</li>
<li>虚线：时间线（从上至下，时间增长）</li>
</ol>
</li>
<li><p>消息</p>
<ol>
<li>异步：带开口箭头的实线</li>
<li>同步：带有实心箭头的实线，</li>
<li>回复：带有开口箭头的虚线，可在图中忽略不表示</li>
<li>创建：带开口箭头的虚线，指向一个对象实例。</li>
</ol>
<p>与消息有关的事件：</p>
<p>消息发送事件、消息接收事件、生命线创建事件、生命线销毁事件、行为执行开始事件、行为执行结束事件</p>
</li>
<li><p>增加语义</p>
<ul>
<li><p>时间约束：<img src="https://cdn.staticaly.com/gh/konsin/images@main/202207160933037.png" alt="image-20220716093350954" style="zoom:50%;" /></p>
</li>
<li><p>状态常量：可以用关联的状态机中的状态名来标示，</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207160937661.png" alt="image-20220716093709632"></p>
</li>
<li><p>逻辑操作：</p>
<ul>
<li>opt （条件 ， T/F）满足条件 就执行opt 框中的交互序列</li>
<li>alt  （多选一） alt框中有虚线（划分 true，else分支）；alt条件只能同时有且只有一个为真；</li>
<li>loop （循环） Loop(min,max);</li>
<li>par  （并行）表示多个场景的交互处于并发执行的语义；</li>
<li>ref操作</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="用例图（ud-usecase-digram）"><a href="#用例图（ud-usecase-digram）" class="headerlink" title="用例图（ud: usecase digram）"></a>用例图（ud: usecase digram）</h3><p>用例图是从用户角度描述系统功能，是用户所能观察到的系统功能的模型图。是系统的一种黑盒视图。</p>
<p>用例图需要配置用例说明书，对用例进行详尽描述。先用自然语言描述清楚，然后进行图形化/形式化建模、分析与验证</p>
<h4 id="用例图中事物及关系"><a href="#用例图中事物及关系" class="headerlink" title="用例图中事物及关系"></a>用例图中事物及关系</h4><ol>
<li><p>参与者（执行者）</p>
<p>是指存在于系统外部并直接与系统进行交互的实体。</p>
<p>参与者不仅可以由人承担，还可以是<strong>其他系统、硬件设备，甚至是时钟</strong>。</p>
</li>
<li><p>用例（系统功能）系统外部可见的一个<strong>系统功能单元</strong>。</p>
</li>
<li><p>系统边界：系统边界是指系统与环境之间的界限。用例图中的系统边界用来表示正在建模系统的边界，边界内表示系统的组成部分，边界外表示系统的外部。</p>
</li>
<li><p>用例图中的关系</p>
<ul>
<li>关联：参与者与用例之间的关系</li>
<li>包含和扩展：用例之间的关系<code>&quot;include&quot;</code> 、<code>&quot;extend&quot;</code></li>
<li>泛化：参与者之间的关系</li>
</ul>
</li>
</ol>
<h3 id="需求图-req-requirment-diagram"><a href="#需求图-req-requirment-diagram" class="headerlink" title="需求图(req: requirment diagram)"></a>需求图(req: requirment diagram)</h3><p>需求是用户解决问题或达到领域目标所需的系统功能；包括系统及子系统/模块等都要满足合同、标准，规范或其它正式规定文档所需具有的条件或能力。</p>
<p>需求分析的目的是确定系统应具备哪些功能。</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/202207161022575.png" alt="image-20220716102254532"></p>
<h2 id="机载系统-软件的需求建模与分析方法"><a href="#机载系统-软件的需求建模与分析方法" class="headerlink" title="机载系统/软件的需求建模与分析方法"></a>机载系统/软件的需求建模与分析方法</h2><h3 id="基于模型的系统工程（MBSE）与SCR方法"><a href="#基于模型的系统工程（MBSE）与SCR方法" class="headerlink" title="基于模型的系统工程（MBSE）与SCR方法"></a>基于模型的系统工程（MBSE）与SCR方法</h3><p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.7s1q75w13uw.jpg" alt="image"><br>什么是系统？系统就是<strong>交互</strong>的<strong>元素</strong>组织起来的组合，以实现一个或多个特定的<strong>目的</strong>。<br>概念：</p>
<ol>
<li>需求（requirements）：能满足用户期望的各种系统各种特征的集合</li>
<li>需求规约（requirement specification ）：用某种<strong>准确</strong>的描述方式将需求内容表达出来，使得能够进行有效的需求层级分析、验证等工作。（条目化-&gt;图形化-&gt;形式化）</li>
<li>需求模型(requirement model): 在MBSE框架下，需求规约就是需求模型<br>需求要满足：明确、正确、完整、一致、可追溯、可实现、可验证<br>一个好的需求模型（规约）应该是以某种方法学为基础来进行良好的<strong>设计</strong>来得到的</li>
</ol>
<p><strong>形式化方法</strong>（Formal Methods）：是在计算机系统（包括硬件和软件）的规约、设计和构造中使用逻辑和离散数学中的技术<br>    提供了一种计算手段，因而可以在一个数字系统的实现之前预测它的行为会是怎样。<br>    需要建立形式化模型；(建模语言)；形式化分析需要一个工具来实现，这需要对这个工具进行鉴定。（工具输入／输出）</p>
<p><strong>形式化方法带来的挑战</strong>：</p>
<ul>
<li>缺少形式化方法的培训导致不理解（培训学习和用户友好的工具）；</li>
<li>并非适用于所有问题（在最关键的地方使用）；</li>
<li>形式化方法和非形式化方法的混合会带来困难（作为需求定义和验证活动的一个子集，与传统的过程集成）；</li>
<li>形式化方法专家太少（培训＋工具）；</li>
<li>有较高资源的需求（在关键、复杂区域使用，成本效益高）</li>
<li>对形式化方法验证能力有过高的信心（建立正确的系统 v.s. 正确的建立系统）</li>
<li>对测试存在偏见（测试仍然是需要，特别是基于目标机的测试来验证硬／软件的集成）</li>
<li>工业和合格审定指南还没有标准化（DO-333是重要一步）</li>
<li>工具支持仍不完整（需要适用于软件生命周期＋领域工程师使用）</li>
</ul>
<h3 id="SCR方法概述"><a href="#SCR方法概述" class="headerlink" title="SCR方法概述"></a>SCR方法概述</h3><p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4hvicy6rr6w0.jpg" alt="image"></p>
<p>Software Cost Reduction（SCR）目的是评价软件工程技术在实际工程应用中的有效性和可扩展性。<br><strong>真正核心出发点是落在系统上</strong></p>
<p>A-7E OFP 需求文档中建立了<strong>三种SCR方法中主要方面</strong>：</p>
<ol>
<li>标识出所有的输出，并将每个输出表示为系统运行状态和环境变化的数学函数；</li>
<li>使用表格的形式来描述这些输出及关系；</li>
<li>建立了需求文档的评价准则</li>
</ol>
<p>为了准确定义所需要的系统行为，在A－7的需求文档中引入了“条件（condition）”、“事件（event）”、“模式/模式类（mode/mode class）”以及“项/宏（term）”等基本概念。</p>
<ul>
<li>条件: 定义在单个系统状态上的约束;（如变量取值）</li>
<li>事件: 定义在系统状态发生变化时所触发的约束；</li>
<li>模式／模式类：系统总是运行在某些<strong>特定工作状态</strong>下；（大概就是不同的功能方面的划分？）</li>
<li>项（宏）：表示中间辅助说明变量。</li>
</ul>
<p>需求文档需要满足的<strong>基本准则</strong>： 完整性；与系统如何实现无关；内容组织合理（如同编撰良好的参考手册）；</p>
<p><strong>SCR利用表格定义函数</strong><br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.6yp12yorff40.jpg" alt="image"><br>表格符号的优点：相比于逻辑符号，错误发生较少(表的结构消除了逻辑符号容易产生的错误); 比其他符号简单.</p>
<h3 id="基于SCR方法的需求建模"><a href="#基于SCR方法的需求建模" class="headerlink" title="基于SCR方法的需求建模"></a>基于SCR方法的需求建模</h3><p><strong>四变量模型(FVM, Four Variable Model)</strong></p>
<ul>
<li>需求的说明包含以下两步：<ul>
<li>理想的系统行为（即系统的正常行为）</li>
<li>真实的系统行为</li>
</ul>
</li>
<li>系统行为通常根据其所处环境量表示</li>
</ul>
<p>四变量：</p>
<ol>
<li>监视变量(Monitored Variables)：系统监视的环境量(如：温度，压力，高度)</li>
<li>受控变量(Controlled Variables): 受系统控制的环境量（如：显示器  的显示——数值、文本、图形，作动器的阈值）</li>
<li>输入(Inputs): 该变量来自于监视变量的估量</li>
<li>输出(Outputs): 该变量对受控变量产生影响</li>
</ol>
<p>为了定义理想的系统行为，需求规范必须</p>
<ul>
<li>从环境中识别和指明受控变量</li>
<li>从环境中识别和指明监视变量</li>
<li>指明监视变量和受控变量之间的关系</li>
</ul>
<p>为了指明真实的系统行为</p>
<ul>
<li>在理想系统中使系统简化的假设需要移除</li>
<li>输入和输出变量的值能够从输入和输出设备中读出</li>
</ul>
<p>监视变量与受控变量之间的关系对应着系统需求，输入变量和输出变量之间的关系对应着软件需求。<br>在监视变量和受控变量上的两种关系</p>
<ul>
<li>NAT: 环境约束（如：物理规律，系统所处环境的一些自然约束） </li>
<li>REQ: 为了实现系统的要求，所添加的系统约束</li>
</ul>
<p>另外两种关系</p>
<ul>
<li>IN: 监视变量和输入变量之间的关系</li>
<li>OUT: 输出变量和受控变量之间的关系 </li>
</ul>
<h2 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>软件工程导论复习</title>
    <url>/2019/12/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>【软件工程导论】</strong></p>
<p>软件 = 知识+程序+数据+文档</p>
<p><strong>文档的概念和作用</strong>文档记录软件开发的活动和中间制品，记录软件的配置及变更，用于软件专业人员和用户的交流，用于软件开发、过程管理和运行阶段的维护。<strong>如</strong>:需求报告对所开发软 件的功能、性能、用户界面及运行环境等作出详细的说明，它是用户与开发人员双方 对软件需求取得共同理解基础上达成的协议，也是实施开发工作的基础。设计说明书 是概要设计阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入 输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计奠定基 础。详细设计说明书着重描述每一模块是怎样实现的，包括实现算法、逻辑流程等</p>
<p><strong>软件特点：</strong>逻辑实体、智力产品;制造即拷贝;无磨损和老化,不遵循“浴盆曲线”,但 存在退化问题。尚未摆脱手工方式;软件移植的需要;复杂（问题复杂性 / 程序结构复 杂性）软件开发的性质如成本、进度、质量等难以估计控制,维护困难，有可复用性</p>
<p><strong>定义</strong>:将系统的、规范的、可量化的方法应用于软件的开发、运行和维护的过程及上述方法的研究</p>
<p><strong>三要素：过程</strong>:管理部分;<strong>方法</strong>:完成软件工程项目的技术手段;<strong>工具</strong>自动或 半自动地支持软件的开发、维护和管理。 </p>
<p><strong>目标：</strong>在给定成本、进度的前提下，开发出满足用户或市场需要的高质量的软件产品</p>
<p><strong>原则：</strong>抽象(自顶向下逐步求精)、信息隐藏（封装的接口）、模块化（相对独立/类）、局部化（相互关联/局部变量）、一致性（接口和规范）、完全性和可验证性(应易于检查、测试和评审)</p>
<p>**传统软件生命周期:**需求,设计,编码、测试,软件测试,运行、维护,退役</p>
<p><strong>瀑布模型生命周期</strong>:1 可行性研究,2 需求分析,3 概要设计,4 详细设计,5 实现,6 集成测试,7 确认 测试,8 使用与维护,9 退役(软件定义:1-2 软件开发 3-7 维护 8-9)</p>
<p><strong>各种模型的含义、优缺点、场景:</strong> </p>
<p>**瀑布模型:**假设软件需求在初期几乎可完全确定;<strong>主要思想</strong>:1.软件开发过程与软件生 命周期是一致的;2.相邻二阶段之间存在因果关系 3.每一阶段的结束点作为里程碑;4. 需对阶段性产品进行评审，如果评审不合格,需返工;<strong>优点</strong>:**1.**使用时间最长,应用面比较广泛;<strong>2.<strong>是其他一些开发模型的基础;3.思路简洁,明确,阶段间因果明确,紧密联系;4. 其可行性研究、需求、设计、编码、测试分离,有利于软件的体系结构设计,规范了软 件开发活动,有利于开发人员的组织管理;5.缓解软件危机</strong>缺点</strong>:1.必须确定软件需求后 才能进行后续开发工作,但多数场合给出全部需求是困难的;**2.<strong>到最后阶段才能得到可运行的软件版本不能适应用户需求的变 化 ;3.上游阶段的“过失”会为软件制品带 来“缺陷”并潜伏在制品中,会误导下游的开发活动,若未被发现运行时会造成“故障” , 寻找修复故障会比较困难</strong>场景:**对于规模较小、软件需求比较稳定的项目或子系统,能够显著提高软件开发的质量和效率;<strong>原型模型</strong>:**概念:**软件开发人员根据客户提出的软件(部分或全部)定义,快速地开发一个原型。原型向客户展示了待开发软件系统的全部 或部分功能和性能,在征求客户对原型意见的过程中,进一步修改、完善、确认软件系 统的需求并达到一致的理解;**优点1.**支持需求的动态变化;**2.**有助于获取用户需求,便于用户对需求的理解;**3.**尽早发现软件中的错误;**缺点:<strong>不支持风险分析.<strong>适用场景：</strong>开发 团队对所开发领域比较熟悉而且有快速的原型开发工具</strong>螺旋模型: 基本思想:<strong>1.将瀑布模型与原型模型进行有机结合;2.增加风险分析步骤。</strong>优点:**1.支持需求的动态变化;2. 有助于获取用户需求,便于用户对需求的理解;3.尽早发现软件中的错误;4.支持风险分 析,可降低或者尽早消除软件开发风险;5.适合于需求动态变化、开发风险较大的系统; **缺点:**由于确定的不确定性,软件开发初期无法进行软件体系结构设计,多次迭代会导 致软件体系结构变坏,为软件理解和维护带来困难;<strong>场景:<strong>在需求不明确的情况下,适合用螺旋模型进行开发,便于风险控制和需求变更;特别适合于大型复杂的系统.<strong>原型模型和螺旋模型既是迭代模型,又是进化模型。</strong> <strong>喷泉模型:基本思想</strong>:1.软件复用与生命周期中多项开发活动集成2.主要支持面向对象的开发方法;<strong>优点</strong> 1软件系统可维护性较好 2各阶段相互重叠,表明了面向对象开发方法各阶段间的交叉和无缝过渡 3整个模型是一个迭代的过程,包括一个阶段内部的迭代和跨阶段的迭代 4模型具有增量开发特性,即能做到“</strong>分析一点,设计一点,实现一点,测试一点</strong>”,使相关功能随之加入到演化的系统中 5模型由对象驱动,对象是各阶段活动的主体,也是项目管理的基本内容 6该模型很自然地支持软部件的重用。</p>
<p><strong>工具： 项目管理工具</strong> AMSRealtime,MicrosoftProject,Viewpoint, Project ControlPanel ,Ittoolkit <strong>软件开发工具：业务系统建模工具：</strong>RationalRose,ArgoUML,Visio,Real-TimeStudo(以 上也可以是对应的<strong>分析和设计工具</strong>）<strong>测试工具：</strong>CodeMedic(为标准 UNIX 调试器 gdb 提供图形界面，支持 C/C++、Java、汇编、FORTRAN、Modua-2 测试) BugCollectorPro （实现多用户数据库，支持软件团队追踪已报告的 bug、管理调试工作 流） JprobeThreadAnalyzer（支持线程测试问题：死锁、延迟） C++Test（C／C++ 单元测试）**原型建造工具（专用性）用户界面工具:**Macromedia Authorware,PowerDesigner/PowerBuilder,MotifCommonDesktopEnvironment </p>
<p><strong>【第 2 章 UML 与 RUP 统一过程】</strong>(用例图(UC图),类图)</p>
<p><strong>面向对象的软件开发方法</strong> 面向对象的软件开发方法通过提供对象,对象间消息传递等语言机制让分析人员在解空间中直接模拟问题空间中的对象及其行为,从而削减了<strong>语义断层</strong>,拉近了问题空间与解空间的距离,从而简化了软件工程师在二者之间架设“桥梁”的工作,并为软件 开发活动提供了直观,自然的语言支持和方法学指导。</p>
<p><strong>面向对象 = {对象+类+继承+聚合+多态+消息}</strong> 基本要素</p>
<p><strong>面向对象方法的优势</strong>:1.简化软件开发过程。面向对象方法不仅可以用来进行需求分析，还可以支持软件 的设计、实现和测试，构成了覆盖软件开发主要阶段的广谱软件开发方法学。 2.支持软件复用。在源代码级复用方面，面向对象方法通过继承机制和代理方法使得复用者不需要直接修改被复用的类；在设计级复用方面，近年来迅速发展的设计技术在软件界大显身手，贡献良多。 3.改善软件结构。面向对象方法通过对属性和操作的封装实现了软件工程倡导的信<strong>息隐藏原则</strong>。</p>
<p><strong>用例图</strong>:用例图，从外部用户的角度描述系统功能，并指出参与者. 1.<strong>关联</strong>：参与者—执行用例。2.**包含(**include):一个用例 A 使用了另外一个用例 B。 A- -&gt;B。边上 include。3.<strong>扩展</strong>(extend):A 扩展自 B。A- -&gt;B。边上 extend</p>
<p>**结构视图:**（不同层面,系统的静态结构): 包图(描述系统的分解结构,表示包与包之间的关系);对象图(类图的一个实例,描述在某个状态下,或者某个时间段系统中活跃的对象及关系);<strong>类图</strong>(描述系统静态结构),<strong>①泛化与特化</strong>：表示类的继承关系。子类 父类。 <strong>②关联</strong>：类之间有关联（对象组合）A 类用到了 B 类的信息 A-&gt;B。一对多的时候，边 上：<code>1—*</code>。双向关联没有箭头，单向关联有箭头，我们一般用单向。 <strong>③聚合</strong>：强关联，整体与部分的关系。Engine Car。一对多：1-*。 <strong>④组合</strong>：强聚合，整体的对象负责代表部分的对象的生命周期。Limb MonkeyKing <strong>⑤依赖</strong>： ClassA的定义依赖于 ClassB的定义。例子： A 的构造函数的参数中有 ClassB。 A 中有个函数以 B 作为参数。A - -&gt;B。</p>
<p><strong>行为视图</strong>: (不同侧面系统的动态行为):交互图［描述对象之间通过消息传递进行的交互和协作,分为**顺序图(**对象之间消息发送的时间序), 通信图(对象间的动态协作关系,也可通过消息序号表示消息传递的时间序,不如顺序图直观)］, 状态图(描述类的对象的动态行为), <strong>活动图</strong>［控制流（一个操作完成后对其后续操 作的触发）、信息流（刻画操作间的信息交换）］</p>
<p><strong>构件视图</strong>：构件图(描述软件系统中各组成构件,构件的内部结构以及构件间依赖关系) </p>
<p><strong>部署视图</strong>：部署图（描述软件系统中各类工件在物理运行环境中的分布情况） </p>
<p><strong>【第六章 软件设计基本原则】</strong>(PDL伪代码格式)</p>
<p><strong>内聚度：偶然性内聚</strong>、逻辑性内聚、<strong>时间性内聚</strong>（经典内聚）/程度低/-&gt;过程性内聚,<strong>通信性内聚</strong>/程度中/-&gt;信息内聚,<strong>功能性内聚</strong>/程度高/</p>
<p><strong>耦合度</strong>:：1 非直接耦合-&gt;2 <strong>数据耦合</strong>与控制耦合-&gt;3 外部耦合-&gt;4 公共耦合-&gt;5 <strong>内容耦合</strong>。尽量使用 1/2，限制 3/4，杜绝 5。 </p>
<p><strong>选三种内聚度、三种耦合度各举一个例子说明。</strong></p>
<p><strong>功能内聚</strong>：一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割.(不建议举此例)<strong>信息内聚</strong>：完成多个功能各个功能都在同一数据结构上操作，每一项功能 有一个唯一的入口点。如课程管理系统上的查找课程、删除课程、修改课程都会使用 “课程”这个数据结构。<strong>通信内聚</strong>：一个模块各个功能部分都使用了相同的输入数据， 或产生了相同的输出数据。个人信息管理系统中：从文件中读取信息，打印功能和统计功能都会使用文件中的信息。<strong>逻辑内聚</strong>：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块的判定参数来确定该模块应执行哪一种功能。 <strong>非直接耦合</strong>：两个模块之间没有直接关系，它们之间的练习完全时通过主模块的控制 和调用来实现的。main()函数调用 A B C 函数，其中 A 用到 B 的返回值。<strong>控制耦合</strong>： 通过传送开关、标志、名字等控制信息，明显的控制选择另一模块的功能。如 A 的返 回值为 0 时调用 C，A 的返回值为 1 时调用 B。<strong>公共耦合</strong>：一组模块都访问同一个公 共数据环境。如 A\B 都调用以局部变量 time,并且会对其修改。 </p>
<p><strong>如何降低耦合度</strong>：根据问题的特点，选择适当的耦合类型；降低模块接口的复杂性(传送信息的数量,耦合方式,传送信息的结构)；把模块的通信信息放在缓冲区中; </p>
<p><strong>软件设计的原则</strong>：提高模块独立性；调整模块的大小；适当的模块深度、宽度、扇出 和扇入模块的作用范围应在控制范围之内简化模块的接口的复杂程度。 </p>
<p><strong>启发式设计策略</strong>：改造软件结构，降低耦合度，提高内聚度；减少扇出，追求高扇入； 使任一模块的作用域在其控制域内(<strong>作用域</strong>是指受模块内部判定影响的所有模块,控制域是指其所有的下属模块);降低模块接口复杂度和冗余度,提高协调性。 <strong>变换流</strong>：信息通常以“外部世界”所具有的形式进入系统，经过处理后，又以这种形式离开系统，呈现在结果界面上。<strong>事务流</strong>数据沿输入通道到达一个转换，该转换根据输入流的类型和特征在若干动作路径中选择一条来执行。</p>
<p>变换分析：复审基本系统模型；理解和精化数据流图；确定数据流图的类型；划分输入流、输出流的边界；执行二级分解；精化、改良软件结构。 </p>
<p><strong>【第八章、人机交互设计】</strong></p>
<p> 老人：图片字体大且清晰，描述简单，目录层级少，打开步骤少，操作简单，实用性 好，功能不复杂、只需要基本功能 小孩：色彩丰富。避免繁杂，大量图片和文字作为提示，风格轻松愉快，宽松简洁的 布局，高明度色彩，带拼音，可爱的卡通形象和字体设计，趣味和有故事性的背景</p>
<p><strong>用户界面设计的基本原则</strong>①易理解性；②易操作性；③灵敏性；④一致性；⑤容错 性；⑥人性化。</p>
<p><strong>用户界面设计模型的表示</strong>：①静态元素（无变化的文本、图标、图形、图像等）； ②动态元素（因运行状态而异自动呈现的不允许修改的文本、表格、图标、图形、图 像等）；③用户输入元素（可编辑文本、单选按钮、多选框、选择列表、可编辑的表 格）；④用户命令元素（按钮、菜单、超链接等）。 </p>
<p><strong>用户界面设计过程的主要活动:</strong> 1.<strong>用户分析、任务分析及建模</strong>。首先必须分析用户的特征，分析用户需要通过目标软件系统完成哪些工作任务，为完成这些任务人机之间需要进行哪些信息交互。2.<strong>概念设计</strong>。主要目标是确定屏幕中应该包含的主要内容，以及用户基于该屏幕可施行的主要操作。3.<strong>界面流设计</strong>。主要目标是确定屏幕之间的跳转关系，即一幅屏幕在何种情况下,或者在响应何种用户操作命令后将跳转至另一屏幕.两种原因：①单屏幕空间容量有限，不足以表现所有必要界面元素；②用户的界面操作可能导出新的屏幕，以便在新的屏幕上进行面向特定业务功能的界面交互。表示方式主要是 UML 交互图（顺序图）和类图。4.<strong>界面精化</strong>。主要任务是基于概念设计和界面流设计，给出目标软件产品界面的完整的、详细的设计。 </p>
<p><strong>【第九章、软件详细设计】</strong>主要活动①用例设计；②子系统设计；③构件设计；④类设计；⑤ 数据模型设计；⑥设计整合与验证。</p>
<p><strong>【第十章、软件实现】</strong></p>
<p><strong>程序设计语言的演化</strong>：第一代：汇编；第二代：Fortran/Cobol/Basic，有成熟的 函数库；第三代：结构化语言 C/Pascal/Ada；面向对象语言 C++/Java；专用领域语 言 Lisp/Prolog；第四代：数据库查询语言 Sql。</p>
<ol>
<li><p>第三代语言的特点：支持结构化程序设计，具有较强的过程能力和数据结构能力。</p>
</li>
<li><p>第四代特点：更高的抽象层次；只需要告诉计算机“做什么”，而不必告知“怎么做” 。 </p>
</li>
</ol>
<p><strong>编程的规则</strong>：1.节俭化（代码尽量简洁）；2.模块化；3.简单化（命名一致性，数 据结构尽量简单） 4.结构化（缩进统一/函数代替重复出现的代码/代码单入口单出口） 5.文档化（文档自说明）6.格式化</p>
<p><strong>编程风格:<strong>1.节俭化 2.模块化 3.简单化 4.结构化 5.文档化 6.格式化. 编程风格在很大程度上</strong>影响着程序</strong>的可读性、可测试性、可维护性。 <strong>结构化</strong>要做到按标准化的次序说明数据，按字母顺序说明对象名，使用容易理解的结 构化程序部件，根据背景排列程序各部分</p>
<p><strong>调试策略</strong>：1.原始法（单步执行，printf）2.回溯法（沿着代码控制流往回找）3. 排除法</p>
<p><strong>【第十一章】</strong>（设计题）</p>
<p><strong>数据流图DFD与数据字典、实体—关系图、面向数据流设计方法（事务流/变换流）</strong></p>
<p><strong>【第十三章、软件维护】</strong></p>
<p><strong>·维护的分类</strong>(按原因划分):1.纠错性维护。为诊断和改正软件系统中潜藏的缺陷而进行的活动.2.适应性维护.为适应软件运行环境变化(如操作系统变更等)而修改软件的活动.3.完善性维护.是根据用户在软件使用过程中提出的一些新需求而实施的维护活动.4.预防性维护。是优化软件系统结构和可理解性，改善可维护性和可靠性。</p>
<p><strong>·可维护性</strong>：软件的可维护性是指理解.改正.调整和改进软件的<strong>难易程度</strong>。是软件质量的重要属性，是指导软件工程活动的一条基本原则，也是软件工程追求的一个目标。 </p>
<p><strong>·影响可维护性的因素</strong>：开发方法有关：设计、编码和测试不规范，软件配置不全开发环境有关：①训练有素的软件团队；②维护团队是否熟悉经过多次维护的系统；③ 软件的可理解性，包括软件结构、描述软件制品的语言、文档及标准化程度等；④操作系统的标准化程度；⑤维护工具和环境；⑥生成测试用例的能力；⑦对于嵌入式系 统维护应有专门的调试工具。</p>
<p><strong>·维护的技术手段</strong>：软件重构。包括：文档重构、重组（简化与结构化源代码）、逆 向工程、再工程。</p>
<p><strong>【第十五章、软件度量与估算】</strong></p>
<p> <strong>·</strong>测量（Measure）是按照统一的规则为现实世界的实体属性定值。软件工程的测量 是按照测量标准直接、客观地采集软件制品、过程或资源的特征、属性，并获得数据。 例如：测量程序的代码行数、操作符的种类、个数，程序中缺陷的个数等等。测量涉 及测量对象、选用的量纲、方法、工具、过程和数据结果。</p>
<p> <strong>·</strong>软件估算（Estimation）是根据经验、历史资料或模型，结合项目实际对软件 制 品、过程、资源进行预测。估算一般用于签订合同、制定工作计划、进行项目预算等。 这里涉及软件过程工作量的估算。</p>
<p> <strong>·</strong>软件度量（Metrics）软件产品、软件开发过程或资源简单属性的定量描述，（如 程序规模、操作数个数、占用内存）能用以解释软件所具有的一个给定属性对软件质 量影响的程度。 </p>
<p><strong>软件度量：规模度量、复杂性度量（McCabe基于图论；Halstead基于操作符与操作数）、质量度量、可靠性度量</strong></p>
<p><strong>·内部属性与外部属性：软件工程的软件制品、过程、资源都具有外部属性和内部属性。外部属性体现了软件制品、过程、资源与环境的关系。内部属性指软件制品\过程和资源本身的技术属性。 二者关系:外部属性在软件开发过程中很难测量和控制，但它是由软件的内部属性决定的。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>软件制品</th>
<th>过程</th>
<th>资源</th>
</tr>
</thead>
<tbody><tr>
<td>内 部</td>
<td>程序语言；代码风格；模块化;复用性;耦合度与内聚度</td>
<td>项目管理过程；业务建模过程；需求过程；设计过程；构造过程；测试过程；部署过程；配置管理过程；工具与环境支持过程</td>
<td>人;软硬件环境; 经验</td>
</tr>
<tr>
<td>外 部</td>
<td>软件系统的可靠性;健壮性；效率;可用性;可维护性;可移植性</td>
<td>资源保障；可控制性；可观察性；稳定性</td>
<td>成本；时 间；合作 机制</td>
</tr>
</tbody></table>
<p><strong>▲软件规模的度量</strong> (计算题)</p>
<p><strong>（一）代码行度量</strong>（直接度量，依赖于程序设计语言）</p>
<p>含义：通过项目总代码行数去度量项目的规模属性。（书本原话：用代码行数（LOC）表示软件项目的规模是自然和直观的。可以用人工或工具直接测量。几乎所有软件开发组织都保存软件项目的代码行数记录，开发初期可以度量软 件规模，度量生产 率、每行代码的平均人力成本、文档和代码的比例关系、每千行代 码存在的软件缺陷个数等）</p>
<p>优点：简单直观，容易操作。</p>
<p>缺点：1.依赖于特定程序设计语言；2.可能对一些设计精巧的软件项目不利；3. 项目开发前期估算困难；4.适用于过程式程序设计语言，对非过程程序设计语言不太 适用；</p>
<p> （<strong>二）基于功能点度量</strong>（间接度量，不依赖于语言）</p>
<p>含义：根据事务信息处理程序的基本功能定义的，采用 5 个测量参数，涉及多种因 素的间接度量方式。（因而可以估算出软件项目的规模）</p>
<p> 优点：1.与程序设计语言无关，适用于过程式和非过程式程序设计语言；2.度量可以用于软件开发的初期（因为初期即能确定系统的输入/输出）</p>
<p>缺点：1.涉及主观因素较多，如加权值；2.信息领域数据有时不容易采集；3.FP(功能点)的值没有直观物理意义。 <strong>两者联系：抽象度越高的语言，同样的功能点对应的码会越少。</strong> </p>
<p><strong>▲软件复杂性的度量</strong></p>
<p><strong>(一)控制结构复杂性</strong>: 圈复杂度/巡回秩数  V(G) = e-n+2 </p>
<p>V(G)的值不要大于10,否则模块内部结构就会变得复杂,给编码和测试带来困难</p>
<p>(二)<strong>体系结构的复杂性</strong> 1. 简单形态度量:弧与节点数之和 S=a+n; 弧与节点数之比 R=a/n;</p>
<p>比值R体现了体系结构的连接密度,R越大,耦合度越高.</p>
<p><strong>▲软件质量度量</strong> </p>
<p><strong>软件质量的定义</strong>：软件制品满足规约和隐含需求特征及特征总和的程度。特征包括：功能性，可靠性，有效性，可使用性，可维护性，可移植性。·2011：增加了安全性 和兼容性的两个特征，扩展了子特征的概念。 软件特征的变化反映了软件与时俱进的特点，为软件质量度量和通过技术手段提高 软件制品质量指明了方向</p>
<p><strong>McCall 三层次度量模型</strong>：质量要素指标（Factor）、评价准则（Criteria）、属 性度量(Metric)。Factor 包括：运行性、修正性、适应性。评价准则 21 个。</p>
<p><strong>所有的质量度量模型（McCall、ISO）是层次性模型，不同在于分的哪些层次,每一 层有哪些方面。</strong> </p>
<p><strong>【第十六章、软件项目管理与过程改进】</strong></p>
<p>目的：软件项目管理的目的是使项目能够按照预定的成本、 进度、质量顺利完成。</p>
<p> 一般经验估算模型：基于代码行的模型 E=a(KLOC)b+c；基于功能点的模型 E=a+b*FP，不同模型采用不同参数</p>
<p><strong>▲软件项目度量与估算</strong> </p>
<p><strong>（一）采用代码行/功能点度量的工作量估算</strong> </p>
<p><strong>E=(a+4m+b)/6</strong>: 采用上述估算方法可估算出 LOC/FP 的乐观值 a，悲观值 b，一般值 m。（表格 16.5 的几列数据要会算）</p>
<p>一般经验估算模型：基于代码行用 E=a(KLOC)^b+c,abc 查表；E 是人月工作量；基于功能点用 E=a+b<em>FP。ab 查表。</em></p>
<p><strong>（二）COCOMO 模型（Constructive Cost Model,构造性成本模型）</strong></p>
<p> COCOMO 模型分为基本、中间、详细三个层次。</p>
<p>通信开销=u<em>n</em>(n-1)/2</p>
<p>基本 COCOMO 模型：用于系统开发初期，估算系统开发工作量和所需要的时间。 <strong>E=a(L)^b; D=c(E)^d</strong>;abcd 查表；E 是人月工作量；D 是开发时间.<strong>N=E/D</strong> 是建议参加项目的<strong>人数</strong>。</p>
<p>中间 COCOMO 模型：用于详细设计阶段，估算各个子系统的工作量和开发时间。 E=a(L)^b*EAF;L 是代码行估算值，单位 kloc；ab 查表。EAF 是工作量调节因子，EAF= （15 个 Fi 连乘）</p>
<p>详细 COCOMO 模型：用于估算独立的软构件，如子系统内部的各个模块，软件的集成和测试。</p>
<p><strong>（三）COCOMO Ⅱ</strong> </p>
<p><strong>E=a(L)^b*EAF+ER</strong>。ER 表示复用构件、代码自动生成需要的工作量，单位人月。 </p>
<p><strong>（四）Putnam 模型</strong> </p>
<p>时间推前或延迟 k%对工作量的影响？</p>
<p><strong>L=C<code>*</code>E^(1/3)<code>*</code>t^(4/3)</strong>.L是代码行数；E 是工作量，单位人年，包括维护；t 是开 发时间；C 表示软件开发环境的常数，查表。 </p>
<p><strong>E=L^3/(C^3*t^4)。比如提前 10%的时间（t=0.9t）,算出工作量 E=1.524E。说明 要增加 52%的工作量。</strong></p>
<p>Putnam 模型虽然揭示了软件项目的工作量、软件开发时间和程序代码长度三者之间的关系，但它没有反映软件制品、软件项目、软件开发人员和计算机软硬件资源等 属性。因此用该模型进行软件项目的成本估算是十分粗糙的。</p>
<p><strong>▲软件项目计划—-工程进度安排</strong></p>
<p><u><em><strong>两个重要的图：网络图（找关键路径，非关键路径的点可调控）；甘特图（网络图=&gt;甘特图）</strong></em></u></p>
<p>Gantt 图优点：简单易用，容易修改，比 PERT 图更加直观方便。 </p>
<p>Gantt 图缺点：不能显示各项活动之间的依赖关系</p>
<p><strong>▲软件配置管理</strong> (版本,基线)</p>
<p><strong>配置管理的目的</strong>：目的是为了减少混乱，提高软件生产率。是对软件修改进行标识、组织和控制的技术，用来协 调和控制整个系统的过程。 </p>
<p><strong>基线技术</strong>：标志软件开发过程的各个里程碑，通过复审的软件配置项 (SCI,Software Configuration Item, SCI是配置管理的基本单位)是构成基线的重要内容,它标志开发过程中一 个阶段的结束。</p>
<p><strong>基线的使用</strong>：1.某 SCI 成 为基线，就会被存入项目数 据库；2.要想改动 SCI，就要复制到私有工作区并在 项目数据库中锁住。3.在私有工作区完成修改并通过复审后，新SCI释放并送回项目 数据库,并解锁。</p>
<p> ·常用基线：1.系统工程–系统规约；2.需求分析—软件需求规约；3.软件设计—设 计规约;4.编码—源代码；5.测试—测试计划、过程、数据；6.集成—可运行系统。</p>
<p>常用工具：版本控制 git；DSEE</p>
<p>DSEE：历史管理、配置管理、任务管理、监控管理。</p>
<p>SCI:（1）系统规约；（2）软件项目规划；（3）需求分析结果；a.软件需求规约； b.可执行的或“纸样”原型；（ 4）初步用户手册；（5）设计规约；a.数据设计描 述；b.总体结构设计描述；c.模块设计描述；d.界面设计描述；e.对象描述；（6） 源代码清单；（7）测试规约；a.测试计划和过程；b.测试用例和实验结果；（8）操 作和安装手册；（9）可执行程序；a.每个模块的可执行代码；b.链接到一起的代码； （10）数据库描述；a.数据模型和文件结构；b.初始化映像；（11）联机用户手册； （12）维护文档； a.软件问题报告；b.维护申请；c.预计变更的顺序；（13）软件工程的标准和过程。</p>
<p>配置管理的任务：标识配置项；版本管理。</p>
<p>配置项的状态有三种：“草稿”（Draft）、“正式发布”（Released）和“正在修 改”(Changing)。变迁：配置项刚建立时其状态为“草稿”。配置项通过评审（或审 批)后，其状态变为“正式发布”。此后若更改配置项，必须依照“变更控制规程” 执行，其状态变为“正在修改”。当配置项修改完毕并重新通过评审（或审批）时， 其状态又变为“正式发布”，如此循环. </p>
<p><strong>▲软件过程改进</strong></p>
<p><strong>能力成熟度模型CMM</strong>:Capability Maturity Model for Software,软件成熟度模型。CMM 是一个概念模型,模型框架和表示是刚性的，不能随意改变。但模型的解释和实现有一定弹性。CMM 源于大型软件开发实践，反映了软件过程评估和软件过程改进的需要，是一个有效的大型软件开发、维护过程模型。 CMM 的应用进一步规范、指导软 件开发组织的自身建设，使软件开发组织从混乱的、低效的不成熟状态，向有纪律的、 高效的成熟状态转变。</p>
<p><strong>常用词汇</strong>: 组织,项目,软件过程,组织的标准软件过程,定义项目的软件过程,组织的软件过程资产</p>
<p><strong>关键过程域 KPA</strong>：描述软件的过程属性，通过完成一组相互关联的活动，实现建立 过程能力至关重要的一组目标。（软件开发组织的软件过程能力是组织能够承接软件 项目的重要依据）</p>
<p>CMM 的能力成熟度共分 5 级：L1 初始级；L2 可重复级；L3 已定义级；L4 已管理级； L5 优化级。从 2 级开始，每级包括若干个 KPA。 ·CMM 评估阶梯：L1 初始级；L2（软件项目计划+软件项目跟踪与监督）；L3（综合 软件管理）；L4（定量的过程管理）；L5（过程变更管理）。</p>
<p>什么是 CMMI？CMMI 是若干过程模型的综合和改进，是支持多个工程学科和领域的,系统的,一致的过程改进框架，能够适应现代工程的特点和需要，能够提高过程的质量和工作效率。</p>
<p>CMMI 等级：L0 不完全级；L1 已执行级；L2 已管理级；L3 已定义级；L4 定量管理 级；L5 优化级。 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>专业课简答题</title>
    <url>/2021/09/08/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%AE%80%E7%AD%94%E9%A2%98/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><ol>
<li>操作系统的作用? <ol>
<li>操作系统是用户与计算机硬件系统之间的接口. </li>
<li>操作系统是计算机资源的管理者 </li>
<li>操作系统是计算机工作流程的组织者 </li>
<li>操作系统实现了对计算机资源的抽象<br />{1. 覆盖了一层I/O设备管理软件,隐藏I/O细节;<br />2.在隐藏I/O细节的基础上覆盖了一层用于文件管理的软件} </li>
</ol>
</li>
<li><strong>操作系统具有那几大特征,他们之间的关系?</strong><br />操作系统有:并发、共享、虚拟、异步 四大特征 <ol>
<li>并发和共享是操作系统最基本的特征，为了提高计算机资源利用率，OS必然要采用多道技术，使多个程序共享系统的资源，并发的执行</li>
<li>并发和共享互为存在的条件。1. 资源的共享是以程序的并发执行为条件的。2.若系统不能对资源共享实施有效的管理，也必将影响到程序的并发</li>
<li>虚拟性以并发和共享为前提</li>
<li>异步性是并发和共享的必然结果，多个并发进行共享资源会使得每个进程的运行过程受到其他进程制约</li>
</ol>
</li>
<li>什么是多道技术，OS引入多道的目的<br />多道程序技术是指在内存中同时存放若干个作业，并使它们共享系统资源且并发运行的技术。<br />OS引入多道技术：1.提高CPU利用率；2.提高内存和I/O设备利用率；3.增加系统吞吐量 </li>
<li>推动批处理系统和分时系统形成和发展的主要动力是什么？<br />批处理系统：不断提高系统资源利用率和提高系统吞吐量<br />分时系统：为了更好地满足用户地需要 </li>
<li>实现分时系统地关键问题是使用户能与自己的作业进行交互，为此需要引入：1. 缓冲区暂存用户键入的命令和输出的结果；2. 规定每个程序每次只能运行一个时间片 </li>
<li>比较分时系统与实时系统<br />分时系统：多路性、独立性、及时性、<strong>交互性</strong><br />实时系统：多路性、独立性、<strong>及时性</strong>、交互性、可靠性 <ol>
<li>从交互性方面：交互性是分时系统的关键问题，用户可以进行广泛的人机交互；实时系统的交互性具有很大的局限性。</li>
<li>从及时性方面：分时系统的及时性是指用户能在很短时间内获得系统的响应，2-3秒；及时性是实时系统的关键问题，由被控制对象所要求的开始截止时间和完成截止始键决定，毫秒级</li>
<li>从可靠性方面：可靠性是实时系统另一个关键问题。分时系统的可靠性要求较低</li>
</ol>
</li>
<li>批处理系统、分时系统、实时系统各有什么特点？ <ol>
<li>批处理系统：用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行</li>
<li>分时系统：可让多个用户同时使用计算机，人机交互性强，具有每个用户独立使用计算机的独占性，系统响应及时</li>
<li>实时操作系统能对控制对象做出及时反应，可靠性高，响应及时，但资源利用率低</li>
</ol>
</li>
</ol>
<h2 id="第二章-进程控制与描述"><a href="#第二章-进程控制与描述" class="headerlink" title="第二章 进程控制与描述"></a>第二章 进程控制与描述</h2><ol>
<li><p>进程控制块PCB（进程存在的唯一标志）：<br />作用：1. 进程控制块时操作系统用来描述和管理进程的数据结构；2.使一个在多道环境下不能独立运行的程序成为一个能独立运行的基本单位； 3.记录系统所需的用于描述进程当前情况机控制进程运行的全部信息。<br />在进程整个生命周期中，系统总是通过PCB来对进程进行控制和管理，系统依靠PCB感知进程的存在。  </p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">进程标识符</span><br><span class="line">处理机状态：主要是寄存器的内容组成，用于CPU切换时保存线程信息和恢复现场信息。</span><br><span class="line">进程调度信息：进程状态、优先级、等待和使用CPU的时间等，用于进程调度和对换。</span><br><span class="line">进程控制信息：地址，进程同步和通信信息，资源清单，队列指针等</span><br></pre></td></tr></table></figure></li>
<li><p>进程创建的过程： </p>
<ol>
<li>申请空PCB：先从PCB集合中申请一个空闲的PCB</li>
<li>分配资源：在为新进程分配内存等资源</li>
<li>初始化PCB：根据父进程提供的参数和分配到的资源的情况来对PCB进行初始化</li>
<li>插入就绪队列</li>
</ol>
</li>
<li><p>进程同步机制原则：</p>
<ol>
<li>空闲让进，临界区空闲，允许一个请求进程立即进入临界区</li>
<li>忙则等待，已有进程进入临界区，其他请求进入的进程必须等待</li>
<li>有限等待，应保证请求进程在有限时间内进入临界区</li>
<li>让权等待 ，当进程不能进入临界区，应立即释放处理机，防止忙等</li>
</ol>
</li>
<li><p>进程通信的类型：<br />共享存储器系统，管道通信，消息传递系统，客户机-服务器系统 </p>
</li>
<li><p>消息缓冲队列机制发送原语和接收原语：</p>
</li>
</ol>
<p>原理：消息缓冲队列通信机制通过内存中公用的消息缓冲区进行进程通信，属于直接通信方式。发送进程发送消息时，需申请一个消息缓冲区，并把自己的进程标示符和有关消息的内容填入消息缓冲区，然后将其插入到接收进程的消息缓冲队列中，接收进程接收消息时需从自己的消息缓冲队列中摘下一个消息缓冲区，取出其中的消息，然后消息缓冲区归还给系统。</p>
<p>PCB需要添加：mq（消息缓冲队列队首指针）；mutex（消息缓冲队列互斥信号量）；sm（消息缓冲队列资源信号量）。    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span>&#123;</span> <span class="comment">//消息缓冲区数据结构</span></span><br><span class="line">    <span class="type">int</span> sender; <span class="comment">//发送者进程标识符</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//消息长度</span></span><br><span class="line">    <span class="type">char</span> *text；<span class="comment">//消息正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个消息缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send</span><span class="params">(receiver a)</span>&#123; <span class="comment">//发送原语</span></span><br><span class="line">     getbuf(a.size, i); <span class="comment">//根据a.size申请缓冲区</span></span><br><span class="line">     i.sender = a.sender; <span class="comment">//将发送区a中的信息复制到缓冲区i</span></span><br><span class="line">     i.size = a.size;</span><br><span class="line">     copy(i.text, a.text);</span><br><span class="line">     i,next = <span class="number">0</span>;</span><br><span class="line">     getid(PCBset, receiver, j)<span class="comment">//获得接收程序j的PCB</span></span><br><span class="line">     wait(j.mutex)</span><br><span class="line">     insert(&amp;j.mq, i) <span class="comment">//将消息缓冲区i插入消息队列</span></span><br><span class="line">     signal(j.mutex)</span><br><span class="line">     signal(j.sm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">receive</span><span class="params">(b)</span> &#123; <span class="comment">//接收原语</span></span><br><span class="line">    j = internal_name; <span class="comment">//获取当前进行的PCB</span></span><br><span class="line">    wait(j.sm);</span><br><span class="line">    wait(j.mutex);</span><br><span class="line">    remove(j.mq, i); <span class="comment">//移出消息队列第一个消息</span></span><br><span class="line">    signal(j.mutex); </span><br><span class="line">    b.sender = i.sender; <span class="comment">//将缓冲区i中信息复制到接收区b</span></span><br><span class="line">    b.size = i.size;</span><br><span class="line">    copy(b.text, i.text);</span><br><span class="line">    releasebuf(i); <span class="comment">//释放消息缓冲区i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>为什么要引入进程？<br />为了实现多个程序的并发执行，提高资源利用率和系统吞吐量。<br />传统的程序在并发执行时结果不可再现。<br />不利影响：管理进程需要付出一定的代价，包括进程控制块，进程间切换，同步，通信等。 </p>
</li>
<li><p>进程和程序的异同：<br />进程与程序紧密相关又完全不同。 </p>
<ol>
<li>进程实体中除了程序段和数据段之外还包含一个数据结构PCB </li>
<li>进程是动态的，是程序的一次执行过程。<br />程序是静态的，是一组指令的有序集合 </li>
<li>多个进程实体可同时放在内存中并发执行，这是引入进程的目的<br />程序的并发具有不可再现性，不能正确的并发。 </li>
<li>进程是一个能够独立运行、独立分配资源和独立接收调度的基本单位。程序在多道程序环境下不能独立运行（没有PCB） </li>
<li>进程与程序不一一对应；同一程序多次运行产生多个进程；同一程序一次执行也可产生多个进程（fork调用产生子进程）；一个进程在生命周期不同时候可以执行不同的程序。 </li>
</ol>
</li>
<li><p>进程和线程的异同 </p>
<ol>
<li>调度性：引入线程后，线程成为调度和分派的基本单位，进程只是拥有资源的基本单位</li>
<li>并发性：都可并发</li>
<li>拥有资源：拥有资源的基本单位是进程。线程只有一点必不可少的资源，但可共享其隶属进程的资源。</li>
<li>独立性：进程可独立的申请资源和运行，而同一进程下的线程共享进程的地址空间和其他资源，独立性较低。</li>
<li>开销：创建撤销进程时，OS都要为之分配和回收资源。开销远大于线程。</li>
<li>传统的进程只能运行在一个处理机上，多线程的进程则可以运行在多个处理机上，并发效果更好。</li>
</ol>
</li>
<li><p>进程状态转换  </p>
<table>
<thead>
<tr>
<th>状态转换</th>
<th>引起转换的事件</th>
</tr>
</thead>
<tbody><tr>
<td>就绪-执行</td>
<td>CPU调度</td>
</tr>
<tr>
<td>执行-就绪</td>
<td>时间片完，更高优先级进程抢占</td>
</tr>
<tr>
<td>执行-阻塞</td>
<td>等待I/O或临界资源</td>
</tr>
<tr>
<td>阻塞-就绪</td>
<td>等待的事件完成</td>
</tr>
</tbody></table>
</li>
<li><p>内核支持线程和用户级线程：<br />内核支持线程是在内核支持下实现的，即每个线程的线程控制块设置在内核中。用户级线程仅存在于用户空间中，每个线程控制块设置在用户空间中，所有对线程的操作也在用户空间中完成，无需内核帮助。 </p>
</li>
</ol>
<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><ol>
<li><p>处理机调度算法的目标</p>
<ol>
<li>资源利用率：为提高资源利用率，应使系统中的处理机和其他所有资源都尽可能保持忙碌</li>
<li>公平性：应使进程获得合理的CPU时间，不会发生饥饿现象。</li>
<li>平衡性：尽可能保持系统资源使用的平衡性</li>
<li>策略强制执行</li>
</ol>
</li>
<li><p>处理机调度的层次</p>
<ol>
<li>高级调度：作业调度，把作业从后备队列拿出，分派资源后建立进程中，使之可以获得处理机</li>
<li>中级调度：内存调度，把外存中的就绪进程调入内存，插入就绪队列</li>
<li>低级调度：进程调度，最基本的调度。决定就绪队列的进程获得处理机</li>
</ol>
</li>
<li><p>调度的方式</p>
<ol>
<li>非剥夺（非抢占）方式：一旦分配就占有资源直到阻塞或结束。优点是简单，系统开销小</li>
<li>剥夺（抢占）方式：当前进程所占有的资源可被其他进程夺走。<ol>
<li>优点：更高的系统吞吐率和响应效率</li>
<li>原则：优先权、短进程、时间片原则</li>
</ol>
</li>
</ol>
</li>
<li><p>引起进程调度的因素：</p>
<ol>
<li>正在执行的进程正常终止或异常终止</li>
<li>正在执行的进程因某种原因而阻塞</li>
<li>引入时间片的系统中，时间片完</li>
<li>抢占调度方式中，有更高优先权的进程</li>
</ol>
</li>
<li><p>调度的算法的类型及比较：</p>
<p> 有先来先服务、短作业优先、优先级调度、高响应比优先、时间片轮转、多级反馈队列等</p>
<ol>
<li>先来先服务、短作业优先无法保证及时接收和处理问题，无法保证在规定时间间隔内响应每个用户需求，也不能达到实时系统的及时性需求。</li>
<li>优先级调度算法，按优先级进行调度，对于更紧急的任务予以更高优先级，适合实时操作系统</li>
<li>高响应比优先，时间片轮转，多级反馈队列能保证每个任务在一定时间内分配到时间片，适合分时系统</li>
</ol>
</li>
<li><p>低级调度主要功能</p>
<p> 低级调度用于决定就绪队列中哪个进程获得处理机，并由分派程序把处理机分配给该进程</p>
<ol>
<li>保存当前进程的处理机现场信息到PCB</li>
<li>按调度算法选择投入执行新进程</li>
<li>恢复新进程的现场，将处理机分配给新进程</li>
</ol>
</li>
<li><p>高响应比优先调度算法优点是什么？</p>
<p> 响应比 = 响应时间/要求服务时间 = （等待时间+要求服务时间）/要求服务时间 ； 优点是：</p>
<ol>
<li>如果进程等待时间相同，则要求服务时间最短的进程优先权最高，有利于短作业。【SJF短作业优先只考虑了作业运行时间而忽略了作业等待时间】</li>
<li>如果作业要求服务时间相同，则优先权将取决于进程到达先后次序，体现了公平原则。【FCFS先来先服务只考虑作业等待时间而忽视了作业运行时间】</li>
<li>如果进程较长，它的优先权将随着等待时间的曾长而提高，不会长时间得不到服务。<ol start="8">
<li>为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？</li>
</ol>
</li>
<li>对于终端型作业用户而言，其提交的作业大多为交互型作业，作业通常较小，系统只要能使这些作业在第一个队列所规定的时间片内完成，便可使其满意</li>
<li>对于短批处理作业用户而言，较短的作业可在第一个队列完成，稍长的也可以在第二三队列执行一个时间片完成，周转时间仍然很短。</li>
<li>对于长批处理作业用户而言，用户不必担心作业长期得不到处理，且每下降一个队列，长作业等待时间都进一步缩短。</li>
</ol>
</li>
<li><p>死锁定理</p>
<p> 在资源分配图中找到一个既不阻塞又非独立的进程，分配给该进程资源后，该进程执行完毕释放所占资源，即消去请求边与分配边，使其成为孤立点，重复该过程，若能使所有进程都能成为孤立点，则该图是可完全简化的。<br />当前状态为死锁的充分条件是，当且仅当该状态的资源分配图是不可完全简化的。</p>
</li>
<li><p>产生死锁的原因和必要条件</p>
<p>原因：系统资源的竞争和进程推进顺序非法。<br />必要条件：互斥条件、请求与保持条件、不剥夺条件、循环等待条件<br />预防死锁：破坏四个条件<br />避免死锁：银行家算法，防止进入不安全状态<br />检测死锁：死锁定理，资源分配图<br />解除死锁：资源剥夺，撤销进程，解除死锁</p>
</li>
</ol>
<h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><ol>
<li><p>程序的装入</p>
<ol>
<li>绝对装入方式：产生使用绝对地址的目标模块。只适用于单道程序环境</li>
<li>可重定位装入方式：程序中的其他地址都是相对于始址的<ol>
<li>静态重定位：在装入时，由重定位程序一次性完成的。不允许程序在运行时在内存中移动位置。</li>
</ol>
</li>
<li>动态运行时装入方式：需要重定位寄存器的支持。可以将程序分配在不连续的存储区中，程序运行之前可以只装入部分代码即刻运行，运行期间动态申请分配内存，便于程序段共享。</li>
</ol>
</li>
<li><p>程序的链接</p>
<ol>
<li>静态链接方式：在程序运行之前将各目标模块及所需的库函数链接为一个完整的装入模块。</li>
<li>装入时动态链接：链接在装入时进行，便于对程序模块进行修改和更新，可对外存中的目标模块实现共享。</li>
<li>运行时动态链接：链接在运行时进行。便于实现目标模块的修改、更新和共享，加快程序的装入过程，提高内存利用率。</li>
</ol>
</li>
<li><p>为什么引入对换？</p>
<ol>
<li>在多道程序环境下，一方面内存中某些进程由于某事件尚未发生而阻塞，却占用大量内存空间，可能出现内存中所有进程被阻塞。另一方面：又有很多作业意志驻留外存，不能进入内存运行</li>
<li>提高内存利用率，系统吞吐量</li>
</ol>
</li>
<li><p>什么情况下需要进行重定位？为什么要引入重定位？</p>
<p> 重定位概念：将作业空间中的逻辑地址转换为主存空间中的物理地址，从而保证作业能够正常进行。</p>
<ol>
<li>程序在装入时，指令和数据的实际物理地址与装入模块中的相对地址是不一致的，此时需要重定位。</li>
<li>引入动态重定位是因为进程在运行过程中进场要在内存中移动位置。重定位的过程是由硬件地址变换机构在程序执行每条指令时自动完成。</li>
</ol>
</li>
<li><p>连续分配方式中动态分区分配方式：</p>
<ol>
<li>首次适应算法：按地址从小到大为序，分配第一个符合条件的分区。</li>
<li>最佳适应算法：按空间从小到大为序，分配第一个符合条件的分区。</li>
<li>最坏适应算法：按空间从大到小为序，分配第一个符合条件分区。</li>
<li>循环首次适应：与首次适应算法相似，从上次分配的下一个位置继续。</li>
</ol>
</li>
<li><p>分页系统地址变换机构</p>
<p> 硬件支持：页表寄存器，地址变换机构</p>
<ol>
<li>页号与页表长度比较，页号大于页表长度，则产生越界中断</li>
<li>以页号为索引去检索页表。页表始址+页号x页表项长度</li>
<li>从页表中获取物理块号。</li>
<li>物理地址=物理块号+页内地址。</li>
</ol>
<p> 一次数据操作，访问两次内存：访问页表获取块号，访问数据。<br />引入快表的地址变换机构</p>
<ol>
<li>页表在与页表寄存器中的页表长度比较时并行地与快表中的所有页号比较。</li>
<li>若在快表中则直接读出物理块号。</li>
<li>否则从页表中读，并将得到的页表项和页号装入到快表中。</li>
</ol>
<p> 多级页表机制下页内地址长度等于页面大小。</p>
</li>
<li><p>分段系统地址变换机构</p>
<p> 硬件支持：段表寄存器，地址变换机构</p>
<ol>
<li>段号S与段表度长比较，若大于则产生越界中断。</li>
<li>使用段号进行索引段表得到该段的基址和长度。段表始址+段号x段表项长度。</li>
<li>检查段内地址是否超过段长，超过则产生越界中断。</li>
<li>物理地址=起始地址（基址）+段内地址。</li>
</ol>
<p> 一次数据操作访问两次内存。</p>
</li>
<li><p>分页与分段比较：</p>
<ol>
<li><p>页是信息的物理单位，分页是为了提高内存利用率。段是信息的逻辑单位，含有一组其意义相对完整的信息。分段是为了能更好的满足用户的需要。</p>
</li>
<li><p>页的大小固定且由系统决定。段的长度不固定且由用户所编写的程序决定。</p>
</li>
<li><p>分页的地址空间是一维的，分段的地址空间是二维的。</p>
</li>
<li><p>分页有内部碎片，无外部碎片。分段无内部碎片，有外部碎片。</p>
</li>
<li><p>分段更容易实现共享和动态链接。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h2><ol>
<li><p>什么是虚拟存储器？</p>
<p> 虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储系统。<br />虚拟存储器具有如下特征：</p>
<ol>
<li>多次性，最本质最重要的特征。虚拟存储器将一个作业分成多次调入内存。部分装入。</li>
<li>对换性，虚拟存储器允许将将暂时用不到的程序从内存调到对换区，提高内存利用率。</li>
<li>虚拟性，虚拟存储器对内存的扩充是逻辑上的。</li>
<li>离散性，虚拟存储器必须建立在离散分配的基础上。</li>
</ol>
</li>
<li><p>如何实现页式虚拟存储器？</p>
<p> 首先请求分页的页表机制。扩充页表，增加状态位确认是否在内存；增加外存始址便于调入；增加引用位供置换算法。增加修改位减少换出时写磁盘次数。<br />请求调页技术，需要硬件上缺页中断机制和软件配合实现。<br />置换页技术，关键是采取什么置换算法。<br />还有地址变换机构。</p>
</li>
<li><p>局部性原理</p>
<ol>
<li>时间局部性，某条指令（数据）一旦执行（访问），不久后可能被再次执行（访问）。原因是程序中的大量循环操作。</li>
<li>空间局部性，程序在一段时间内所访问的地址可能集中在一定范围内。原因是程序的顺序执行。</li>
</ol>
</li>
<li><p>缺页中断中断机构与一般中断之间的区别</p>
<ol>
<li>在指令执行期间产生和处理中断信号。</li>
<li>一条指令在执行期间可能产生多次中断。</li>
</ol>
</li>
<li><p>请求分页系统中地址变换过程（考试中不需要写这个详细的，要写按地址字段进行转换的）</p>
</li>
</ol>
<img src="https://fastly.jsdelivr.net/gh/konsin/images@main/202207111635877.jpeg" alt="7B745057-CD3E-4C10-99F6-05F104B1AE8F.jpeg" style="zoom:20%;" />

<ol start="6">
<li>页面置换算法<ol>
<li><p>最佳算法（OPT）：选择往后最长时间内不再被访问的页面置换。</p>
</li>
<li><p>先进先出页面置换算法（FIFO）</p>
</li>
<li><p>最近最久未使用算法（LRU）：为每个页面设置一个访问字段，记录自上次被访问以来所经历的时间。选择最大的置换。需要寄存器和栈的硬件支持。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第六章-输入输出系统（I-O）"><a href="#第六章-输入输出系统（I-O）" class="headerlink" title="第六章 输入输出系统（I/O）"></a>第六章 输入输出系统（I/O）</h2><ol>
<li><p>I/O系统基本功能</p>
<p>方便用户使用I/O设备。</p>
<ol>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
</ol>
<p>提高设备的资源利用率。</p>
<ol>
<li><p>提高处理机和I/O设备的利用率。</p>
</li>
<li><p>对I/O设备进行控制。</p>
</li>
</ol>
<p>方便用户共享。</p>
<ol>
<li><p>确保对设备的正确共享</p>
</li>
<li><p>错误处理</p>
</li>
</ol>
</li>
<li><p>I/O系统的层次结构</p>
<ol>
<li>用户层I/O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ol>
</li>
<li><p>I/O控制方式</p>
<ol>
<li><p>轮询方式：程序直接对设备循环测试</p>
<p>优点：简单，易于实现<br />缺点：CPU和I/O只能串行工作，CPU利用率很低</p>
</li>
<li><p>中断方式：引入中断机制，当设备准备完成时发生中断</p>
<p>优点：CPU和I/O可以并行工作，相较于轮询方式大大提高了CPU利用率<br />缺点：仍以字节为单位，降低了效率。</p>
</li>
<li><p>DMA（直接存储器存取）方式：在I/O设备与内存之间直接开辟数据通路</p>
<p>特点：</p>
<ol>
<li>基本单位是数据块</li>
<li>数据是直接从设备送入送出内存的</li>
<li>仅在传送一个或多个数据块的开始和结束时才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</li>
</ol>
</li>
<li><p>通道控制方式：引入专门的I/O处理机进行管理</p>
<p>进一步减少CPU干预，基本单位变为一组数据块</p>
</li>
</ol>
</li>
<li><p>试说明I/O控制发展的主要推动因素是什么？</p>
<ol>
<li>力图减少CPU对I/O设备的干预，充分发挥CPU的数据处理能力</li>
<li>缓和CPU的高速性和I/O设备的低速性之间速度不匹配的矛盾。提高CPU利用率和系统的吞吐量。</li>
<li>提高CPU和I/O设备操作的并行程度。提高整个系统的资源利用率和吞吐量。</li>
</ol>
</li>
<li><p>中断的重要性：</p>
<ol>
<li>中断是多道程序实现的基础，进程的切换通过中断完成。</li>
<li>中断是设备管理的基础，为提高CPU利用率和实现CPU与I/O设备并行执行。</li>
</ol>
</li>
<li><p>中断驱动I/O方式和DMA方式有什么不同？</p>
<ol>
<li>中断方式是程序的切换，要保护和恢复现场； DMA方式除了预处理和后处理其余时间不占用CPU</li>
<li>对中断请求的响应只能发生在每条指令结束时（指令执行周期后）；对DMA的请求响应可以发生在每个机器周期结束时（取指、间址、执行），只要CPU不占用总线就可以响应。</li>
<li>中断传送过程需要CPU的干预；DMA传送过程不需要CPU的干预，故DMA传输效率高，适合高速外设成组数据传输。</li>
<li>DMA请求优先于中断请求</li>
<li>中断方式具有对异常事件的处理能力。 DMA方式仅局限传送数据块的I/O操作。</li>
<li>从数据传送来看，中断靠程序传送，DMA靠硬件传送。</li>
</ol>
</li>
<li><p>DMA方式和I/O通道方式的区别。</p>
<ol>
<li>DMA需要CPU控制数据传送位置，数据块大小等参数，而通道中这些参数的设置是由通道控制的。</li>
<li>一个DMA控制器对应一台设备。 一个I/O通道可以控制多台设备。</li>
</ol>
</li>
<li><p>为什么I/O通道常采用交叉连接的方式</p>
<p>I/O通道是一种特殊的处理机，它具有执行I/O指令的功能，能控制I/O操作。由于通道价格昂贵，所以通道数量少，这往往成为I/O的瓶颈，造成整个系统吞吐量的下降。为解决此问题，增加设备到主机之间的通路而不增加通道，提高了系统可靠性。</p>
</li>
<li><p>为什么要引入缓冲区？（重要）</p>
<ol>
<li>缓和CPU和I/O设备速度不匹配的矛盾。</li>
<li>减少对CPU的中断频率，放宽CPU响应中断时间。</li>
<li>提高CPU和I/O设备之间的并行性</li>
<li>解决数据粒度不匹配的问题。</li>
</ol>
</li>
<li><p>为什么要引入设备独立性？如何实现设备独立性？（重要）</p>
<p>引入设备独立性，可使应用程序独立于具体的物理设备。用逻辑设备名来申请使用某类物理设备，可显著地改善资源的利用率及可适应性。独立性还可以使用户程序独立于设备的类型，可以很方便地进行输入输出重定向。<br />为了实现设备独立性，必须在设备驱动程序之上设置一层设备独立性软件，用来执行所有I/O设备的公用操作，并向用户层软件提供统一接口。关键是系统中必须设置一张逻辑设备表LUT来进行逻辑设备到物理设备的映射。（逻辑设备名、物理设备名、设备驱动程序入口地址）</p>
</li>
<li><p>什么是虚拟设备？实现虚拟设备的关键技术是什么？</p>
<p>虚拟设备是指通过某种虚拟技术，将一台物理设备变为若干台逻辑设备，从而实现多个用户对该物理设备的同时共享。<br />虚拟设备技术常通过在可共享的、高速的磁盘上开辟两个大的存储空间（输入井、输出井）以及预输入、缓输出技术来实现。预输入和缓输出可通过脱机和假脱机技术实现。</p>
</li>
<li><p>SPOOLing系统（假脱机技术）由哪几部分组成？以打印机为例说明如何利用SPOOLing技术实现多个进程对打印机共享。</p>
<p>SPOOLing系统由磁盘上的输入井和输出井、内存中的输入缓冲区和输出缓冲区，输入进程和输出进程以及井管理程序构成。<br />使用SPOOLing技术共享打印机：</p>
<ol>
<li><p>在输出井中为进程申请一空闲缓冲区，放入要打印的数据。</p>
</li>
<li><p>为用户进程申请一张空白的打印申请表，在把该表挂到假脱机文件队列上。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h2><ol>
<li><p>文件系统为什么通常是显式进行文件”打开””关闭”操作？</p>
<ol>
<li>打开文件操作的基本功能是将指定文件的属性信息FCB复制到内存中，并返回指向内存中该文件属性信息的地址（文件描述符）。关闭文件操作是从内存中删除文件的属性信息，并写回外存。</li>
<li>显式进行打开操作，当用户需要对一个文件实施多次读写操作时，只需要使用文件描述符而非路径名。系统则无需对目录进行检索便可通过文件描述符直接找到内存中的文件FCB。避免了重复检索目录，提高了文件的访问速度。</li>
</ol>
</li>
<li><p>文件的逻辑结构和物理结构的概念</p>
<ol>
<li><p>文件的物理结构是文件的存储结构，指系统过将文件存储在外存上的存储形式</p>
</li>
<li><p>文件的逻辑结构指从用户角度出发所观察到的文件组织形式，文件的内部数据在逻辑上是怎么组织的。</p>
<ol>
<li><p>有结构文件</p>
<ol>
<li>顺序文件：与关键字有关的串结构，无关的顺序结构</li>
<li>索引文件：为变长文件建立索引表</li>
<li>索引顺序文件：顺序文件和索引文件的结合</li>
<li>直接文件：通过哈希函数直接决定记录地址</li>
</ol>
</li>
<li><p>无结构文件：将数据按顺序组织成记录并积累保存。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对文件目录管理的要求？</p>
<ol>
<li>能够实现”按名存取”。</li>
<li>能够提供快速的目录查询手段以提高对文件的检索速度。</li>
<li>为文件的共享和重名提供方便</li>
<li>允许文件同名</li>
</ol>
</li>
<li><p>文件系统：文件控制块和索引节点的内容</p>
<img src="https://fastly.jsdelivr.net/gh/konsin/images@main/202207111635837.jpeg" alt="7775FC29-3F7C-47E8-83FB-299E9BD9F51A.jpeg" style="zoom: 10%;" />

<ol>
<li><p>文件控制块：</p>
<ol>
<li>基本信息：包括文件名，文件物理地址，文件逻辑结构，文件物理结构</li>
<li>存取控制信息：文件的存取权限</li>
<li>使用信息：文件的建立时间，修改时间，当前使用信息。</li>
</ol>
</li>
<li><p>索引结点：至少要有索引结点编号、存取权限、文件物理地址、文件大小的信息。</p>
<ol>
<li>优点是：可以减少文件查找时平均启动磁盘的次数，有效提升文件检索速度。</li>
</ol>
</li>
<li><p><del>磁盘索引结点</del></p>
<ol>
<li><del>文件主标识符</del></li>
<li><del>文件类型</del></li>
<li><del>文件存取权限</del></li>
<li><del>文件物理地址</del></li>
<li><del>文件长度</del></li>
<li><del>文件连接计数</del></li>
<li><del>文件存取时间</del></li>
</ol>
</li>
<li><p><del>内存索引结点</del></p>
<ol>
<li><del>索引结点编号</del></li>
<li><del>状态：是否修改</del></li>
<li><del>访问计数</del></li>
<li><del>文件所属文件系统的逻辑设备号</del></li>
<li><del>链接指针，指向空闲链表和散列队列。</del></li>
</ol>
</li>
</ol>
</li>
<li><p>文件系统必要的系统调用</p>
<p>创建文件、删除文件、读文件、写文件。<br />以读文件为例：</p>
<ol>
<li>系统调用给出文件名和读入的内存目标地址<ol>
<li>系统通过查找目录表，找到该文件所对应的索引结点编号，或直接通过指向索引节点的指针找到索引结点。</li>
<li>根据索引结点中的物理地址，找到文件在外存中存放的位置。</li>
<li>将该文件读入内存。</li>
</ol>
</li>
</ol>
</li>
<li><p>树形目录结构中线性检索法的检索过程</p>
<ol>
<li>系统在检索一个文件时，先读入给定文件路径名中的第一个分量名，用它与根目录文件（当前目录文件）中的各目录项中的文件名顺序地进行比较。<ol>
<li>若找到相匹配的目录项，则可获得它的FCB或索引节点编号，从而找到该分量名对应的文件。</li>
<li>然后系统再读入第二个文件分量名，与刚检索到的目录文件中的各目录项的文件名顺序比较，若找到，则重复该过程，逐级检索指定文件分量名，最后会得到指定文件的FCB或索引结点。</li>
</ol>
</li>
</ol>
</li>
<li><p>文件共享方式</p>
<p>目的是提高文件存储空间利用率，方便用户对文件的使用。</p>
<ol>
<li><p>基于索引结点的共享方式（硬链接）：将多个目录项指向同一个磁盘索引结点</p>
</li>
<li><p>利用符号链实现文件共享（软链接）：建立一个类型为LINK，内容为被共享文件路径名的新文件来实现共享。</p>
</li>
</ol>
</li>
</ol>
<h2 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h2><ol>
<li><p>文件外存分配中，即文件的物理结构，连续分配、链接分配、和索引分配各自的优缺点。</p>
<ol>
<li><p>连续分配方式：为每个文件分配一组相邻的物理块，将文件信息按逻辑顺序存放。</p>
<ol>
<li>适合不经常更新，经常随机访问</li>
<li>优点：管理简单；顺序访问存取速度很快；支持对文件随机存取</li>
<li>缺点：要求连续的存储空间，容易产生碎片，降低存储空间利用率；要求事先知道文件长度；不利于文件的增长扩充。</li>
</ol>
</li>
<li><p>链接分配方式：隐式链接方式类似于单链表；显式链接方式是将链接各物理块的指针显式地登记在系统的一张文件分配表FAT中。</p>
<ol>
<li><p>适合经常更新，经常顺序访问</p>
</li>
<li><p>隐式链接：</p>
<ol>
<li>优点：解决了外部碎片；不需事先知道文件长度；插入删除修改容易；</li>
<li>缺点：只支持顺序访问；可靠性较差</li>
</ol>
</li>
<li><p>显式链接：</p>
<ol>
<li>优点：可显著提高检索的速度；增加了文件系统的可靠性。</li>
<li>缺点：不支持高效的随机存取；文件存储介质较大，则FAT也要占用较大存储空间。</li>
</ol>
</li>
</ol>
</li>
<li><p>索引组织方式：为每个文件建立一个索引表，登记分配给该文件所有的物理块号，文件FCB的物理地址字段为该索引表的指针。</p>
<ol>
<li>适合经常更新，经常随机访问</li>
<li>优点：既支持顺序访问又支持随机访问；查找效率高；便于文件删除</li>
<li>缺点：索引表会占用一定存储空间，对单独的中小文件也需要分配完整的索引表，对外存空间造成严重浪费。</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>UNIX系统的混合索引方式：索引地址分为13个地址项。假设每个物理块4KB</p>
<p>优点：既能节省存储地址所占的存储空间，又有较高的查找速度。</p>
<ol>
<li><p>直接地址：0-9共10个地址项，分配相应文件的前十个物理块地址。可存储4KB X 10 = 40KB的文件</p>
</li>
<li><p>一次间址：地址项10为一次间址。登记分配给文件的第10个物理块及后序物理块地址。如果地址长度为4B，则一次间址块可存储4KB / 4B = 1K个物理块号。最大存储文件为40KB+ 1K x 4KB</p>
</li>
<li><p>多次间址：地址项11为二次间址，存储的是1次间址的块号。故可存储40KB+4MB+4GB的文件；地址项12是三次间址，存储的是二次间址的块号。故可存储40KB + 4MB + 4GB + 4TB的文件。</p>
</li>
</ol>
</li>
<li><p>文件存储空间的管理</p>
</li>
</ol>
<ol>
<li><p>位示图法：用1表示分配，0表示清除</p>
</li>
<li><p>成组链接法：适合大型文件。将一个文件卷的所有空闲盘块按固定大小分成若干组，并将每一组的盘块数和该组所有盘块号计入前一组的最后一个盘块中。（最后一组的0标记也算一个）</p>
<ol>
<li><p>分配过程（操作题）：</p>
<ol>
<li>将s_nfree（该组空闲盘块数）减1；</li>
<li>若s_nfee仍大于0，即第一组不只一个空闲盘块，则将s_free[s_nfree]空闲盘块号栈栈顶的空闲盘块分配出去。</li>
<li>若s_nfree为0，即当前空闲盘块号栈中只剩下最后一个空闲盘块，则用唯一所剩的盘块替换掉超级块，再将该盘块分配出去。</li>
<li>若s_nfree为0，且栈底登记盘块号为0；则表示系统已无空闲盘块可分配。</li>
</ol>
</li>
</ol>
</li>
<li><p>磁盘调度算法（计算）</p>
<p>一次磁盘读写操作时间：<br /></p>
<p>​    寻道时间（m x 磁道数 + 启动时间） + 延迟时间（1/2r） + 传输时间（b/(r x 一个磁道上字节数)）</p>
<ol>
<li>先来先服务（FCFS）：根据进程请求访问磁盘的先后顺序进行调度</li>
<li>最短寻找时间优先（SSTF）：选择当前磁头所在磁道距离最近的磁道</li>
<li>电梯算法（SCAN）：在当前移动方向上最近的磁道。</li>
<li>循环扫描算法（CSCAN）：只能一个方向，到达当前方向上最后一个需要访问的磁道后，从头开始。</li>
</ol>
</li>
<li><p>提高磁盘I/O速度的途径。</p>
<ol>
<li><p>磁盘高速缓存</p>
</li>
<li><p>提前读</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>延迟写</p>
</li>
<li><p>优化物理块布局</p>
</li>
<li><p>虚拟盘</p>
</li>
<li><p>提高文件访问速度的途径。</p>
<ol>
<li><p>改进文件的目录结构及检索目录的方法来减少对目录的查询时间</p>
</li>
<li><p>选取好的文件存储结构，以提高对文件访问速度</p>
</li>
<li><p>提高磁盘I/O速度。</p>
</li>
</ol>
</li>
</ol>
<h1 id="组成原理"><a href="#组成原理" class="headerlink" title="组成原理"></a>组成原理</h1><ol>
<li><p>冯·诺伊曼计算机结构的主要特点：</p>
<ol>
<li>计算机由运算器、控制器、存储器、输入设备和输出设备5大部分组成</li>
<li>指令和数据用二进制表示，两者形式上没有差别。</li>
<li>指令和数据存放在存储器中，按地址访问</li>
<li>指令由操作码和地址码组成，操作码指定操作性质，地址码指定操作数地址</li>
<li>采用”存储程序”方式进行工作</li>
</ol>
</li>
<li><p>计算机系统层次结构</p>
</li>
<li><p>指令和数据均以二进制形式存放在存储器中，计算机如何区分？</p>
<p> 时间上说，在取指周期取的是指令，在执行周期取的是数据；<br />空间上说，指令存放在指令寄存器，数据存放在通用寄存器；<br />并且，指令地址在PC中存放，数据地址在指令的地址字段。</p>
</li>
<li><p>控制器设计的两种方式及其各自特点 </p>
<ol>
<li>微程序控制器：微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出，执行速度慢，较规整，应用于CISC，易扩充和修改。指令添加容易，可维护性好。</li>
<li>硬布线控制器：微操作控制信号由组合逻辑电路根据当前指令码、状态和时序即时产生，执行速度快，繁琐不规整，应用于RISC，难易扩充，可维护性差。</li>
</ol>
</li>
<li><p>计算机调用中断服务程序与调用子程序有何区别</p>
<ol>
<li>中断程序：随机的，和主程序有关，从隐指令中取得中断服务地址</li>
<li>子程序：预先设计好的，为主程序服务，由调用服务给出地址。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>829专业课</tag>
        <tag>操作系统</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>重学C++</title>
    <url>/2022/08/18/%E9%87%8D%E5%AD%A6C/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul>
<li><p>C++语言的优点，缺点，和主要用途？</p>
<ul>
<li>优点：<ul>
<li>强大的封装抽象能力，强大的开发工程的能力</li>
<li>高性能，运行快，占用资源少</li>
<li>低功耗，特别适合微型嵌入式</li>
</ul>
</li>
<li>缺点<ul>
<li>语法相对复杂、细节较多</li>
<li>需要一些好的规范和范式，否则代码难以维护</li>
</ul>
</li>
<li>主要用途<ul>
<li>大型桌面应用程序</li>
<li>大型网站后台</li>
<li>游戏和游戏引擎</li>
<li>视觉库和AI引擎</li>
<li>数据库</li>
<li>自动驾驶系统、嵌入式设备等</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象和面向过程的优缺点</p>
<p>面向过程</p>
<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 </li>
<li>缺点：没有面向对象易维护、易复用、易扩展 </li>
</ul>
<p>面向对象</p>
<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 </li>
<li>缺点：性能比面向过程低 </li>
</ul>
</li>
</ul>
<h2 id="第二章-C-基础语法"><a href="#第二章-C-基础语法" class="headerlink" title="第二章 C++基础语法"></a>第二章 C++基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">位</th>
<th align="left">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 个字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 个字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">4 个字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">signed int</td>
<td align="left">4 个字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">unsigned short int</td>
<td align="left">2 个字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">signed short int</td>
<td align="left">2 个字节</td>
<td align="left">-32768 到 32767</td>
</tr>
<tr>
<td align="left">long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">signed long int</td>
<td align="left">8 个字节</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td align="left">unsigned long int</td>
<td align="left">8 个字节</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">4 个字节</td>
<td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">8 个字节</td>
<td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">16 个字节</td>
<td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">2 或 4 个字节</td>
<td align="left">1 个宽字符</td>
</tr>
</tbody></table>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th>asm</th>
<th>else</th>
<th>new</th>
<th>this</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>enum</td>
<td>operator</td>
<td>throw</td>
</tr>
<tr>
<td>bool</td>
<td>explicit</td>
<td>private</td>
<td>true</td>
</tr>
<tr>
<td>break</td>
<td>export</td>
<td>protected</td>
<td>try</td>
</tr>
<tr>
<td>case</td>
<td>extern</td>
<td>public</td>
<td>typedef</td>
</tr>
<tr>
<td>catch</td>
<td>false</td>
<td>register</td>
<td>typeid</td>
</tr>
<tr>
<td>char</td>
<td>float</td>
<td>reinterpret_cast</td>
<td>typename</td>
</tr>
<tr>
<td>class</td>
<td>for</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>const</td>
<td>friend</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>const_cast</td>
<td>goto</td>
<td>signed</td>
<td>using</td>
</tr>
<tr>
<td>continue</td>
<td>if</td>
<td>sizeof</td>
<td>virtual</td>
</tr>
<tr>
<td>default</td>
<td>inline</td>
<td>static</td>
<td>void</td>
</tr>
<tr>
<td>delete</td>
<td>int</td>
<td>static_cast</td>
<td>volatile</td>
</tr>
<tr>
<td>do</td>
<td>long</td>
<td>struct</td>
<td>wchar_t</td>
</tr>
<tr>
<td>double</td>
<td>mutable</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>namespace</td>
<td>template</td>
<td></td>
</tr>
</tbody></table>
<h3 id="命名建议：变量名尽量使用“名词”或“形容词-名词”；函数名用“动词-名词”。原则上长度不超过32位"><a href="#命名建议：变量名尽量使用“名词”或“形容词-名词”；函数名用“动词-名词”。原则上长度不超过32位" class="headerlink" title="命名建议：变量名尽量使用“名词”或“形容词+名词”；函数名用“动词+名词”。原则上长度不超过32位"></a>命名建议：变量名尽量使用“名词”或“形容词+名词”；函数名用“动词+名词”。原则上长度不超过32位</h3><h3 id="常用命名规则"><a href="#常用命名规则" class="headerlink" title="常用命名规则"></a>常用命名规则</h3><ol>
<li>匈牙利命名法：开头字母用变量类型缩写后面用变量的英文或缩写</li>
<li>Camel命名法：首单词小写，后面单词首字母大写</li>
<li>Pascal命名法：每个单词第一个字母都大写</li>
</ol>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><ol>
<li><p>常量：在程序运行过程中，值一直保持不变的量</p>
<ul>
<li><p>定义方法</p>
<ul>
<li>使用<code>#define </code>方式 <code>#define PI 3.1415</code></li>
<li>使用<code> const</code>方式 <code>const double PI = 3.1415</code></li>
</ul>
<p>使用const定义常量可以在编译时检查出错误。而define只是宏定义，难以排错</p>
</li>
<li><p>常量类型</p>
<ul>
<li>整数常量：可以是十进制、八进制或十六进制的常量。</li>
</ul>
<p><strong>前缀</strong>指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p><strong>后缀</strong>是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。</p>
<ul>
<li>浮点常量</li>
</ul>
<p>小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。</p>
<p>指数形式表示时， 必须包含小数点、指数，或同时包含两者。e后面指定指数</p>
<ul>
<li>布尔常量</li>
<li>字符常量</li>
</ul>
<p>如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。</p>
</li>
</ul>
</li>
</ol>
<h2 id="第三章-C-运算符与表达式"><a href="#第三章-C-运算符与表达式" class="headerlink" title="第三章 C++运算符与表达式"></a>第三章 C++运算符与表达式</h2><p><strong>运算符</strong>：告诉编译器执行特定数学或逻辑操作的符号。（算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、杂项运算符）</p>
<p><strong>表达式</strong>：使用运算符将操作数连接而成的式子，每一个表达式都有自己的值，表达式都有运算结果</p>
<p><strong>注释的建议</strong>：</p>
<ol>
<li>好的命名和代码本身就是最好的注释；如果代码本身很清楚，不需要额外加注释。</li>
<li>在重要代码段、或复杂代码处先写注释再写代码，这样思路更清晰，同时可以保证代码和注释的一致性。</li>
<li>注释不是越多越好，它是对代码的提示，如果要写就写清楚，并且保证和代码一致。如果更新的代码，清更新相应的注释。</li>
</ol>
<p><strong>补码</strong>：<br>  有符号数另一种计算方式：<img src="https://cdn.staticaly.com/gh/konsin/images@main/image.7ka0cc9pftg0.jpg" alt="image"><br>  常用计算方式：正数不变；复数 符号位不变，其余位取反，最后加1</p>
<p><strong>大端方式</strong> 数字高位在低地址<br><strong>小段方式</strong> 数字低位在低地址</p>
<h2 id="第四章-C-基础容器"><a href="#第四章-C-基础容器" class="headerlink" title="第四章 C++基础容器"></a>第四章 C++基础容器</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>概念：代表内存里一组连续的同类型存储区；可以用来把多个存储区合并成一个整体<br>C语言中数组下标：从0开始，使用非对称区间<code>[,)</code>，下届可以取到值，上界取不到值。<br>   好处：<br>      1. 取值范围的大小：上界 - 下届；<br>      2. 如果这个取值范围为空， 上界值 == 下界值<br>      3. 即使取值范围为空，上界值永远不可能小于下界值。<br>使用：</p>
<ol>
<li>通过下下标可以直接访问任意一个元素</li>
<li>下标从0开始到元素个数减一为止</li>
<li>超过范围的下标不可以使用</li>
<li>数组名称和下标可以表示数组里的元素</li>
</ol>
<p>优点：</p>
<ol>
<li>可以编写循环依次处理数组里的所有元素</li>
<li>循环变量依次代表所有有效下标</li>
</ol>
<p><strong>差一错误</strong>：high - low + 1</p>
<h3 id="vector数组"><a href="#vector数组" class="headerlink" title="vector数组"></a>vector数组</h3><p><code>#include &lt;vector&gt;</code><br>引入原因：使用最简单的数组，无法实现动态扩容插入元素，因为容量有限。</p>
<ul>
<li>查询大小：<code>s.size()</code></li>
<li>查询容量：<code>s.capacity()</code></li>
<li>使用sort对vector排序<br><code>sort(num.begin(), num.end());</code></li>
<li>插入数据的方式<br>尾插 <code>push_back(val)</code><br>尾删 <code>pop_back()</code><br>插入 <code>insert()</code><br>删除 <code>erase()</code><br>清空 <code>clear()</code></li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>定义方式</strong>：<br>  <code>char str[] = &#123;&quot;hello&quot;&#125;</code><br>  <code>char str[6] = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;</code><br><strong>字符串变量</strong>：</p>
<ul>
<li>字符串是以空字符(‘\0’)结束的字符数组</li>
<li>空字符 ‘\0’自动添加到字符串的内部表示中</li>
</ul>
<p><strong>字符串常量</strong>：</p>
<ul>
<li>字符串常量是一对双引号括起来的字符串数组</li>
<li>字符串中每个字符作为一个数组元素存储</li>
</ul>
<p><strong>Unicode编码</strong>：目的-&gt;把世界上的文字都映射到一套字符空间中</p>
<ol>
<li>UTF-8：1byte表示字符，可以兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（可作为外部编码）</li>
<li>UTF-16：分为UTF-16BE（big endian）、UTF-16LE(little endian)。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）</li>
<li>UTF-32：分为UTF-32BE、UTF-32LE。特点是定长（方便内部随机访问），有字节序问题（不可作为外部编码）</li>
</ol>
<p><strong>字符串指针</strong>：</p>
<ul>
<li>指针表示方法： <code>char* pStr = &quot;hello&quot;;</code></li>
<li>char[] 和 char* 的区别：<ul>
<li>地址和地址存储的信息</li>
<li>可变与不可变。<br>如果数组指针初始化指向字符串常量，那么这个指针所指内容不可发生改变。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *ps = <span class="string">&quot;hello&quot;</span>;  <span class="comment">//字符串常量指针</span></span><br><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> *ps2 = s;       <span class="comment">//字符串变量指针</span></span><br></pre></td></tr></table></figure>
s不可变，s[i]的值可变；<br>ps可变，ps[i]的值可不可变取决于所指区间的存储区域是否可变。</li>
</ul>
</li>
</ul>
<p><strong>常见操作</strong>：<br>  <code>strlen(s)</code>：返回s的长度<br>  <code>strcmp(s1, s2)</code>: 自左到右按ASCII值大小比较 s1 == s2 返回 0； s1 &lt; s2 返回 -； s1 &gt; s2 返回+；<br>  <code>strcpy(s1, s2)</code>: 复制s2到s1；<br>  <code>strncpy(s1, s2, n)</code> 将字符串s2中前n个字符拷贝到s1中<br>  <code>strcat(s1, s2)</code> 将字符串s2接到s1后面<br>  <code>strchr(s1,ch)</code> 查找ch在s1中第一次出现位置<br>  <code>strstr(s1, s2)</code> 查找s2在s1中第一次出现位置。</p>
<h3 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h3><p><code>#include &lt;string&gt;</code><br>使用string可以更为方便和安全的管理字符串。<br>定义：<code>string s</code>; <code>string s = &quot;hello&quot;</code>; <code>string s(&quot;hello&quot;)</code>; <code>string s = string(&quot;hello&quot;)</code>;<br><strong>常用操作</strong></p>
<ul>
<li>获取长度：<ul>
<li><code>s.length()</code> </li>
<li><code>s.size()</code></li>
<li><code>s.capacity()</code> 容量 != 长度</li>
</ul>
</li>
<li>字符串比较：<code>==</code> <code>!=</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></li>
<li>转换为C风格字符串 char*<br><code>const char *c_s = s.c_str(); </code></li>
<li>可通过下标进行随机访问。</li>
<li>可通过<code>=</code>进行字符串拷贝</li>
<li>可通过<code>+</code>、<code>+=</code>连接字符串</li>
</ul>
<h2 id="第五章-指针"><a href="#第五章-指针" class="headerlink" title="第五章 指针"></a>第五章 指针</h2><p>指针的缺点：使用指针是非常危险的行为，可能存在空指针，野指针的问题，并可能造成内存泄漏问题。<br>优点：指针非常的高效<br><strong>C++中内存单元内容与地址</strong><br>指针的本质：内存划分内存单元用来存放各种类型的数据。计算机对内存单元进行编号，称为内存地址，决定内存单元在内存中的位置。C++编译器让我们通过名字来访问这些内存位置。<br>指针定义的基本形式： 指针本身就是一个变量，其符合变量定义的基本形式，存储的是值的地址。对类型T，T*是‘到T的指针’类型。通过一个指针访问所指向地址的过程称为间接访问或引用指针。<br>  小结：</p>
<ol>
<li>一个变量有三个重要信息：<ol>
<li>变量的地址位置</li>
<li>变量所存的信息</li>
<li>变量的类型</li>
</ol>
</li>
<li>指针变量是一个专门用来记录变量的地址的变量，通过指针变量可以间接的访问改变另一个变量的值<h3 id="C-中原始指针"><a href="#C-中原始指针" class="headerlink" title="C++中原始指针"></a>C++中原始指针</h3></li>
<li>一般类型指针T*</li>
<li>指针的数组与数组的指针<br>指针的数组 T* t[]<br>数组的指针 T (*t)[]</li>
<li>const pointer 和 pointer to const<br><code>char const</code> 和 <code>const char</code> 是等价的。<br>看const修饰部分：<ul>
<li>看左侧最近的部分</li>
<li>如果左侧没有则看右侧</li>
</ul>
</li>
<li>指向指针的指针<br><code>*</code>操作符具有从右向左的结合性<br><code>**</code>表达式相当于<code>*(*c)</code>，必须从里向外逐层求值</li>
<li>未初始化和非法的指针<br>如果定义到了一个非法地址，程序会出错，从而终止。<br>如果定位到一个可以访问的地址，无意修改了它，这种错误难以捕捉，引发的错误可能与原先用于操作的代码完全不相干。</li>
<li>NULL指针<br>一个特殊的指针，表示不指向任何东西。这种方法来表示特定的指针目前未指向任何东西<br>注意事项：<br>对应于一个指针如果已经知道被初始化为什么地址，如果不赋值就设置为NULL<br>引用指针前先判断是否为NULL</li>
</ol>
<p><strong>杜绝野指针</strong><br>if等判断对野指针不起作用，因为没有置NULL<br>一般有三种情况：</p>
<ol>
<li>指针变量没有初始化</li>
<li>已经释放不用的指针没有置NULL，如delete和free之后的指针</li>
<li>指针操作超越了变量的作用范围。</li>
</ol>
<p>没有初始化的，不用的或者超出范围的指针把值置为NULL</p>
<h3 id="指针的基本运算"><a href="#指针的基本运算" class="headerlink" title="指针的基本运算"></a>指针的基本运算</h3><ol>
<li><code>&amp;</code>与<code>*</code>操作符<br><code>&amp;ch</code>取出来的是地址<br><code>*cp</code>为右值时是指向地址的内容，为左值时为指针。<pre><code> `*CP+1`左值非法，`*(cp+1)`为下一位指针对应的
</code></pre>
</li>
<li><code>++</code>与<code>--</code>操作符</li>
<li>关于<code>++++</code>与<code>----</code>等运算符<br>编译程序分解成符号的方法是：一个字符一个字符的读入，如果该字符可能组成一个符号，那么读入下一个字符，一直到读入的字符不能再组成一个有意义的符号。 a+++b 相当于 a++ +b</li>
</ol>
<h3 id="CPP程序存储区域划分"><a href="#CPP程序存储区域划分" class="headerlink" title="CPP程序存储区域划分"></a>CPP程序存储区域划分</h3><p>全局变量、常量在常量区，变量在栈区，动态申请变量在堆区。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/5-11-CPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E6%80%BB%E7%BB%93-00_05_34-2022_09_20_14_23_02-(2).6mgazj6rwp00.jpg" alt="5-11-CPP程序的存储区域划分总结-00_05_34-2022_09_20_14_23_02-(2)"></p>
<ol>
<li>栈和队列<br>栈：先进后出<br>队列：先进先出</li>
<li>动态分配资源-堆（heap）<br>程序通常需要牵涉到三个内存管理器的操作：<ol>
<li>分配某个大小的内存块；</li>
<li>释放一个之前分配的内存块；</li>
<li>垃圾收集操作，寻找不再使用的内存块并予以释放。（这个回收策略需要实现性能、实时性、额外开销等各方面的平衡，很难有统一和高效的做法）<br>C++做了1、2，Java做了1、3。</li>
</ol>
</li>
</ol>
<h3 id="资源管理方案–RAII-Resource-Acquisition-Is-Initialization"><a href="#资源管理方案–RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="资源管理方案–RAII(Resource Acquisition Is Initialization)"></a>资源管理方案–RAII(Resource Acquisition Is Initialization)</h3><ol>
<li>主流的编程语言中，C++是唯一一个依赖RAII做资源管理的。</li>
<li>RAII依托<strong>栈</strong>和<strong>析构函数</strong>，来对所有的资源——包括堆内存在内进行管理。对RAII的使用，使得C++不需要类似Java那样的垃圾收集方法也能有效地对内存进行管理。</li>
<li>RAII有些比较成熟的智能指针代表：<code>std::auto_ptr</code>、<code>boost::shared_ptr</code></li>
</ol>
<h3 id="C-中几种变量对比"><a href="#C-中几种变量对比" class="headerlink" title="C++中几种变量对比"></a>C++中几种变量对比</h3><p>栈和堆中的变量对比<br>| | 栈区| 堆区|<br>|:————|:————|:————–|<br>|作用域|函数体内，语句块{}作用域|整个程序范围内，由<code>new</code>,<code>malloc</code>开始，<code>delete</code>、<code>free</code>结束|<br>|编译间大小确定|变量大小范围确定|变量大小不确定，需要运行期确定|<br>|大小范围|Windows默认栈大小1M，linux默认栈大小8M或10M|所有系统的堆空间上限是接近内存（虚拟内存）的总大小的|<br>|内存分配方式|地址由高到低减少|地址由低到高增加|<br>|内容是否可变|可变|可变|<br>全局静态存储区和常量存储区的变量对比<br>||全局静态存储区|常量存储区|<br>|:-|:-|:-|<br>|存储内容|全局变量，静态变量|常量|<br>|编译期间大小是否确定|确定|确定|<br>|内容是否可变|可变|不可变|</p>
<h3 id="内存泄漏（Memory-Leak）问题"><a href="#内存泄漏（Memory-Leak）问题" class="headerlink" title="内存泄漏（Memory Leak）问题"></a>内存泄漏（Memory Leak）问题</h3><ol>
<li>什么是内存泄漏问题：<br>指程序中已动态分配的<strong>堆内存由于某种原因程序未释放或无法释放</strong>，造成系统内存的浪费，导致<strong>程序运行速度减慢甚至系统崩溃等严重后果</strong>。</li>
<li>内存泄漏发生原因和排查方式：<ol>
<li>内存泄漏主要发生在<strong>堆内存分配方式</strong>中，即“配置了内存后，所有指向该内存的指针都遗失了”。若缺乏语言这样的垃圾回收机制，这样的内存片就无法归还系统。</li>
<li>因为内存泄漏属于程序运行中的问题，无法通过编译识别，<strong>所以只能在程序运行过程中来判别和诊断</strong>。<br>比指针更安全的解决方案</li>
</ol>
</li>
<li>使用更安全的指针-智能指针</li>
<li>不使用指针，使用更安全的方式-引用</li>
</ol>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++中四种常用智能指针: unique_ptr、shared_ptr、weak_ptr、在C++17中已经废弃的auto_ptr</p>
<ol>
<li><code>auto_ptr</code><br>由<code>new expression</code>获取对象，在<code>auto_ptr</code>对象销毁时，其所管理的对象也会自动被<code>delete</code>掉。<br>所有权转移：不小心把它传递给另外的智能指针，原来的指针就不再拥有这个对象了。在拷贝/赋值过程中，会直接剥夺指针对原对象内存的控制权，转交给新对象，然后再将**原对象指针置为<code>nullptr</code>**。<br><code>auto_ptr&lt;int&gt; pl(new int(10))</code></li>
<li><code>unique_ptr</code><br><code>unique_ptr</code>是<strong>专属所有权</strong>，所以<code>unique_ptr</code>管理的内存，只能被一个对象持有，不支持复制和赋值。<br>移动语义：<code>unique_ptr</code>禁止了拷贝语义，但是可以使用 <code>std::move()</code>进行控制所有权的转移。</li>
<li><code>shared_ptr</code><br><code>shared_ptr</code><strong>通过一个引用计数共享一个对象</strong>，<code>shared_ptr</code>是为了解决<code>auto_ptr</code>在对象所有权上的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针。因为引入了引用计数，所以造成了额外的资源浪费，不如<code>unique_ptr</code>轻量。<br>当引用计数为0时，说明对象没有被使用，可以析构。<br>问题：<br>循环引用：引用计数会带来循环引用的问题，循环引用会导致堆里的内存无法正常回收，造成内存泄漏。</li>
<li><code>weak_ptr</code><br><strong><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作</strong>，用一种观察者模式工作。<br>意味着<code>weak_ptr</code>只对<code>shared_ptr</code>进行引用而不改变其引用计数。</li>
</ol>
<h3 id="C-的引用"><a href="#C-的引用" class="headerlink" title="C++的引用"></a>C++的引用</h3><p>引用是一种特殊的指针，不允许修改的指针。<br>：1. 不存在空引用；2. 必须初始化； 3. 一个引用永远指向它初始化的那个对象。</p>
<ol>
<li>引用的基本使用：可以认为值指定变量的别名，使用时可以认为是变量本身。<br><code>int&amp; rx = x</code>, <code>cout &lt;&lt; rx; </code>等同于<code>cout &lt;&lt; x;</code></li>
<li>有了指针为什么还需要引用？ 为了支持函数运算符重载。</li>
<li>有了引用为什么还需要指针？ 为了兼容C语言。</li>
</ol>
<p>对内置基础类型（int、double等)而言，在函数中传值（pass by value）更高效。<br>对OO面向对象中自定义类型而言，在函数中传引用(pass by reference to const)更高效。</p>
<h2 id="第六章-C-基础句法"><a href="#第六章-C-基础句法" class="headerlink" title="第六章 C++基础句法"></a>第六章 C++基础句法</h2><p>单一语句： 在任何一个表达式后面加上分号<code>;</code><br>复合语句：用一对花括号<code>&#123;&#125;</code>括起来的语句块，在语法上等效于一个单一的语句。</p>
<h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><ol>
<li><p><code>if</code>语句<br>if语句是最常用的一种分支语句，也称为条件语句。<br>（比较好的编程规范是if的花括号不允许不写，即使只是一个单一语句）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>switch</code>语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 常数<span class="number">1</span>: 语句<span class="number">1</span>;  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常数<span class="number">2</span>: 语句<span class="number">2</span>;  <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> 常数n: 语句n;  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: 语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举结构"><a href="#枚举结构" class="headerlink" title="枚举结构"></a>枚举结构</h3></li>
<li><p>使用<code>#define</code>和const创建符号常量，而使用enum不仅能够创建符号常量，还能<strong>定义新的数据类型</strong>。</p>
</li>
<li><p>枚举类型enum(enumeration)的声明和定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">wT</span> &#123;</span><br><span class="line"> Monday, Tuesday, Wednesday, Tursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;; <span class="comment">//声明枚举类型</span></span><br><span class="line">wT weekday; <span class="comment">//定义枚举变量</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体和联合体"><a href="#结构体和联合体" class="headerlink" title="结构体和联合体"></a>结构体和联合体</h3></li>
<li><p><code>struct</code>定义结构体<br>各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> name[<span class="number">6</span>];</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   Score s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>union</code>定义联合体<br>各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。<br>联合体的内存大小：1、至少要容纳最大的成员变量 2、必须是所有成员变量类型大小的整数倍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Score</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">double</span> sc;</span><br><span class="line"> <span class="type">char</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>结构体中内存对齐问题</strong>：综合考虑内存对数据的处理及最大的数据类型所占字节<br>   缺省对齐原则：<br>   32位cpu：</p>
<ul>
<li>char: 任何地址</li>
<li>short: 偶数地址</li>
<li>int: 4的整数倍地址</li>
<li>double： 4的整数倍地址<br>可以修改默认编译选项,设置内存按n字节寻址<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Visual C++：</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//g++:</span></span><br><span class="line">__attribute__(<span class="built_in">aligned</span>(n))</span><br><span class="line">__attribute__(__packed__)</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3></li>
</ul>
<ol>
<li>while循环</li>
<li>do while循环</li>
<li>for循环</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数将一段逻辑封装起来便于复用。一个C++程序是由若干个源程序文件构成，而一个源程序是由若干函数构成。</p>
<ol>
<li>函数组成部分：<ul>
<li>返回类型：一个函数可以返回一个值。</li>
<li>函数名称：是函数的实际名称，函数名和参数列表一起构成了函数签名。(SDK提供的<code>undname.exe</code>程序的作用就是为我们还原函数签名。)</li>
<li>参数</li>
<li>函数主体：函数主题包含一组定义函数执行任务的语句。</li>
</ul>
</li>
<li>函数重载overload 与C++ Name Mangling：相同函数名称然后不同参数则是不同的函数。<br><code>int test(int a);</code>、<code>int test(double a);</code></li>
<li>指向函数的指针与返回指针的函数<br>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。</li>
</ol>
<ul>
<li>一般形式：数据类型(*指针变量名)(参数表)； 如<code>int(*p)(int);</code></li>
<li>与返回指针的函数之间的区别：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(*p)(<span class="type">int</span>); <span class="comment">//是指针，指向一个函数入口地址</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//是函数，返回的值是一个指针</span></span><br></pre></td></tr></table></figure>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3>命名空间这个概念可作为附加信息来区分不同库中相同名称的函数、类、变量等，命名空间即定义了上下文。<br>本质上，命名空间就是定义了一个范围。</li>
<li>定义命名空间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> konsin</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用命名空间，可以再函数内声明这个函数使用的命名空间，也可以全局<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> konsin; <span class="comment">//使用命名空间内所有的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> konsin::test; <span class="comment">//使用命名空间内的test函数</span></span><br><span class="line"></span><br><span class="line">konsin::<span class="built_in">test</span>(a);  <span class="comment">//直接调用命名空间内的test函数</span></span><br></pre></td></tr></table></figure>
<h3 id="内联函数（inline）"><a href="#内联函数（inline）" class="headerlink" title="内联函数（inline）"></a>内联函数（inline）</h3>如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。<br>目的是为了解决程序中函数调用的效率问题。（空间换时间）<br>注意：内联函数内部不能有太复杂的逻辑，编译器有事会有自己的优化策略，内联不一定起作用。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3>递归背后的数学逻辑是数学归纳法。</li>
</ul>
<p>递归四个基本准则：</p>
<ol>
<li>基准情形：无需递归就能解出；</li>
<li>不断推进：每一次递归调用都必须使求解状况朝接近基准情形的方向推进；</li>
<li>设计法则：假设所有的递归调用都能运行；</li>
<li>合成效益法则：求解一个问题的同一个实例时，切勿在不同递归调用中做重复性工作。</li>
</ol>
<p>递归的缺陷:</p>
<ol>
<li>空间上需要开辟大量的栈空间。</li>
<li>时间上可能需要有大量的重复运算。</li>
</ol>
<p>递归的优化：</p>
<ol>
<li>尾递归：所有递归形式的调用都出现在函数的末尾；</li>
<li>使用循环代替</li>
<li>使用动态规划，空间换时间。</li>
</ol>
<h2 id="第七章-C-高级语法"><a href="#第七章-C-高级语法" class="headerlink" title="第七章 C++高级语法"></a>第七章 C++高级语法</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象是软件工程发展到一定阶段为了管理代码和数据提出的一种方法，没有解决以前解决不了的问题，不是万能的。</p>
<p><strong>面向对象三大特性</strong>：封装，继承，多态。</p>
<ol>
<li>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问，封装可以使得代码模块化。</li>
<li>继承性：让某种类型对象获得另一个类型对象的属性和方法，继承可以扩展已存在的代码。</li>
<li>多态性：同一事物表现出不同事物的能力，即面向不同对象会产生不同的行为，多态的目的则是为了接口重用。</li>
</ol>
<p><strong>面向对象的误区</strong></p>
<ol>
<li>对象是对现实世界中具体物体的反映，继承是对物体分类的反映？<br>错，类只是一个概念的抽象，而不是对现实世界的反映。</li>
<li>面对变化，尽可能少修改原有的逻辑，要扩充逻辑。</li>
</ol>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>C++使用struct、class来定义一个类，struct的默认成员权限是public，class的默认成员权限是private。<br>成员权限有：public、protected、private。</p>
<ol>
<li><p>构造类Complex <code>class Complex&#123;&#125;</code></p>
</li>
<li><p>构造函数：定义方法<code>Complex();</code>,不需要指定返回值类型。在实例化类对象时会自动调用构造函数创建类对象。系统会自动生成一个无参数的默认构造函数，而手动创建有参数的构造函数之后，则系统不会再去创建默认构造函数，会引起部分情况下错误。因此如果手动创建了构造函数，则也需要手动定义无参数的构造函数。</p>
</li>
<li><p>析构函数：定义方法<code>virtual ~Complex();</code>，不需要指定返回值类型。在销毁对象时自动调用。<br><code>virtual</code>关键字用于实现多态，子类可以重写父类的函数。</p>
</li>
<li><p>运算符重载：<br>如果不需要改变变量的值则需要加<code>const</code>，具体区分看<code>+</code>号重载和<code>=</code>号重载</p>
<ul>
<li>加、减、乘、除符号重载声明：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Complex</span>(ref + x.ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>等号重载声明<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Complex&amp; c) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;c) &#123;</span><br><span class="line">    ref = c.ref;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>++、–重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>++ () &#123;</span><br><span class="line"> 	ref++;</span><br><span class="line"> 	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>++ (<span class="type">int</span>) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">Complex</span>(ref++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>&lt;&lt;、&gt;&gt;流运算符重载。<br>标准流无法直接访问类的private属性，此时可以采用友元来解决。<ul>
<li>友元函数：在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。</li>
<li>友元类：一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。</li>
</ul>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Complex &amp;x) &#123;</span><br><span class="line"> 	os &lt;&lt; <span class="string">&quot;value is  &quot;</span> &lt;&lt; x.ref;</span><br><span class="line"> 	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; is, Complex &amp;x) &#123;</span><br><span class="line"> 	is &gt;&gt; x.ref;</span><br><span class="line"> 	<span class="keyword">return</span> is;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ol>
<li><p>C和C++中I/O流对比：<br>传统的C中I/O有printf、scanf等函数：</p>
<ol>
<li>不可编程，仅仅能识别固有的数据类型</li>
<li>代码可移植性差，有很多的坑。<br>C++中I/O流istream和ostream等：</li>
<li>可编程，对于类库的设计者来说很有用。</li>
<li>简化编程，能使得I/O的风格一致。</li>
</ol>
</li>
<li><p>C++中I/O流类层次结构图</p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">作用</th>
<th align="left">在哪个头文件中声明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios</td>
<td align="left">抽象基类</td>
<td align="left">iostream</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">istream</td>
<td align="left">通用输入流和其他输入流的基类</td>
<td align="left">iostream</td>
</tr>
<tr>
<td align="left">ostream</td>
<td align="left">通用输出流和其他输出流的基类</td>
<td align="left">iostream</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">通用输入</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">iostream</td>
<td align="left">输出流和其他输入输出流的基类</td>
<td align="left">iostream</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">输入文件流类</td>
<td align="left">fstream</td>
</tr>
<tr>
<td align="left">ofstream</td>
<td align="left">输出文件流类</td>
<td align="left">fstream</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">输入输出文件流类</td>
<td align="left">fstream</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">istrstream</td>
<td align="left">输入字符串流类</td>
<td align="left">strstream</td>
</tr>
<tr>
<td align="left">ostrstream</td>
<td align="left">输出字符串流类</td>
<td align="left">strstream</td>
</tr>
<tr>
<td align="left">strstream</td>
<td align="left">输入输出字符串流类</td>
<td align="left">strstream</td>
</tr>
</tbody></table>
</li>
<li><p>IO缓存区<br>标准IO提供三种类型的缓存模式：</p>
<ol>
<li>按块缓存：如文件系统</li>
<li>按行缓存：\n</li>
<li>不缓存。</li>
</ol>
</li>
<li><p>IO流的奇技淫巧<br>使用IO流可以灵活的转换字符串为数或数转为字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>      <span class="comment">// std::stringstream</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="number">100</span>;</span><br><span class="line">  <span class="type">int</span> foo,bar;</span><br><span class="line">  ss &gt;&gt; foo;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foo: &quot;</span> &lt;&lt; foo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>IO格式化输出 iomanip库<br>ipmanip库也包含了</p>
<table>
<thead>
<tr>
<th align="left">流操纵算子</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setbase(b)</td>
<td align="left">以进制基数 b 为输出整数值</td>
</tr>
<tr>
<td align="left">setprecision(n)</td>
<td align="left">将浮点精度设置为 n</td>
</tr>
<tr>
<td align="left">setiosflags(long)</td>
<td align="left">设置特定的格式标志位</td>
</tr>
<tr>
<td align="left">setw(n)</td>
<td align="left">按照 n 个字符来读或者写</td>
</tr>
<tr>
<td align="left">setfill(ch)</td>
<td align="left">用 ch 填充空白字符</td>
</tr>
<tr>
<td align="left">flush</td>
<td align="left">刷新 ostream 缓冲区</td>
</tr>
<tr>
<td align="left">ends</td>
<td align="left">输出空字符</td>
</tr>
<tr>
<td align="left">endl</td>
<td align="left">输出换行符并刷新 ostream 缓冲区</td>
</tr>
<tr>
<td align="left">ws</td>
<td align="left">跳过空白字符（用于输入）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">标志值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::skipws</td>
<td align="left">在输入中跳过空白</td>
</tr>
<tr>
<td align="left">ios::left</td>
<td align="left">左对齐，用填充字符填充右边。</td>
</tr>
<tr>
<td align="left">ios::right</td>
<td align="left">右对齐，用填充字符填充左边(缺省对齐方式)。</td>
</tr>
<tr>
<td align="left">ios::dec</td>
<td align="left">以基 10（十进制）格式化数值（缺省进制）</td>
</tr>
<tr>
<td align="left">ios::oct</td>
<td align="left">以基 8（八进制）格式化数值</td>
</tr>
<tr>
<td align="left">ios::hex</td>
<td align="left">以基 16（十六进制）格式化数值</td>
</tr>
<tr>
<td align="left">ios::showbase</td>
<td align="left">以 C++ 编译器能读的格式显示数值常量</td>
</tr>
<tr>
<td align="left">ios::showpoint</td>
<td align="left">按精度把后面的空白补 0 输出</td>
</tr>
<tr>
<td align="left">ios::uppercase</td>
<td align="left">对于十六进制数值显示大写字母 A 到 F，对于科学格式显示大写字母 E。</td>
</tr>
<tr>
<td align="left">ios::showpos</td>
<td align="left">对于正数显示正号（+）</td>
</tr>
<tr>
<td align="left">ios::scientific</td>
<td align="left">以科学格式显示浮点数值</td>
</tr>
<tr>
<td align="left">ios::fixed</td>
<td align="left">以定点格式显示浮点数值</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol>
<li>文件操作步骤<ol>
<li>打开文件用于读和写 open；<br>文件打开方式：<ul>
<li>ios::in 打开文件进行读操作（ifstream默认模式）</li>
<li>ios::out 打开文件进行写操作（ofstream默认模式）</li>
<li>ios::ate 打开一个已有输入或输出文件并查找到文件尾</li>
<li>ios::app 打开文件以便再文件尾部添加数据</li>
<li>ios::nocreate 如果文件不存在则打开失败</li>
<li>ios::trunc 如果文件存在，清除文件原有内容</li>
<li>ios::binary 以二进制方式打开<br><code>fstrream f;</code>、 <code>f.open(&quot;x.text&quot;, ios::app | ios::binary);</code>。</li>
</ul>
</li>
<li>检查打开是否成功 fail；<br><code>if(!f)</code> 或者 <code>if(f.fail)</code></li>
<li>读或者写 read，write；<br><code>streamsize count = f.gcount();</code>获取读取到数据大小 。</li>
<li>检查是否读完 EOF (end of file)；<br><code>while (!f.eof())</code></li>
<li>使用完文件后关闭文件 close;<br><code>f.close();</code></li>
</ol>
</li>
</ol>
<h3 id="头文件重复包含问题"><a href="#头文件重复包含问题" class="headerlink" title="头文件重复包含问题"></a>头文件重复包含问题</h3><p>避免同一个文件被include多次的方式：</p>
<ol>
<li>使用宏来防止同一文件被多次包含<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line">···</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
优点：可移植性好；<br>缺点：无法防止宏名重复，难以排错。</li>
<li>使用编译器来防止同一文件被多次包含<br><code>#pragma once</code><br>优点：可以防止宏名重复，易排错。<br>缺点：可移植性不好。</li>
</ol>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：只拷贝指针地址，C++默认拷贝构造函数与赋值运算符重载都是浅拷贝。节省空间，但容易引发多次释放。<br>深拷贝：<strong>重新分配堆内存</strong>，拷贝指针指向内容。浪费空间，但不会导致多次释放。</p>
<h2 id="第八章-C-编程思想9"><a href="#第八章-C-编程思想9" class="headerlink" title="第八章 C++编程思想9"></a>第八章 C++编程思想9</h2><h3 id="软件的设计模式"><a href="#软件的设计模式" class="headerlink" title="软件的设计模式"></a>软件的设计模式</h3><p>一个模式描述了一个不断发生的问题及这个问题的解决方案；模式是前人的设计经验上总结出来的对于一些普遍存在的问题提供的通用解决方案。<br>23种面向对象可复用设计模式。</p>
<ol>
<li><strong>单例模式</strong><br>整个程序中有且只有一个实例。便于访问控制和维护。</li>
</ol>
<p>实现思路：<br>      1. Singleton拥有一个私有构造函数，确保用户无法通过new直接实例它；<br>      2. 包含一个静态私有成员变量<code>instance</code>与静态公有方法<code>instance()</code>；</p>
<p>实现样例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	<span class="keyword">if</span> (!This)</span><br><span class="line">   	&#123;</span><br><span class="line">   		This = <span class="keyword">new</span> Singleton;</span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">return</span> This;</span><br><span class="line">   &#125;;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Do Something&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 将构造和析构函数私有化，防止外部访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>();</span><br><span class="line">	~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> Singleton* This; <span class="comment">// 使用静态变量帮助解决资源的分配和释放</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用方法其中的DoSomething()方法：<code>Singleton::getInstance()-&gt;DoSomething();</code><br>不能实例化后再调用，而是通过提供的getInstance方法获取实例。</p>
<ol start="2">
<li><strong>观察者模式</strong><br>观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变事件后，直接接收事件并作出响应，对象常是一对多的关系。 常用于各种MVC框架中，Model的变化通知View。</li>
</ol>
<p>实现思路：将问题的职责解耦合，将Observable和Observer抽象开，分清抽象和实体。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.619ssrb6vm80.webp" alt="image"></p>
<p>在设计观察者模式时要注意以下几点：</p>
<ul>
<li>要明确谁是观察者，谁是被观察者。明白了关注对象，问题也就清楚了；</li>
<li>Observable在发送广播通知时，无须指定具体的Observer，观察者可以自己决定是否要订阅Observable的通知；</li>
<li>被观察者至少有三个方法： 添加监听者、删除监听者和通知监听者；观察者至少有一个方法：更新方法。<br>观察者模式的应用场景如下：</li>
<li>一个对象的数据或状态更新需要其它对象同步更新时；</li>
<li>系统存在事件多级触发时；</li>
<li>一个对象仅需要将自己的更新通知给其它对象而不需要知道其它对象细节时，如消息推送；</li>
<li>跨系统的消息交换场景，如通信过程中的消息队列处理机制。</li>
</ul>
<p>Observer抽象类定义，具体实现由其继承子类实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> OBSEVER_H_1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBSEVER_H_1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Observer</span>() &#123; ; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() &#123; ; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当被观察对象发生变化时，通知被观察者调用这个方法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">void</span>* pArg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>Observable类定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observerable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Observerable</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Observerable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer* pOb)</span></span>;</span><br><span class="line">	<span class="comment">// 反注册观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Observer* pOb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetSomeNews</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">SetChange</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">SetChange</span><span class="params">(string news)</span></span>;   <span class="comment">// 有变化，需要通知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(<span class="type">void</span>* pArg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> _bChange;</span><br><span class="line">	list&lt;Observer*&gt; _Obs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Obseverable类实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Observerable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observerable::<span class="built_in">Observerable</span>():_bChange(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observerable::~<span class="built_in">Observerable</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册观察者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Attach</span><span class="params">(Observer* pOb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pOb == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 看看当前列表中是否有这个观察者</span></span><br><span class="line">	<span class="keyword">auto</span> it = _Obs.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != _Obs.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it == pOb)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Obs.<span class="built_in">push_back</span>(pOb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反注册观察者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Detach</span><span class="params">(Observer* pOb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((pOb == <span class="literal">NULL</span>) || (_Obs.<span class="built_in">empty</span>() == <span class="literal">true</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Obs.<span class="built_in">remove</span>(pOb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::SetChange</span><span class="params">(string news)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_bChange = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Notify</span>( ( (<span class="type">void</span>*)news.<span class="built_in">c_str</span>() ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Notify</span><span class="params">(<span class="type">void</span>* pArg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_bChange == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 看看当前列表中是否有这个观察者</span></span><br><span class="line">	<span class="keyword">auto</span> it = _Obs.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != _Obs.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		(*it)-&gt;<span class="built_in">Update</span>(pArg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_bChange = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>适配器模式（Adapter）<br>适配器将类接口转换为客户端期望的另一个接口。使用适配器可防止类由于接口不兼容而一起工作。适配器模式的动机是，如果可以更改接口，则可以重用现有软件。</li>
</ol>
<ul>
<li>第一种适配的方式：<strong>使用多重继承</strong>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LegacyRectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LegacyRectangle</span>(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LegacyDraw</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter</span>: <span class="keyword">public</span> Rectangle, <span class="keyword">public</span> LegacyRectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RectangleAdapter</span>(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> w, <span class="type">double</span> h) :</span><br><span class="line">		<span class="built_in">LegacyRectangle</span>(x, y, x + w, y + h)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">LegacyDraw</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>第二种方式：组合方式的Adapter<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter</span> :<span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RectangleAdapter2</span>(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> w, <span class="type">double</span> h) :</span><br><span class="line">		_lRect(x, y, x + w, y + h)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_lRect.<span class="built_in">LegacyDraw</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LegacyRectangle _lRect;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong><code>void*</code>,NULL 和 nullptr</strong><br>   在C语言中 <code>#define NULL((void*) 0)</code>，<code>void*</code> 可以转换为任意类型的指针进行传递。<br>   在C++11中，nullptr用来代替<code>(void*) 0</code>，NULL则只表示0。当然如果创建指针时使用NULL，此时NULL则代表空指针。</p>
<p>   C类型转换：</p>
<ol>
<li>隐式类型转换: 存在丢失精度的问题。</li>
<li>显式类型转换：(类型)(表达式)</li>
</ol>
<p>   C++类型转换：</p>
<ol>
<li>const_cast：用于转换指针或引用，去掉const属性。int a = const_cast<int>(b);</li>
<li>reinterpret_cast: 重新解释类型，既不检查指向内容，也不检查指针类型本身。但要求转换前后的类型所占用内存大小一致，否则引发编译时的错误。<strong>不安全的</strong></li>
<li>static_cast: 用于基本类型转换，有继承关系类对象和类指针之间转换。可以替换C的显式类型转换。不会产生动态转换的类型安全检查开销。<code>static_cast&lt;double&gt;(i);</code></li>
<li>dynamic_cast：只能用于含有虚函数的类，必须用在多态体系中，用于类层次间的向上和向下转化；向下转化时，如果是非法的，对于指针返回NULL。（防止向下转换）</li>
</ol>
<h3 id="泛型编程（模板）"><a href="#泛型编程（模板）" class="headerlink" title="泛型编程（模板）"></a>泛型编程（模板）</h3><p>不同于面向对象的动态期多态，泛型编程是一种静态期多态，通过编译器生成最直接的代码；<br>泛型编程可以将算法与特定类型、结构剥离，尽可能复用代码。<br>使用模板类，模板函数实现，<code>template</code>关键字。</p>
<ol>
<li>模板函数示例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于某一数据类型的特例，可以采用特化的方法。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">max</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ?  (a) : (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于模板函数参数不一致的情况，或者固定的返回值情况。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>模板类示例<br>在函数后面加 <code>:_a(a)</code>代表赋值操作，等同于在函数内<code>_a = a;</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TC</span>(T a, T b,  T c);</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">Min</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	T minab = _a &lt; _b ? _a : _b;</span><br><span class="line">	<span class="keyword">return</span> minab &lt; _c ? minab : _c;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T _a, _b, _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">TC&lt;T&gt;::<span class="built_in">TC</span>(T a, T b, T c):</span><br><span class="line">	_a(a), _b(b), _c(c)</span><br><span class="line">&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第九章-C-进阶"><a href="#第九章-C-进阶" class="headerlink" title="第九章 C++进阶"></a>第九章 C++进阶</h2><h3 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h3>STL算法是泛型的，不与任何特定的数据结构和对象绑定，不必在环境类似的情况下重写代码。<br>STL算法可以量身定做，并具有很高的效率。<br>STL可以进行扩充，你可以编写自己的组件，并能与STL标准的组件进行很好的配合。<h4 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h4>序列式容器（Sequence Containers）：其中的元素都是可排序的(ordered),STL提供了<code>vector</code>, <code>list</code>,<code>deque</code>等序列式容器,而<code>stack</code>, <code>queue</code>, <code>priority_queue</code>则是容器适配器;<br>关联式容器(Associative Containers)：每个数据元素都是由一个键(key)和值(Value)组成，当元素被插入到容器时，按其键以某种特定规则放入适当位置;常见的STL关联容器如: <code>set</code>, <code>multiset</code>, <code>map</code>, <code>multimap</code>;</li>
</ol>
<ul>
<li>STL函数 <code>for_each</code>：具有三个参数，（迭代起始位置，迭代终止位置，函数）<br>STL源码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InIt</span>, <span class="keyword">class</span> <span class="title class_">_Fn</span>&gt;</span><br><span class="line"><span class="function">_CONSTEXPR20 _Fn <span class="title">for_each</span><span class="params">(_InIt _First, _InIt _Last, _Fn _Func)</span> </span>&#123; <span class="comment">// perform function for each element [_First, _Last)</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    <span class="keyword">for</span> (; _UFirst != _ULast; ++_UFirst) &#123;</span><br><span class="line">        _Func(*_UFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _Func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 使用方式： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">Display</span> <span class="comment">//定义仿函数,可以通过构造函数的方法传入参数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//重载了括号运算符，等同于直接定义Display函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">for_each( iVector.<span class="built_in">begin</span>(), iVector.<span class="built_in">end</span>(), <span class="built_in">Display</span>() ); <span class="comment">//调用方式</span></span><br></pre></td></tr></table></figure></li>
<li>map使用<ul>
<li>定义及插入方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;string, <span class="type">double</span>&gt; studentSocres;</span><br><span class="line">studentSocres[<span class="string">&quot;LiMing&quot;</span>] = <span class="number">95.0</span>;</span><br><span class="line">studentSocres.<span class="built_in">insert</span>( <span class="built_in">pair</span>&lt;string, <span class="type">double</span>&gt;(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100.0</span>) );</span><br><span class="line">studentSocres.<span class="built_in">insert</span>(map&lt;string, <span class="type">double</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">95.5</span>) );</span><br></pre></td></tr></table></figure></li>
<li>遍历方式，查询方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string, <span class="type">double</span>&gt;::iterator iter;</span><br><span class="line">iter = studentSocres.<span class="built_in">find</span>(<span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">iter-&gt;first;   iter-&gt;second;</span><br><span class="line">for_each(studentSocres.<span class="built_in">begin</span>(), studentSocres.<span class="built_in">end</span>(), <span class="built_in">Display</span>());</span><br><span class="line"><span class="keyword">for</span> (iter = studentSocres.<span class="built_in">begin</span>(); iter != studentSocres.<span class="built_in">end</span>(); iter++);</span><br></pre></td></tr></table></figure>
<h3 id="仿函数（functor）"><a href="#仿函数（functor）" class="headerlink" title="仿函数（functor）"></a>仿函数（functor）</h3>STL仿函数在&lt;functional&gt;头文件内。<br>仿函数主要是为了搭配STL算法使用。<br>函数指针不能满足STL对抽象性的要求，不能满足软件积木的要求，无法和STL其他组件搭配。<br>本质是类重载了一个operator()，创建了一个行为类似函数的对象。看上文<code>Display</code>结构体.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++仿函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SortTF</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="STL算法和lambda表达式"><a href="#STL算法和lambda表达式" class="headerlink" title="STL算法和lambda表达式"></a>STL算法和lambda表达式</h3>常见算法包括：查找、排序和通用算法、排列组合算法、数值算法、集合算法等。STL算法包含于&lt;algorithm&gt;、&lt;numeric&gt;、&lt;functional&gt;。分为：</li>
</ul>
</li>
</ul>
<ol>
<li>非可变序列算法:指不直接修改其所操作的容器内容的算法;</li>
<li>可变序列算法:指可以修改它们所操作的容器内容的算法;</li>
<li>排序算法:包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作;</li>
<li>数值算法:对容器内容进行数值计算;</li>
</ol>
<p><strong>transform()</strong> 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。</p>
<ol>
<li><p>版本一和 for_each() 相似，可以将一个一元函数应用到元素序列上来改变它们的值</p>
</li>
<li><p>第二个版本的 transform() 允许将二元函数应用到两个序列相应的元素上。</p>
<ol>
<li><p>一元函数使用方式<br>共有四个参数：它的前两个参数是定义输入序列的输入迭代器，第 3 个参数是目的位置的第一个元素的输出迭代器，第 4 个参数是一个二元函数。</p>
<p>例： <code>transform(begin(deg_C), end(deg_C), rbegin(deg_F),[](double temp)&#123; return 32.0 + 9.0*temp/5.0; &#125;);</code><br>将函数处理后的deg_C数值保存在deg_F中</p>
</li>
<li><p>二元函数使用方式<br>应用二元函数的这个版本的 transform() 含有 5 个参数：<br>前两个参数是第一个输入序列的输入迭代器。<br>第3个参数是第二个输入序列的开始迭代器，显然，这个序列必须至少包含和第一个输入序列同样多的元素。<br>第4个参数是一个序列的输出迭代器，它所指向的是用来保存应用函数后得到的结果的序列的开始迭代器。<br>第5个参数是一个函数对象，它定义了一个接受两个参数的函数，这个函数接受来自两个输入序列中的元素作为参数，返回一个可以保存在输出序列中的值。</p>
<p>例：<code>transform(ones, ones + 5, twos, results, std::plus&lt;int&gt;());</code> 将one和tow的值相加保存在results中。</p>
</li>
</ol>
</li>
</ol>
<p><strong>lambda表达式</strong>：定义了一个匿名函数，并且可以捕获一定范围内的变量。<br>格式为<code>[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</code>，示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ ](<span class="type">int</span> a)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>bind方法绑定参数</strong><br>在C++14中lambda支持多态，完全可以不用bind方法了。<br><code>#include &lt;functional&gt;</code><br><code>bind1st()</code>和<code>bind2nd()</code>都是把二元函数转化为一元函数，方法是绑定其中一个参数。<br><code>bind1st()</code>是绑定第一个参数。<code>bind2nd()</code>是绑定第二个参数。</p>
<p><code>bind()</code>方法：可以绑定任意个参数<code>bind (Fn&amp;&amp; fn, Args&amp;&amp;... args);</code>具体使用见下文<code>count_if</code><br><code>std::placeholders::_1</code> 占位符位于std命名空间的placeholders命名空间中。其中_1, _2, _3是未指定的数字对象，用于function的bind中。 _1用于代替回调函数中的第一个参数， _2用于代替回调函数中的第二个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> c, <span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> bindFunc3 </span>= <span class="built_in">bind</span>(TestFunc, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1);</span><br><span class="line"><span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;C&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在bind的时候，第一个位置是TestFunc，除了这个，参数的第一个位置为占位符std::placeholders::_2，这就表示，调用bindFunc3的时候，它的第二个参数和TestFunc的第一个参数匹配，以此类推。</p>
<p><strong>查找函数</strong><br><code>count</code>函数查找元素并返回个数。<code>count(begin, end, num)</code><br><code>count_if</code>:可加条件判断。 <code>count_if(numbers, numbers + 6, bind(less&lt;int&gt;(), std::placeholders::_1, 40));</code><br><code>binary_search</code>二分查找：查找元素是否存在。<code>binary_search(arr, arr + len, 9)</code><br><code>search</code>查找子序列：<code>*search(arr, arr + len, iA.begin(), iA.end())</code> 前两个参数指定序列，后两个参数指定子序列。返回一个地址，间接引用得到下标。</p>
<h3 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h3><p>迭代器本质上是一种smater pointer，用于访问顺序容器和关联容器中的元素，相当于容器和操作容器算法之间的中介。<br>按定义方式分类：1. 正向迭代器(iterator); 2. 常量正向迭代器(const_iterator); 3. 反向迭代器(reverse_iterator); 4. 常量反向迭代器(const_reverse_iterator)</p>
<table>
<thead>
<tr>
<th align="left">容器</th>
<th align="left">迭代器功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vector</td>
<td align="left">随机访问</td>
</tr>
<tr>
<td align="left">deque</td>
<td align="left">随机访问</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">双向访问</td>
</tr>
<tr>
<td align="left">set/multiset</td>
<td align="left">双向访问</td>
</tr>
<tr>
<td align="left">map/multimap</td>
<td align="left">双向访问</td>
</tr>
<tr>
<td align="left">stack</td>
<td align="left">不支持迭代器</td>
</tr>
<tr>
<td align="left">queue</td>
<td align="left">不支持迭代器</td>
</tr>
<tr>
<td align="left">priority_queue</td>
<td align="left">不支持迭代器</td>
</tr>
</tbody></table>
<p>使用示例：<code>for (vector&lt;int&gt;:: iteratorit = v.begin(); it != v.end(); it++)</code>。迭代器不支持<code>&lt;</code>、<code>&gt;</code></p>
<h3 id="适配器-adapter"><a href="#适配器-adapter" class="headerlink" title="适配器(adapter)"></a>适配器(adapter)</h3><ol>
<li>stack 堆栈：一种”先进后出”的容器，底层数据结构是使用的deque;</li>
<li>queue 队列：一种”先进先出”的容器，底层数据结构是使用的deque;</li>
<li>priority_queue 优先队列：一种特殊的队列，它能够在队列中进行排序(堆排序)，底层实现结构是vector或者deque;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;  <span class="comment">// 默认是最大值优先</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; pq3; <span class="comment">// 最小值优先</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="空间配置器-allocator"><a href="#空间配置器-allocator" class="headerlink" title="空间配置器(allocator)"></a>空间配置器(allocator)</h3><p>allocator隐藏在其他组件中默默工作，不需要关心。allocator的分析可以体现C++在性能和资源管理上优化思想。是理解STL最先分析的组件。<br>要学很底层再看。。。</p>
<h3 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h3><p>早期C++使用Boost库可以避免重复造轮子，现在？<br><a href="https://www.boost.org/">https://www.boost.org/</a><br><a href="https://www.boost.org/users/download/">https://www.boost.org/users/download/</a></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>NuXMV学习笔记</title>
    <url>/2022/11/03/NuXMV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="smv文件示例"><a href="#smv文件示例" class="headerlink" title="smv文件示例"></a>smv文件示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">MODULE</span> main                                 -- 新建一个模型，名为main</span><br><span class="line"><span class="variable constant_">VAR</span>                                         -- 变量声明</span><br><span class="line">    bit0 : <span class="title function_">counter_cell</span>(<span class="variable constant_">TRUE</span>);              -- bit0是模型counter_cell的实例</span><br><span class="line">    bit1 : <span class="title function_">counter_cell</span>(bit0.<span class="property">carry_out</span>);</span><br><span class="line">    bit2 : <span class="title function_">counter_cell</span>(bit1.<span class="property">carry_out</span>);</span><br><span class="line"><span class="variable constant_">CTLSPEC</span>                                        -- <span class="variable constant_">CTL</span>说明</span><br><span class="line">    <span class="variable constant_">AG</span> <span class="variable constant_">AF</span> bit2.<span class="property">carry_out</span>                    -- <span class="title function_">AG</span>(forall globally),<span class="title function_">AF</span>(forall <span class="keyword">finally</span>),检测bit2.<span class="property">carry_out</span>的结果</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MODULE</span> <span class="title function_">counter_cell</span>(carry_in)               -- 新建一个模型，名为counter_cell</span><br><span class="line"><span class="variable constant_">VAR</span>                                         -- 变量声明</span><br><span class="line">    value : boolean;                        -- 定义变量value,类型为boolean</span><br><span class="line"><span class="variable constant_">ASSIGN</span>                                      -- 指定约束</span><br><span class="line">    <span class="title function_">init</span>(value) := <span class="variable constant_">FALSE</span>;                   -- 初始化value为<span class="variable constant_">FALSE</span></span><br><span class="line">    <span class="title function_">next</span>(value) := value xor carry_in;      -- value下一状态为value和carry_in的异或值</span><br><span class="line"><span class="variable constant_">DEFINE</span>                                      -- 定义声明</span><br><span class="line">    carry_out := value &amp; carry_in;          -- carry_out是value和carry_in的与值</span><br></pre></td></tr></table></figure>

<h2 id="验证CTL"><a href="#验证CTL" class="headerlink" title="验证CTL"></a>验证CTL</h2><blockquote>
<p>nuxmv -int<br>进入nuxmv交互shell。<br>read_model -i xx.smv<br>读取smv文件<br>go<br>初始化验证后端<br>check_ctlspec<br>验证文件中的ctl范式</p>
</blockquote>
<h1 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><blockquote>
<ul>
<li>等宽字体：表示语法类别（非终结符）、</li>
<li><strong>粗体字符</strong> 令牌和字符集成员（终结符）</li>
<li><code>[]</code>表示可选的语法结果</li>
<li><code>|</code>用于分割语法规则中的备选项<br>如果是加粗的符号<code>[]</code>和<code>|</code>就是正常字符。<br>标识符以字母开头且标识符中只能包含 {A-Za-z0-9 $#-}中的字符<br>任何以两个破折号(<code>——</code>)开头并以换行符结尾的字符串都是注释，解析器会忽略它。多行注释以<code>/——</code>开始，以<code>——/</code>结束。</li>
</ul>
</blockquote>
<h3 id="NuXMV保留关键字"><a href="#NuXMV保留关键字" class="headerlink" title="NuXMV保留关键字"></a>NuXMV保留关键字</h3><blockquote>
<p>@F<del>, @O</del>, A, ABF, ABG, abs, AF, AG, array, ASSIGN, at next, at last, AX, bool, boolean, BU, case, Clock, clock, COMPASSION, COMPID, COMPUTE, COMPWFF, CONSTANTS, CONSTARRAY,CONSTRAINT, cos, count, CTLSPEC, CTLWFF, DEFINE, E, EBF, EBG, EF, EG, esac, EX, exp, extend, F, FAIRNESS, FALSE, floor, FROZENVAR, FUN, G, H, IN, in, INIT, init, Integer, integer, INVAR, INVARSPEC, ISA, ITYPE, IVAR, JUSTICE, ln, LTLSPEC, LTLWFF, MAX, max, MDEFINE, MIN, min, MIRROR, mod, MODULE, NAME, next, NEXTWFF, noncontinuous, O, of, PRED, PREDICATES, pi, pow, PSLSPEC, PARSYNTH, READ, Real, real, resize, S, SAT, self, signed, SIMPWFF, sin, sizeof, SPEC, swconst, T, tan, time, time since, time until, toint, TRANS, TRUE, typeof, U, union, unsigned, URGENT, uwconst, V, VALID, VAR, Word, word, word1, WRITE, X, xnor, xor, X~ Y, Y~, Z</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li>Boolean<br>布尔类型由符号值FALSE和TRUE组成。</li>
<li>枚举类型 Enumeration Types<br>enum类型。<br>我们实际上只处理两种枚举类型:符号枚举和整数符号枚举。这些类型是可区分的，并且允许对它们进行不同的操作。<br>纯整数枚举没有必要，布尔类型枚举不被允许。</li>
<li>字类型 Word<br>unsigned word 无符号单词[•]和 signed word 有符号单词[•]类型用于建模位向量(布尔值)，允许按位进行逻辑和算术操作(分别为无符号和有符号)。这些类型可以通过宽度来区分。例如，类型无符号单词[3]表示3位的向量，允许无符号操作，类型有符号单词[7]表示7位的向量，允许有符号操作。<br>当无符号字[N]的值被解释为整数时，所使用的位表示是最受欢迎的，即每个位表示0(位号0)到$2^N−1$(位号N−1)之间的连续2次幂。因此无符号字[N]能够表示0到$2^N−1$的值。<br>有符号词[N]类型的位表示是”二进制补码”，即它与无符号词[N]相同，只是最高位(数字N−1)的值为$−2^{N−1}$。因此，符号词[N]可能的值从$−2^{N−1}$到$2^N−1$。</li>
<li>整型 Integer<br>首先，在某些模型检查引擎和算法中不允许使用整数。其次，目前，整型枚举类型有实现相关的约束，因为整型数只能在$−2^{32}  +1$到$2^{32}−1$的范围内(更准确地说，这些值等价于C/ c++宏INT MIN +1和INT MAX)。</li>
<li>实数 Real<br> 类似于float型</li>
<li>时钟类型Clock<br>时钟类型仅在TTS(2.4)中支持。该类型的域取决于模块的时间域:<ul>
<li>continuous时间域:时钟类型域等价于实类型域;</li>
<li>none 时间域:不能表示时钟类型。</li>
</ul>
</li>
<li>数组类型 Array<br>数组声明时使用索引的下限和上限，以及数组中元素的类型。例如<br><code>array 0..3 of boolean</code><br><code>array 1..8 of array -1..2 of unsigned word[5]</code><br>数组类型与set类型不兼容，即数组元素不能为set类型。</li>
<li>字类型数组 WordArray<br>字数组类型用于为数组建模，数组的大小是有限制的，并使用无符号单词[•]类型指定。数组的元素可以是某种类型的。例如,<br><code>array word[5] of unsigned word[3];</code></li>
<li>整型数组 IntArray<br><code>array integer of integer;</code></li>
<li>集合类型 Set<br>集合类型用于标识表示一组值的表达式。集合有四种类型:boolean set,integer set, symbolic set, integers-and-symbolic set.。set类型的使用方式非常有限。特别是，变量不能为set类型。只有范围常量和联合运算符可以用来创建set类型的表达式，并且只有在、case、(•?•:•)，而assignment1表达式可以具有set类型的立即操作数。</li>
<li>类型顺序<br>integer小于integer -symbolic enum且小于real;符号枚举小于整数和符号枚举，等等。无符号词[•]和有符号词[•]类型不能与任何其他类型比较，也不能相互比较。任何类型都等于它本身。<br>注意，只包含整数的枚举类型为integer。</li>
<li>表达式<ol>
<li>隐式类型转换<br> 在某些表达式中，操作数可以从一种类型转换为与其对应的set类型<br> 在NUXMV中也不再支持隐式整数&lt;-&gt;布尔类型转换，必须使用显式强制转换操作符。</li>
<li>常数表达式<br>常量可以是布尔值、整数、实数、符号、字或范围常量。</li>
<li>基本表达式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">basic_expr ::</span><br><span class="line">   constant -- a constant</span><br><span class="line">   | variable_identifier -- a variable identifier</span><br><span class="line">   | define_identifier -- a define identifier</span><br><span class="line">   | function_call -- a call to a function</span><br><span class="line">   | ( basic_expr )</span><br><span class="line">   | pi -- the pi constant</span><br><span class="line">   | <span class="built_in">abs</span> ( basic expr ) -- absolute value</span><br><span class="line">   | <span class="built_in">max</span> ( basic expr , basic expr ) -- max</span><br><span class="line">   | <span class="built_in">min</span> ( basic expr , basic expr ) -- min</span><br><span class="line">   | <span class="built_in">sin</span> ( basic expr ) -- sin</span><br><span class="line">   | <span class="built_in">cos</span> ( basic expr ) -- cos</span><br><span class="line">   | <span class="built_in">exp</span> ( basic expr ) -- exp</span><br><span class="line">   | <span class="built_in">tan</span> ( basic expr ) -- tan</span><br><span class="line">   | <span class="built_in">ln</span> ( basic expr ) -- ln</span><br><span class="line">   | ! basic_expr -- logical <span class="keyword">or</span> bitwise NOT</span><br><span class="line">   | basic_expr &amp; basic_expr -- logical <span class="keyword">or</span> bitwise AND</span><br><span class="line">   | basic_expr | basic_expr -- logical <span class="keyword">or</span> bitwise OR</span><br><span class="line">   | basic_expr <span class="keyword">xor</span> basic_expr -- logical <span class="keyword">or</span> bitwise exclusive OR</span><br><span class="line">   | basic_expr xnor basic_expr -- logical <span class="keyword">or</span> bitwise NOT exclusive OR</span><br><span class="line">   | basic_expr -&gt; basic_expr -- logical <span class="keyword">or</span> bitwise implication</span><br><span class="line">   | basic_expr &lt;-&gt; basic_expr -- logical <span class="keyword">or</span> bitwise equivalence</span><br><span class="line">   | basic_expr = basic_expr -- equality</span><br><span class="line">   | basic_expr != basic_expr -- inequality</span><br><span class="line">   | basic_expr &lt; basic_expr -- less than</span><br><span class="line">   | basic_expr &gt; basic_expr -- greater than</span><br><span class="line">   | basic_expr &lt;= basic_expr -- less than <span class="keyword">or</span> equal</span><br><span class="line">   | basic_expr &gt;= basic_expr -- greater than <span class="keyword">or</span> equal</span><br><span class="line">   | - basic_expr -- integer <span class="keyword">or</span> real <span class="keyword">or</span> word unary minus</span><br><span class="line">   | basic_expr + basic_expr -- integer <span class="keyword">or</span> real <span class="keyword">or</span> word addition</span><br><span class="line">   | basic_expr - basic_expr -- integer <span class="keyword">or</span> real <span class="keyword">or</span> word subtraction</span><br><span class="line">   | basic_expr * basic_expr -- integer <span class="keyword">or</span> real <span class="keyword">or</span> word multiplication</span><br><span class="line">   | basic_expr / basic_expr -- integer <span class="keyword">or</span> real <span class="keyword">or</span> word division</span><br><span class="line">   | basic_expr mod basic_expr -- integer <span class="keyword">or</span> word remainder</span><br><span class="line">   | basic_expr &gt;&gt; basic_expr -- bit shift right</span><br><span class="line">   | basic_expr &lt;&lt; basic_expr -- bit shift left</span><br><span class="line">   | basic_expr [ index ] -- index subscript</span><br><span class="line">   | basic_expr [ basic_expr : basic_expr ]</span><br><span class="line">   -- word bits selection</span><br><span class="line">   | basic_expr :: basic_expr -- word concatenation</span><br><span class="line">   | <span class="built_in">word1</span> ( basic_expr ) -- boolean to <span class="type">unsigned</span> word[<span class="number">1</span>] conversion</span><br><span class="line">   | <span class="built_in">bool</span> ( basic_expr ) -- <span class="type">unsigned</span> word[<span class="number">1</span>] <span class="keyword">and</span> <span class="type">int</span> to boolean conversion</span><br><span class="line">   | <span class="built_in">toint</span> ( basic_expr ) -- word <span class="keyword">and</span> boolean to integer constant conversion</span><br><span class="line">   | <span class="built_in">count</span> ( basic_expr_list ) -- count of <span class="literal">true</span> boolean expressions</span><br><span class="line">   | <span class="built_in">swconst</span> ( basic_expr , basic_expr )</span><br><span class="line">   -- integer to <span class="type">signed</span> word constant conversion</span><br><span class="line">   | <span class="built_in">uwconst</span> ( basic_expr, basic_expr )</span><br><span class="line">   -- integer to <span class="type">unsigned</span> word constant conversion</span><br><span class="line">   | <span class="built_in">signed</span> ( basic_expr ) -- <span class="type">unsigned</span> word to <span class="type">signed</span> word conversion</span><br><span class="line">   | <span class="built_in">unsigned</span> ( basic_expr ) -- <span class="type">signed</span> word to <span class="type">unsigned</span> word conversion</span><br><span class="line">   | <span class="built_in">sizeof</span> ( basic_expr ) -- word size as an integer</span><br><span class="line">   | <span class="built_in">floor</span> ( basic_expr ) -- from a real to an integer</span><br><span class="line">   | <span class="built_in">extend</span> ( basic_expr , basic_expr)</span><br><span class="line">   -- word width extension</span><br><span class="line">   | <span class="built_in">resize</span> ( basic_expr , basic_expr)</span><br><span class="line">   -- word width resize</span><br><span class="line">   | <span class="type">signed</span> word[N] ( basic_expr ) -- integer to <span class="type">signed</span> word conversion</span><br><span class="line">   | <span class="type">unsigned</span> word[N] ( basic_expr ) -- integer to <span class="type">unsigned</span> word conversion</span><br><span class="line">   | basic_expr <span class="keyword">union</span> basic_expr -- <span class="keyword">union</span> of set expressions</span><br><span class="line">   | &#123; set_body_expr &#125; -- set expression</span><br><span class="line">   | basic_expr in basic_expr -- inclusion in a set expression</span><br><span class="line">   | basic_expr ? basic_expr : basic_expr</span><br><span class="line">   -- <span class="keyword">if</span>-then-<span class="keyword">else</span> expression</span><br><span class="line">   | <span class="built_in">READ</span> ( basic_expr , basic_expr ) -- read function with first argument</span><br><span class="line">   -- an array <span class="keyword">and</span> second index</span><br><span class="line">   | <span class="built_in">WRITE</span> ( basic_expr, basic_expr, basic_expr ) -- write function with first</span><br><span class="line">   -- argument an array, second index, <span class="keyword">and</span> third value to be stored</span><br><span class="line">   | <span class="built_in">CONSTARRAY</span> ( <span class="built_in">typeof</span> ( variable_identifer ), basic_expr ) -- constant array</span><br><span class="line">   -- constructor function that takes the type of the array variable indentifier</span><br><span class="line">   | <span class="built_in">CONSTARRAY</span> ( array word[n] of subtype, basic_expr ) -- constant array</span><br><span class="line">   -- constructor function <span class="keyword">for</span> word-array that takes the array type explicitly</span><br><span class="line">   | <span class="built_in">CONSTARRAY</span> ( array integer of subtype, basic_expr ) -- constant array</span><br><span class="line">   -- constructor function <span class="keyword">for</span> <span class="type">int</span>-array that takes the array type explicitly</span><br><span class="line">   | case_expr -- <span class="keyword">case</span> expression</span><br><span class="line">   | basic_next_expr -- next expression</span><br><span class="line">   basic_expr_list ::</span><br><span class="line">      basic_expr</span><br><span class="line">      | basic_expr_list , basic_expr</span><br></pre></td></tr></table></figure></li>
<li>操作符及顺序<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ ]  下标索引, [ : ] 位选择运算[high : low]</span><br><span class="line">! 非运算</span><br><span class="line">::  连接操作符</span><br><span class="line">- (unary minus)</span><br><span class="line">* / mod</span><br><span class="line">+ -</span><br><span class="line">&lt;&lt; &gt;&gt;</span><br><span class="line">union</span><br><span class="line">in</span><br><span class="line">= != &lt; &gt; &lt;= &gt;=   </span><br><span class="line">&amp;</span><br><span class="line">| xor xnor</span><br><span class="line">(• ? • : •)</span><br><span class="line">&lt;-&gt;</span><br><span class="line">-&gt;</span><br></pre></td></tr></table></figure></li>
<li>变量和定义<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define_identifier :: complex_identifier</span><br><span class="line">variable_identifier :: complex_identifier</span><br></pre></td></tr></table></figure></li>
<li>函数调用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function call :: <span class="function">function <span class="title">identifier</span> <span class="params">( fun args list )</span></span></span><br><span class="line"><span class="function">function identifier :: complex identifier</span></span><br><span class="line"><span class="function">fun args list :: next expr | fun args list next expr</span></span><br></pre></td></tr></table></figure></li>
<li>其他操作<ul>
<li>连接字（:）<br>w1 := 0ub4 1101 and w2 := 0sb2 00, the result of w1::w2 is 0ub6 110100.</li>
<li>字扩展（extend）<br>扩展操作符通过在左侧附加额外的位来增加单词的宽度。可以理解为扩展后右移，填充字节规则同C</li>
<li>调整字大小（resize）</li>
<li>set表达式<br>在NUXMV中不能有集合的集合。集合只能包含单例值，而不能包含其他集合。</li>
<li>包含运算符 in ： 判断左操作数是否是右操作数的子集。</li>
<li>read表达式<br>读取操作符’ read ‘提取数组中特定下标处的一个元素。操作符的第一个实参必须是word-array或int-array类型的表达式，第二个实参表达式的类型必须与第一个实参中的数组表达式的索引类型相同。</li>
<li>write表达式<br>写操作符’ write ‘更新数组特定下标处的一个元素，并将更新后的数组作为新数组返回。操作符的第一个参数必须是word-array或int-array类型的表达式。<br>第二个和第三个参数表达式的类型必须与第一个参数中的数组表达式的索引类型和元素类型相同</li>
<li>CONSTARRAY表达式<br>常量数组’ CONSTARRAY ‘是一个特殊的构造函数，用于创建给定类型的数组，其中的元素设置为统一的给定值。<br><code>CONSTARRAY(typeof(a), 0)</code></li>
<li>typeof表达式。它主要用于获取数组变量的类型。</li>
<li>case表达式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case</span><br><span class="line">  left_expression_1 : right_expression_1 ;</span><br><span class="line">  left_expression_2 : right_expression_2 ;</span><br><span class="line">  ...</span><br><span class="line">  left_expression_N : right_expression_N ;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li><code>if then else</code> 表达式 或<code>(• ? • : •)</code>即<br>cond_expr ? basic_expr1 : basic_expr2</li>
<li>next表达式<br>Next表达式指的是处于下一个状态的变量的值。例如，如果一个变量v是一个状态变量，那么next(v)指的是下一个时间步中的变量v。应用于复杂表达式的next是递归应用于表达式中所有变量的next的一种速记方法。例如:next((1 + a) + b)等价于(1 + next(a)) + next(b)。<br>注意，next操作符不能应用两次，即不允许next(next(a))。</li>
<li>count表达式 count运算符计算为真表达式的个数。</li>
</ul>
</li>
<li>类型转换操作符<ul>
<li>整数转换操作符（toint）</li>
<li>floor转换操作符 将一个实数映射到之前最大的整数。</li>
<li>bool转换操作符<br>将无符号单词和任何整数类型的表达式(例如1 + 2)转换为布尔值。</li>
<li>整型到字常量的转换<br>swconst、uwconst分别将整数常量转换为给定大小的有符号单词[•]常量或无符号单词[•]常量。</li>
<li>Word1显式转换 bool转换为unsigned word[1]</li>
<li>无符号和有符号字显式转换</li>
<li>一般整数到字的转换<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned word[N](x) = −(unsigned word[N](−x))</span><br><span class="line">signed word[N](x) = signed(unsigned word[N](x))</span><br></pre></td></tr></table></figure>
<h3 id="变量声明-p27"><a href="#变量声明-p27" class="headerlink" title="变量声明 p27"></a>变量声明 p27</h3></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="CTL语法"><a href="#CTL语法" class="headerlink" title="CTL语法"></a>CTL语法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctl_expr ::</span><br><span class="line">simple_expr -- 一个简单的布尔表达式</span><br><span class="line">| ( ctl_expr )</span><br><span class="line">| ! ctl_expr -- 逻辑非</span><br><span class="line">| ctl_expr &amp; ctl_expr -- 逻辑与</span><br><span class="line">| ctl_expr | ctl_expr -- 逻辑或</span><br><span class="line">| ctl_expr xor ctl_expr -- 逻辑异或</span><br><span class="line">| ctl_expr xnor ctl_expr -- 逻辑同或</span><br><span class="line">| ctl_expr -&gt; ctl_expr -- 逻辑蕴含</span><br><span class="line">| ctl_expr &lt;-&gt; ctl_expr -- 逻辑等价</span><br><span class="line">| <span class="variable constant_">EG</span> ctl_expr -- 全局存在</span><br><span class="line">| <span class="variable constant_">EX</span> ctl_expr -- 存在下一个状态</span><br><span class="line">| <span class="variable constant_">EF</span> ctl_expr -- 最后存在</span><br><span class="line">| <span class="variable constant_">AG</span> ctl_expr -- forall globally</span><br><span class="line">| <span class="variable constant_">AX</span> ctl_expr -- forall next state</span><br><span class="line">| <span class="variable constant_">AF</span> ctl_expr -- forall <span class="keyword">finally</span></span><br><span class="line">| E [ ctl_expr U ctl_expr ] -- exists until</span><br><span class="line">| A [ ctl_expr U ctl_expr ] -- forall until</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EX p 在状态$s$中为真：如果存在状态$s’$且$p$在$s’$为真，同时存在从状态$s’$到s的转移。<br>AX p 在状态$s$中为真：如果所有从状态$s$到$s’$的转移有$p$在$s’$为真。<br>EF p 在状态$s_0$中为真：如果存在一系列$s_0→s_1，s_1→s_2，……，s_{n−1}→s_n$的转换。<br>AF p 在状态$s_0$中为真: 如果对于任意一系列$s_0→s_1，s_1→s_2，……，s_{n−1}→s_n$转换且$p$在$s_n$中为真。<br>EG p 在状态$s_0$中为真：如果存在一个无限的转换$s_0→s_1，s_1→s_2，……$且p在每个$s_i$中都是真的,。<br>AG p 在状态$s_0$中为真：如果对于所有无限的转换$s_0→s_1，s_1→s_2，……$且p在每个$s_i$中都是真的。<br>E[p U q] 在状态$s_0$中为真：如果存在一系列的转换$s_0→s_1，s_1→s_2，……，s_{n−1}→s_n$，p在从s0到sn−1的每个状态下都为真，而q在状态sn中为真。<br>A[p U q] 在状态$s_0$中为真：如果对于所有一系列的转换$s_0→s_1，s_1→s_2，……，s_{n−1}→s_n$ p在从s0到sn−1的每个状态下都为真，而q在状态sn中为真。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>NuXMV</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习（三）QString操作</title>
    <url>/2022/11/15/QT%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89QString/</url>
    <content><![CDATA[<blockquote>
<p>QString存储16位QChar（Unicode）字符串。<br>QString使用隐式共享（copy-on-write）来提高性能。</p>
</blockquote>
<p><strong>初始化方式</strong></p>
<blockquote>
<p>由于QString是Qchar类型，如果从C++ String转换为QString时，需要先通过c_str()转化为C风格字符串。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123; </span><br><span class="line">  QString str1 = <span class="string">&quot;The night train&quot;</span>; 	</span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str1; <span class="function">QString <span class="title">str2</span><span class="params">(<span class="string">&quot;A yellow rose&quot;</span>)</span></span>; 		</span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str2; QString str3 &#123;<span class="string">&quot;An old falcon&quot;</span>&#125;; 		</span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str3; std::string s1 = <span class="string">&quot;A blue sky&quot;</span>; </span><br><span class="line">  QString str4 = s1.<span class="built_in">c_str</span>(); 		</span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str4; std::string s2 = <span class="string">&quot;A thick fog&quot;</span>; </span><br><span class="line">  QString str5 = QString::<span class="built_in">fromLatin1</span>(s2.<span class="built_in">data</span>(), s2.<span class="built_in">size</span>()); </span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str5; <span class="type">char</span> s3[] = <span class="string">&quot;A deep forest&quot;</span>; </span><br><span class="line">  <span class="function">QString <span class="title">str6</span><span class="params">(s3)</span></span>; 			</span><br><span class="line">  <span class="built_in">qDebug</span>()  &lt;&lt; str6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问字符串元素：</strong><br>可以通过<code>[]</code>索引和at方式访问字符串元素。</p>
<blockquote>
<p>operator[]返回的是可以修改的QChar&amp;。<br>at返回为const QChar,为只读，更高效。</p>
</blockquote>
<p><strong>构建字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString s3 = <span class="string">&quot;We have %1 lemons and %2 oranges&quot;</span>; </span><br><span class="line"><span class="type">int</span> ln = <span class="number">12</span>; </span><br><span class="line"><span class="type">int</span> on = <span class="number">4</span>; <span class="built_in">qDebug</span>() &lt;&lt; s3.<span class="built_in">arg</span>(ln).<span class="built_in">arg</span>(on) ; </span><br></pre></td></tr></table></figure>

<p><strong>截取字串的方式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str.<span class="built_in">right</span>(<span class="number">5</span>); </span><br><span class="line">str.<span class="built_in">left</span>(<span class="number">9</span>); </span><br><span class="line">str.<span class="built_in">mid</span>(<span class="number">4</span>, <span class="number">5</span>); </span><br></pre></td></tr></table></figure>


<p><strong>遍历字符串的几种方式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (QChar qc: str) </span><br><span class="line">	out &lt;&lt; qc &lt;&lt; <span class="string">&quot; &quot;</span>; out &lt;&lt; endl; </span><br><span class="line"><span class="keyword">for</span> (QChar *it=str.<span class="built_in">begin</span>(); it!=str.<span class="built_in">end</span>(); ++it) </span><br><span class="line">	out &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> ; out &lt;&lt; endl; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) </span><br><span class="line">	out &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br></pre></td></tr></table></figure>

<p><strong>字符串比较</strong><br>QString::compare返回整型：<br>0表示相等<br>负数表示小于<br>正数表示大于</p>
<p><strong>字符类型判断</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (QChar s : str) &#123; </span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">isDigit</span>()) &#123;digits++;&#125;          <span class="comment">//判断数字</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">isLetter</span>()) &#123;letters++;&#125;   <span class="comment">//判断字母</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">isSpace</span>()) &#123;spaces++;&#125;     <span class="comment">//判断空白字符</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">isPunct</span>()) &#123;puncts++;&#125;     <span class="comment">//判断标点符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符串类型转换</strong><br>转为int型 s1.toInt()<br>转为字符串 setNum(n1) </p>
<p><strong>字符串修改操作</strong><br><code>str.append(&quot; season&quot;)</code>：追加字符串<br><code>str.remove(10, 3)</code>：移除index =10 后的三个字符<br><code>str.replace(7, 3, &quot;girl&quot;)</code>：替换 index = 7 后的三个字符为新字符串<br><code>str.clear(); </code>：清空字符串<br>‘str.split(‘,’)’：按指定字符切割字符串，返回字符串列表QStringList<br>‘str.trimmed()’：去除字符串两侧的空格</p>
<p><strong>对齐字符串</strong><br>可以使用leftJustified和rightJustified来对齐字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString field3 &#123; <span class="string">&quot;Residence: &quot;</span> &#125;; </span><br><span class="line">QString field4 &#123; <span class="string">&quot;Marital status: &quot;</span> &#125;; </span><br><span class="line"><span class="type">int</span> width = field4.<span class="built_in">size</span>(); </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; field3.<span class="built_in">rightJustified</span>(width, <span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="string">&quot;New York&quot;</span>; </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; field4.<span class="built_in">rightJustified</span>(width, <span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="string">&quot;single&quot;</span>; </span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>Residence: New York
</code></pre>
<p>Marital status: single</p>
</blockquote>
<p><strong>转码为html格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString allText = <span class="string">&quot;&lt;\&quot;hello the world!\&quot;&gt;&quot;</span>; </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; allText.<span class="built_in">toHtmlEscaped</span>(); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>&lt;&quot;hello the world!&quot;&gt;</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习（四）常用容器</title>
    <url>/2022/12/01/QT%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>相对于C++ STL里的容器，QT也提供了容器，且与STL模板兼容。</p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h3 id="QList"><a href="#QList" class="headerlink" title="QList"></a>QList</h3><blockquote>
<p>QList、QVector(在qt6中，QVector是QList别名)</p>
</blockquote>
<ol>
<li>引入容器：<code>#include &lt;QList&gt; </code></li>
<li>定义：<code>QList&lt;int&gt; vals = &#123;1, 2, 3, 4, 5&#125;; </code></li>
<li>容器大小：<code> vals.size();</code></li>
<li>首元素：<code> vals.first();</code></li>
<li>尾元素：<code> vals.last();</code></li>
<li>尾插：<code>vals.append()</code></li>
<li>头插：<code>vals.prepend()</code></li>
<li>一种遍历方式：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : vals) </span><br><span class="line">      <span class="built_in">qDebug</span>() &lt;&lt; val ; </span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>tips:</strong> QCollator类</p>
</blockquote>
<p>QCollator使用QLocale和可选的排序策略进行初始化。它尝试用指定的值初始化collator。然后，可以使用collator以依赖于语言环境的方式对字符串进行比较和排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QLocale <span class="title">cn</span><span class="params">(QLocale::Chinese)</span></span>; </span><br><span class="line"><span class="function">QCollator <span class="title">collator</span><span class="params">(cn)</span></span>; </span><br><span class="line">std::<span class="built_in">sort</span>(authors.<span class="built_in">begin</span>(), authors.<span class="built_in">end</span>(), collator); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>QStringList</p>
</blockquote>
<p>QStringList仍包含于QList中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString string = <span class="string">&quot;coin, book, cup, pencil, clock, bookmark&quot;</span>; </span><br><span class="line">QStringList items = string.<span class="built_in">split</span>(<span class="string">&quot;,&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用Java风格的const迭代器遍历QStringList</p>
<ul>
<li>hasNext()判断是否有下一项</li>
<li>next()：返回下一项并将迭代器前进一个位置。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QStringListIterator <span class="title">it</span><span class="params">(items)</span></span>; </span><br><span class="line"><span class="keyword">while</span> (it.<span class="built_in">hasNext</span>()) </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">next</span>(); </span><br></pre></td></tr></table></figure>
使用C++风格的iterator迭代器遍历：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QStringList::Iterator it=items.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">while</span> (it!=items.<span class="built_in">end</span>()) </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; (*it++).<span class="built_in">trimmed</span>() ;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="QSet"><a href="#QSet" class="headerlink" title="QSet"></a>QSet</h3><ul>
<li>提供具有快速查找功能的单值集。</li>
<li>不支持排序。values方法返回一个QList，其中包含QSet中的元素。</li>
<li>unite方法执行两个集合的并集。</li>
</ul>
<ol>
<li>引入：<code>#include &lt;QSet&gt; </code></li>
<li>定义：<code>QSet&lt;QString&gt; cols1 = &#123;&quot;yellow&quot;, &quot;red&quot;, &quot;blue&quot;&#125;;</code></li>
<li>求并集：<code>cols1.unite(cols2); </code></li>
<li>大小：<code>cols1.size()</code></li>
<li>插入元素：<code>cols1.insert(&quot;brown&quot;); </code></li>
<li>遍历方式：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> QString &amp;val : cols1) </span><br><span class="line">     out &lt;&lt; val &lt;&lt; endl; </span><br></pre></td></tr></table></figure>
<h3 id="QMap"><a href="#QMap" class="headerlink" title="QMap"></a>QMap</h3></li>
<li>引入：<code>#include &lt;QMap&gt; </code></li>
<li>定义：<code>QMap&lt;QString, int&gt; items = &#123; &#123;&quot;coins&quot;, 5&#125;, &#123;&quot;books&quot;, 3&#125; &#125;; </code></li>
<li>插入：<code>items.insert(&quot;bottles&quot;, 7);  </code></li>
<li>大小：<code>items.size()</code></li>
<li>获取所有值：<code>QList&lt;int&gt; values(items.cbegin(),items.cend());</code><br> 使用了cbegin()，cend()迭代器</li>
<li>获取所有键：<code>QList&lt;QString&gt; keys(items.keyBegin(),items.keyEnd());</code><br>使用了keyBegin()，keyEnd()迭代器</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑与形式化方法</title>
    <url>/2023/01/16/%E9%80%BB%E8%BE%91%E4%B8%8E%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>课程视频<a href="https://dl.ccf.org.cn/albumList/5719367269009408?_ack=1">杨子江-逻辑与形式化方法</a>；参考书籍<a href="https://pan.baidu.com/s/1VV5zVMk9ILYnB4WkYA5N6A?pwd=0fbh">Handbook of Model Checking</a></p>
<h1 id="Model-Checking"><a href="#Model-Checking" class="headerlink" title="Model Checking"></a>Model Checking</h1><blockquote>
<p><strong>Definition (Model checking)</strong> Given a Kripke structure M = (S,R,L), a designated initial state s0 ∈ S, and a temporal logic formula ϕ, the model-checking problem is to decide whether M is a model of ϕ, i.e., whether M,s0 |= ϕ.</p>
</blockquote>
<p>三个问题:</p>
<ol>
<li>模型Model:怎么把程序等转化成Model？怎么样建立有效的Model？有很多的Model在建立时已经决定了验证时是不确定的。</li>
<li>形式化验证Specification：Properties很难写。LTL和CTL很难写</li>
<li>算法Algorithm：软件和硬件系统是不是Properties的一个子集？不是说公式表达的状态越多越复杂，有时候反而会很简单。用BDD做model checking很难预测大小。故现在主要用SAT做验证<br>Higher-order theorem proving 是比 Testing 更强大的用于证明程序复杂性的</li>
</ol>
<h2 id="时序逻辑概述"><a href="#时序逻辑概述" class="headerlink" title="时序逻辑概述"></a>时序逻辑概述</h2><p>在一个模型中，公式的真与假不是静态的。</p>
<h3 id="Kripke-Structures-克里普克结构"><a href="#Kripke-Structures-克里普克结构" class="headerlink" title="Kripke Structures 克里普克结构"></a>Kripke Structures 克里普克结构</h3><p>用来做Model Checking 很重要的一个Model。是有限有向图，其顶点用一组原子命题标记。图的顶点和边分别被称为“状态”和“转换”。</p>
<blockquote>
<p><strong>Definition (Kripke structure)</strong> Let AP be a finite set of atomic propositions.A Kripke structure is a triple (S,R,L) where S is a finite set of states, R ⊆ S × S is a transition relation, and $L: S \mapsto \mathcal{P}(AP)$ labels each state with a set of atomic propositions.</p>
</blockquote>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.1ax2g51vvif4.webp" alt="image"></p>
<h3 id="分支时序逻辑-计算树逻辑（CTL）"><a href="#分支时序逻辑-计算树逻辑（CTL）" class="headerlink" title="分支时序逻辑-计算树逻辑（CTL）"></a>分支时序逻辑-计算树逻辑（CTL）</h3><p>CTL是一种分支时态逻辑，在状态上解释路径量词，在路径上解释时态运算符。可用于断言一条路径的存在。<br>复杂度大小为：Model大小 * formula大小<br><strong>路径量词</strong><br>$A$: 沿所有路径<br>$E$: 沿至少一条路径<br><strong>时态操作符</strong>（用于原子命题$p$和$q$）<br>$Xp$: $p$为真在<u>下一个状态</u><br>$Fp$: $p$为真在<u>某个未来状态</u><br>$Gq$: $q$为真在<u>所有未来状态</u><br>$qUp$: $p$在某个未来状态为真，在所有状态$q$一直为真，<u>直到</u> $p$为真</p>
<p><strong>CTL语法定义</strong>：A为给定的原子命题</p>
<blockquote>
<p>If $p \in A$, then $p$ is a formula of CTL* .<br>If $\varphi$ and $\psi$ are formulas of CTL* , then $\varphi \vee \psi$, $\varphi \wedge \psi$, $\neg \varphi$, $A\varphi$, $E\varphi$, $X\varphi$, $F\varphi$, $G\psi$, and $\varPsi U \psi$ are formulas of CTL*.</p>
</blockquote>
<p><strong>CTL状态公式真值表</strong><br>$K$是一个Kripke structure，$\pi$是一个路径，$s$是一个状态，$p$是一个原子命题，$f$和$g$是状态公式，$\varphi$和$\psi$是CTL*公式</p>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.1c1qesv09ev4.webp" alt="image"></p>
<h3 id="线性时序逻辑（LTL）"><a href="#线性时序逻辑（LTL）" class="headerlink" title="线性时序逻辑（LTL）"></a>线性时序逻辑（LTL）</h3><p>LTL将时间建模成状态的序列，无限延伸到未来。这个状态序列称为计算路径。如果定义系统的一个状态满足一个LTL公式，则由给定状态出发的所有路径都满足该LTL。即LTL隐含着对所有路径做全称量词限定。LTL是CTL的一个语法子集？但是算法时间复杂度比CTL大。Model的大小 * formula的指数大小。</p>
<blockquote>
<p>If $p \in A$, then $p$ is a formula of LTL- .<br>If $\varphi$ and $\psi$ are formulas of LTL- , then $\varphi \vee \psi$, $\varphi \wedge \psi$, $\neg \varphi$, $X\varphi$, $F\varphi$, $G\psi$, and $\varPsi U \psi$ are formulas of LTL-.<br>If $\psi$ is a formula of LTL-, $A\psi$ is an LTL formula.</p>
</blockquote>
<h1 id="Modeling-Software-Systems"><a href="#Modeling-Software-Systems" class="headerlink" title="Modeling Software Systems"></a>Modeling Software Systems</h1><p>多线程系统相较于单线程系统存在新的问题：资源竞争、死锁、运算顺序等。<br>状态空间爆炸问题。</p>
<h2 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h2><p>语言要求：Formal（规范）、Intuitive（易懂）、Succinct（简介）、Effective（有效）、Expressive（表达力）</p>
<h3 id="Linear-Temporal-Logic：-LTL"><a href="#Linear-Temporal-Logic：-LTL" class="headerlink" title="Linear Temporal Logic： LTL"></a>Linear Temporal Logic： LTL</h3><p>LTL公式使用析取和否定的普通布尔连接词构造，并引入时序操作符next、previous、until和since。<br>$\varphi ::= (\varphi)|\neg\varphi|\varphi\vee\varphi|\varphi\wedge\varphi|\varphi U \varphi|\Box\varphi|\diamondsuit\varphi|\bigcirc\varphi|P$<br>$\bigcirc p$等同于$Xp$: $p$为真在<u>下一个状态</u><br>$\diamondsuit p$等同于$Fp$: $p$为真在<u>某个未来状态</u><br>$\Box q$等同于$Gq$: $q$为真在<u>所有未来状态</u><br>$qUp$: $p$在某个未来状态为真，在所有状态$q$一直为真，<u>直到</u> $p$为真<br>$P$为布尔变量</p>
<h2 id="Explicit-State-Model-Checking"><a href="#Explicit-State-Model-Checking" class="headerlink" title="Explicit-State Model Checking"></a>Explicit-State Model Checking</h2><p>显式状态模型检验(Explicit-state model checking) 非常适合应用于软件验证，特别是交互异步进程系统的验证。</p>
<ul>
<li>基本的可达性分析最容易用于安全 属性的验证，例如不变量、断言的有效性，或者多进程系统中不存在死锁 。</li>
<li>算法也可以用来证明活跃属性，包括所有可以在线性时序逻辑(LTL)中形式化的属性</li>
</ul>
<p>使用Explicit-State Model Checking需要满足两个假设：</p>
<ul>
<li>作为验证目标的系统必须是有限状态的</li>
<li>系统执行可以被建模为一个单独的状态转换序列。</li>
</ul>
<p><strong>抽象很重要</strong></p>
<h3 id="基本的搜索算法"><a href="#基本的搜索算法" class="headerlink" title="基本的搜索算法"></a>基本的搜索算法</h3><p>（使用DFS）？<br>状态机定义$A={S,s_0,L,T,F}$</p>
<ul>
<li>$S$是 状态的有限集，</li>
<li>$s_0$是S中的一个元素，称为初始状态，</li>
<li>$L$是一组符号，称为 标签集或字母表，</li>
<li>$T\subseteq S \times L \times S$是过渡集，</li>
<li>$F \subseteq S$是 最终状态集。</li>
<li>自动机A接受任何以在$s\in F$状态下结束的有限执行。</li>
</ul>
<p><strong>BFS和DFS比较</strong>：</p>
<ul>
<li>同：两种算法具有相同的计算复杂度<ul>
<li>在可达状态的数量上是线性</li>
<li>这两种算法都可以在运行中工作，故不不需要预先知道可达图</li>
</ul>
</li>
<li>异：行为不同<ul>
<li>DFS:必须存储在集合D中使反例生成更小。</li>
<li>DFS:很容易扩展，不仅支持安全性的验证，且支持活跃属性的验证，而不会增加搜索的计算复杂性。（显著优点）</li>
<li>BFS:生成的任何反例往往更小</li>
</ul>
</li>
</ul>
<h3 id="omega-自动机"><a href="#omega-自动机" class="headerlink" title="$\omega$自动机"></a>$\omega$自动机</h3><p>任何LTL公式都可以机械地转换为Büchi自动机$B={S,s_0,L,T,F}$。$B$接受执行序列$\sigma$，当且仅当$\sigma$包含集合$F$的无穷多个状态时。即Büchi只接受无限序列。</p>
<p><strong>模型检验的问题</strong>：<br>给定一个系统A，形式化为一个有限自动机 A，和一个Büchi自动机B， 形式化满足LTL公式的A的所有执行。在两个自动机接受的语言的交集中找到一个接受运行的问题。</p>
<p>A 和B的交集是通过计算A × B得到的，A × B是一个Büchi 自动机。</p>
<p>有限状态自动机A和B的同步积为有限状态自动机$P={S’,s_o’,L’,T’,F’}$</p>
<ul>
<li>$S’=A.S\times B.S$</li>
<li>$s_0’=(A.s_0,B.s_0)$</li>
<li>$L’=A.L\times B.L$</li>
<li>$T’\in S’\times L’\times S’$, 其中$((A.s,B.t),(e,f ),<br>(A.s′,B.t′)) ⊆ T′,\  (A.s,e,A.s′) ∈ A.T, \ and (B.t,f,B.t′) ∈ B.T$</li>
<li>$F’\subseteq A.S × B.S$，对于每一对$(e, F)\in F’$有$e\in A.F\wedge F\in B.F$</li>
</ul>
<p><strong>形式化如下</strong>：</p>
<ul>
<li>将LTL公式$f$转换为相应的Büchi自动机$B$。</li>
<li>计算A0，…，AN的 交叉积(interleaving product) A。</li>
<li>计算$A \times B$的同步积(synchronous product) P。</li>
<li>使用Büchi接受规则找到自动机P的接受运行。</li>
</ul>
<h3 id="Nested-depth-first-search-嵌套DFS？"><a href="#Nested-depth-first-search-嵌套DFS？" class="headerlink" title="Nested depth-first search(嵌套DFS？)"></a>Nested depth-first search(嵌套DFS？)</h3><p>可以用嵌套的深度优先搜索算法有效地解决。在P中是否存在至少一个可到达的最终状态，也可以从它自身到达?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Open D = &#123;&#125;; <span class="comment">// ordered set</span></span><br><span class="line">Visited V = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">State seed = nil;</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span>()</span><br><span class="line">&#123;   V!s0,<span class="number">0</span>; D!s0,<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ndfs</span>(); <span class="comment">// start the first search</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ndfs</span>()</span><br><span class="line">&#123;   Bit b; <span class="comment">// b=0: first search, b=1: nested search</span></span><br><span class="line">    D?s,b;</span><br><span class="line"></span><br><span class="line">    foreach (s,e,s’) in T</span><br><span class="line">    &#123;   <span class="keyword">if</span> (s’ == seed) <span class="comment">// seed reachable from itself</span></span><br><span class="line">        &#123;   <span class="built_in">liveness_violation</span>(); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !(s’,b ∈ V) <span class="comment">// if s’ not reached before</span></span><br><span class="line">        &#123;   V!s’,b; D!!s’,b; <span class="built_in">ndfs</span>(); <span class="comment">// continue search</span></span><br><span class="line">    &#125;   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in post-order, in first search only</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s ∈ F &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">    &#123;   seed = s;   <span class="comment">// a reachable final state</span></span><br><span class="line">        D!!s,<span class="number">1</span>;     <span class="comment">// push s on stack D</span></span><br><span class="line">        <span class="built_in">ndfs</span>();     <span class="comment">// start the nested search</span></span><br><span class="line">        seed = nil; <span class="comment">// nested search completed</span></span><br><span class="line">&#125;   &#125;</span><br></pre></td></tr></table></figure>
<p>算法中的符号定义：</p>
<ul>
<li>$X!y$将y添加到集合X中;如果X是有序的，那么它将y作为X的最后一个元素，</li>
<li>$X!!y$将y添加到集合X中;如果X是有序的，那么它将y作为X的第一个元素，</li>
<li>$X?y$从集合X中移除一个元素并命名为y;如果X有序，则删除的元素是X中的第一个元素，如果X为空，则操作返回空元素 $\emptyset$ 。</li>
</ul>
<h1 id="Binary-Decision-Diagrams"><a href="#Binary-Decision-Diagrams" class="headerlink" title="Binary Decision Diagrams"></a>Binary Decision Diagrams</h1><p>使用真值表或者二进制决策树来表示二进制布尔变量情况，其复杂度是指数倍增长的。采用二进制决策图来表示可以降低复杂度</p>
<p>**二进制决策图(BDD)**：将布尔函数表示为无环有向图，</p>
<ul>
<li>非终端顶点用布尔变量标记<br>对于非终端顶点$v$，其变量记为$var(v)$，而对于叶顶点$v$，其值记为$val(v)$。<br>每个非终端顶点v都有两条出边:$hi(v)$，变量值为1;$lo(v)$变量值为0。</li>
<li>叶子顶点用值1和0标记。<br>我们将$hi(v)$和$lo(v)$称为顶点$v$的$hi$和$lo$子结点。这两个叶结点被称为$1-leaf$和$0-leaf$。<blockquote>
<p><strong>Definition 1 (BDD)</strong> Reduced ordered BDDs are canonical representations of Boolean propositional formulas. The BDD for a formula f , denoted by Bdd(f ), is a directed acyclic graph (DAG).</p>
</blockquote>
</li>
</ul>
<h2 id="BDD相关规则"><a href="#BDD相关规则" class="headerlink" title="BDD相关规则"></a>BDD相关规则</h2><p><strong>ODBB表示布尔函数的规则：</strong><br>将函数$f_v$与图中的每个顶点$v$相关联来定义由BDD表示的布尔函数。BDD中的每个顶点都表示一个布尔函数</p>
<ul>
<li>对于两个叶子，相关联的值是 1 (1-leaf)和0 (0-leaf)。</li>
<li>对于非终端顶点v，相关的函数定义为为$f_v = (var(v) \wedge f_{hi(v)}\vee (\neg var(v) ∧ f_{lo(v)}).$</li>
</ul>
<p>对于有序二进制决策图(obdd)，我们对与图顶点相关的变量强制执行一个排序规则 。（<strong>不同的排序规则会导致不同的BDD大小）</strong></p>
<ul>
<li>对于每个顶点$v$有 $var(v) = x_i$，对于顶点$u\in {hi(v)，lo(v)}$有$var(u) = x_j$且必须 $i &lt; j$。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.74vur33458s0.webp"><br><center>树表示</th>
<th align="left"><img src=https://cdn.staticaly.com/gh/konsin/images@main/image.u8xh67186zk.webp><br><center> OBDD表示</th>
</tr>
</thead>
</table>
<center> (x1 ∧ x2 ∧ ¬x3) ∨ (¬x1 ∧ x3) 的表示。<br>图中，我们将lo子结点的弧表示为虚线，将hi子结点的弧表示为实线。</center>

<p><strong>简化的OBDD定义为满足以下规则的OBDD:</strong></p>
<ol>
<li>一个叶子最多只能有一个给定的值。</li>
<li>不可能有顶点v使得$hi(v) = lo(v)$。一个节点的两个孩子不能指向一个地方。</li>
<li>不可能存在不同的非终端顶点u和v，使得$var(u) = var(v)， hi(u) = hi(v)， lo(u) = lo(v)$。没有另外一个节点跟当前节点表达同一个意思</li>
</ol>
<p><strong>化简为reduced OBDD的规则</strong>：</p>
<ol>
<li>如果叶u和v有val(u) = val(v)，那么消除其中一个，并将所有传入的边重定向到另一个。</li>
<li>如果顶点v具有lo(v) = hi(v)，则消除顶点v并将所有传入的边重定向到它的子顶点。</li>
<li>如果顶点u和v有var(u) = var(v)， hi(u) = hi(v)， lo(u) = lo(v)，那么消除其中一个顶点，并将所有传入的边重定向到另一个顶点。</li>
</ol>
<h2 id="布尔函数抽象数据类型的基本操作"><a href="#布尔函数抽象数据类型的基本操作" class="headerlink" title="布尔函数抽象数据类型的基本操作"></a>布尔函数抽象数据类型的基本操作</h2><p>图中$f$和$g$表示布尔函数(用obdd表示)，$i$是 1到n之间的变量索引，$b$是0或1, $\bold{a}$是n个0和1的向量。索引$I\subseteq {1,…,n}$,$X_I$表示对应的一组变量${x_i|i\in I}$<br>| 操作               | 结果                                         | 解释                     |<br>| :—————– | :——————————————- | :———————– |<br>| 基本函数           |<br>| $CONST(b)$         | $\bold{1} (b = 1)\ or\ \bold{0} (b = 0)$     |<br>| $VAR(i)$           | $x_i$                                        |<br>| 代数运算           |<br>| $NOT(f)$           | $\neg f$                                     |<br>| $AND(f,g)$         | $f \wedge g$                                 |<br>| $OR(f,g)$          | $f \vee g$                                   |<br>| $XOR(f,g)$         | $f \oplus g$                                 |<br>| 非代数操作         |<br>| $RESTRICT(f,i,b)$  | $ f\vert_{x_i} \leftarrow b$                 | 把$x_i$值替换成0或1      |<br>| $COMPOSE(f,i,g)$   | $ f  \vert_{ x_i} \leftarrow g $             | 把$x_i$值替换成布尔函数g |<br>| $EXISTS(f,I)$      | $ \exist X_I.f$                              |<br>| $FORALL(f,I)$      | $ \forall X_I.f$                             |<br>| $RELPROD(f,g,I)$   | $ \exist X_I.(f \wedge g)$                   |<br>| 检验函数           |<br>| $EQUAL(f,g)$       | $ f = g$                                     |<br>| $EVAL(f,\bold{a})$ | $ f (\bold{a})$                              |<br>| $SATISFY(f )$      | some $\bold{a}$ such that $f (\bold{a}) = 1$ |<br>| $SATISFY-ALL(f )$  | $ {\bold{a} \vert f (\bold{a}) = 1}$       |</p>
<h2 id="APPLY算法"><a href="#APPLY算法" class="headerlink" title="APPLY算法"></a>APPLY算法</h2><center>Apply算法，一种实现二进制布尔代数运算的通用方法。<br>在从递归调用返回时从下往上生成一个简化的OBDD 。 </center>

<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4gzb8uvgqhs0.webp" alt="image"></p>
<h2 id="变量排序和重组"><a href="#变量排序和重组" class="headerlink" title="变量排序和重组"></a>变量排序和重组</h2><p>有些函数对变量排序非常敏感，甚至出现从线性到变量数量的指数级的复杂度的差异。<br>使用相邻变量的成对交换作为基本操作，大多数OBDD库通过称为筛选 [59]的过程实现动态变量排序。单个变量或一小组变量[57]，通过相邻变量交换序列在排序中上下移动，直到确定产生的位置(总顶点数可接受)。在筛选的原始公式中，变量在整个可能的位置范围内移动，然后返回到使整体OBDD大小最小化的位置。</p>
<h2 id="表示非布尔函数"><a href="#表示非布尔函数" class="headerlink" title="表示非布尔函数"></a>表示非布尔函数</h2><p><strong>OBDD的关键属性</strong>:</p>
<ul>
<li>主要是通过子图的共享实现了紧凑性，， </li>
<li>关键操作可以通过图算法实现，</li>
<li>表示的函数的属性可以很容易地测试。</li>
</ul>
<p><strong>无界域上的函数</strong><br>当一个函数变量x在一个无限大的定义域D上时，我们不能简单地用一组二进制值来编码它的可能值，或者向决策图的顶点添加多个分支。然而，在某些应用程序中，<u>只需要捕获状态变量的一组有界属性。</u><br><strong>差异决策图(DDDs:Difference Decision Diagrams (DDDs))</strong><br>差分约束:每一种形式为$x_i−x_j≤c$或$x_i−x_j &lt; c$，其中$x_i$和$x_j$为时钟变量，c为整数或实值。<br>| <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.285elr5wge80.webp" alt="image">       | <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.2to7vq40v6q0.webp" alt="image">                          | <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.699t285smtc0.webp" alt="image">                      |<br>| :————————————————————————————– | :——————————————————————————————————— | :—————————————————————————————————– |<br>| $C_1 = (x_1 − x_2 &gt; 4) ∧ (x_1 − x_3 ≤ 12)$ <br> $C2 = (x_1 − x_2 ≤ 4) ∧ (x_2 − x_3 ≤5)$ | $C_1 = (x_1 − x_2 &gt; 4) ∧ (x_1 − x_3 ≤ 12)$ <br> $C’_2 = (x_1 − x_2 ≤ 4) ∧ (x_2 − x_3 ≤ 5) ∧ (x_1 −x_3&gt;10)$ | $C_1 = (x_1 − x_2 &gt; 4) ∧ (x_1 − x_3 ≤ 12)$ <br>$C_2’’ = (x1 − x2 ≤ 4) ∧ (x2 − x3 ≤ 5) ∧ (x1 − x3 ≤ 9)$ |</p>
<center>差分决策图(DDD)示例。顶点由差分约束标记</center>

<h1 id="BDD-Based-Symbolic-Model-Checking"><a href="#BDD-Based-Symbolic-Model-Checking" class="headerlink" title="BDD-Based Symbolic Model Checking"></a>BDD-Based Symbolic Model Checking</h1><ul>
<li>BDDs用于符号表示所分析的自动机或Kripke结构的转换关系，以及由模型检查算法控制的状态集。</li>
<li>表示和操作转换关系及状态集对于实现广泛的时序逻辑的模型检查算法是足够的</li>
</ul>
<p>基于bdd的符号模型检查对形式化验证和形式化方法的影响。</p>
<ul>
<li>首先，它实现了工业系统的实际验证。</li>
<li>其次，它导致了bdd的重要发展，例如新类型的bdd[22]，变量排序启发式[2,24]和高效实现[31]。</li>
<li>最后，它为其他形式的符号模型检查铺平了道路，</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.41162qpy4o20.webp" alt="image"><br>一个Kripke结构和一个BDD的转换关系 (虚线和实线分别表示BDD中的0和1边)</p>
<h2 id="状态集-和-关系的表示"><a href="#状态集-和-关系的表示" class="headerlink" title="状态集 和 关系的表示"></a>状态集 和 关系的表示</h2><h3 id="状态集的表示："><a href="#状态集的表示：" class="headerlink" title="状态集的表示："></a><strong>状态集的表示</strong>：</h3><p>对于任意$X⊆S$，特征函数$[[X]]$用命题公式$f (X)$表示，定义为：$f (X) = \bigvee\limits_{s∈X}\chi (s)$<br>形式上，设$\chi$为从S到minterms的映射，定义为:$\chi(s) = l_1 ∧ ··· ∧ l_k\  where\  l_i =\left{\begin{matrix} p_i &amp; if\ p_i ∈ L(s) \ \neg p_i &amp; otherwise  \end{matrix}\right.$<br>以上图Kripke结构图为例。<br>$χ(s0) = p ∧ ¬q,\ χ(s1) = p ∧ q,\ χ(s2) = ¬p ∧ q,\ χ(s3) = ¬p ∧ ¬q$<br>让$X = \emptyset, Y = {s0,s1}, and Z = {s1,s3}$.那么 对应的特征函数的符号表示为:<br>$\begin{matrix} f (X) = FALSE &amp; f (Y) = (p ∧ ¬q) ∨ (p ∧ q) = p &amp;<br>f (Z) = (p ∧ q) ∨ (¬p ∧ ¬q)\end{matrix}$</p>
<h3 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a><strong>关系的表示</strong></h3><p>对于任意$R⊆S × S$，特征函数$[[R]]$用命题公式$f (R)$表示为:$f (R) = \bigvee\limits_{(s, t)∈R}\chi (s, t)$</p>
<p>为了表示转换关系$R⊆S × S$，我们引入了一组新的原子命题$AP’ = {p_1’，…, p_k’}$。<u>$p$为当前状态中的$p$，$p’$为当前状态可转换到的下一个状态中的$p$。</u><br>对于AP上的公式$f$，$Prime(f )=f [p_1,…,p_k/p_1′ ,…,p_k′]$，$UnPrime(f ) = f [p_1′ ,…,p_k′ /p_1,…,p_k]$<br>使用BDD 重命名操作将这些操作提升到BDD。我们现在将χ扩展为S × S与 minterms集合对AP∪AP’的双射：$χ(s,t) = χ(s) ∧ Prime(χ(t))$</p>
<p>上图右侧为以下关系的BDD表示：<br>$f (R) =(p ∧ ¬q ∧ p’ ∧ q’) ∨ (p ∧ ¬q ∧ ¬p’ ∧ q’) ∨ (p ∧ q ∧ p’ ∧ q’)<br>∨ (p ∧ q ∧ ¬p’ ∧ q’) ∨ (¬p ∧ q ∧ ¬p’ ∧ ¬q’) ∨ (¬p ∧ ¬q ∧ ¬p’ ∧ ¬q’)<br>\=(p ∧ q’)∨ (¬p ∧ ¬p’ ∧ ¬q’)$</p>
<h2 id="图像运算"><a href="#图像运算" class="headerlink" title="图像运算"></a>图像运算</h2><p>图像和预图像计算——即分别计算一组状态的后继集合或前身的集合——是任何模型检查算法的基本操作</p>
<p>给定一组状态S，转换关系R下S的图像用Image (S,R)表示 ，定义为:<br>$Image(S,R) = {t \vert ∃s ∈ S_▪ (s,t) ∈ R}$ ，是过渡关系R中从S一步可达的状态集。</p>
<p>设$\bold{S}$和$\bold{R}$分别是$\bold{S}$和$\bold{R}$用 BDD 对$AP$和$AP∪AP’$的符号表示。然后计算 $Image(\bold{S,R})$的符号表示，记为$BDDIMAGE(\bold{S,R})$，计算公式如下:<br>$BDDIMAGE(\bold{S,R}) = UnPrime(∃AP_▪ \bold{S ∧ R})$</p>
<blockquote>
<p>首先为S和R的合取构造BDD，然后使用存在量化投射所有的预状态变量$AP$，最后 将结果从$AP’$重命名为$AP$变量。</p>
</blockquote>
<p>以$BDDIMAGE(\bold{S,R})$为例，其中$R$为s上图中Kripke结构的跃迁关系，$\bold{S} = {s0}$:<br>$$<br>\begin{align*}<br>&amp; BDDIMAGE(S,R)\<br>&amp; = UnPrime(∃p,q_▪ (p ∧ ¬q) ∧ ((p ∧ q′) ∨ (¬p ∧ ¬p′ ∧ ¬q′)))\<br>&amp; = UnPrime(∃p,q_▪ (p ∧ ¬q) ∧ (p ∧ q′))\<br>&amp; = UnPrime(q’) = q = Bdd(f ({s1,s2}))<br>\end{align*}<br>$$<br>$(p ∧ ¬q)$为$S_0$，$((p ∧ q′) ∨ (¬p ∧ ¬p′ ∧ ¬q′)))$为化简后的转换关系符号表示$f(R)$</p>
<p>$R$下$S$的预像记为$PreImage(S,R)$，定义为:$PreImage(T,R) = {s | ∃t ∈ T_▪ (s,t) ∈ R}$<br>$PreImage(S,R)$是由转换关系R的一步可以到达$S$中某个状态的所有状态的集合，给定T和R的符号表示T和R，$PreImage(T,R)$的符号表示为 $BDDPREIMAGE(T,R)$，计算公式如下:<br>$BDDPREIMAGE\bold{(T,R)} = ∃AP′ ▪ \bold{R} ∧ Prime(\bold{T})$</p>
<p>以$BDDPREIMAGE(\bold{T,R})$为例，其中$R$为s上图中Kripke结构的跃迁关系，$\bold{T} = {s_1,s_2}$:<br>$$<br>\begin{align*}<br>&amp;BDDPREIMAGE(T,R) \<br>&amp;= ∃p′,q′ ▪ ((p ∧ q′) ∨ (¬p ∧ ¬p′ ∧ ¬q′)) ∧ Prime(q)\<br>&amp;= ∃p′,q′ ▪ (p ∧ q′) ∧ q′\<br>&amp;= p = Bdd(f ({s0,s1}))\<br>\end{align*}<br>$$</p>
<h2 id="分区转换关系"><a href="#分区转换关系" class="headerlink" title="分区转换关系"></a>分区转换关系</h2><p>通常在实践中，即使$R, S$和$Image(S,R)$具有有效的BDD表示，中间结果也非常大。这通常被称为 图像计算的“驼峰”。在这种情况下，需要将转换关系$R$划分为一组BDDs，并直接对这样一个已分区的关系进行操作。</p>
<h3 id="析取分解-Disjunctive-Decomposition"><a href="#析取分解-Disjunctive-Decomposition" class="headerlink" title="析取分解 Disjunctive Decomposition"></a>析取分解 Disjunctive Decomposition</h3><p><strong>当R是几个转换关系异步组合的结果时</strong>，通常会出现这种情况。<br>存在量词下的析取：$∃X ▪ A ∨ B ⇐⇒ (∃X ▪ A) ∨ (∃X ▪ B)$<br>假设R为一组BDD的集合$\bold{R}=\bigvee\limits_{1\le i\le n }\bold{R}<em>i$<br>$$\begin{align*}<br>BDDIMAGE(S,R) &amp;= UnPrime(∃AP ▪ S ∧ R)\<br>&amp;= UnPrime\left(∃AP ▪ S ∧\left( \bigvee\limits</em>{1≤i≤n} R_i\right)\right) \<br>&amp;= \bigvee\limits_{1≤i≤n}\underbrace{UnPrime(∃AP ▪ S ∧ Ri)}<em>{done\ one\ \bold{R}<em>i\ at\ a time}\<br>\end{align*}<br>$$<br>$$\begin{align*}<br>BDDPREIMAGE(S,R) &amp;= ∃AP’ ▪ Prime(S) ∧ R\<br>&amp;= ∃AP’ ▪ Prime(S)\wedge \left( \bigvee\limits</em>{1≤i≤n} R_i\right) \<br>&amp;= \bigvee\limits</em>{1≤i≤n}\underbrace{∃AP’ ▪ Prime(S) \wedge \bold{ R_i}}_{done\ one\ \bold{R}_i\ at\ a time}\<br>\end{align*}<br>$$</p>
<h3 id="合取分解-Conjunctive-Decomposition"><a href="#合取分解-Conjunctive-Decomposition" class="headerlink" title="合取分解 Conjunctive Decomposition"></a>合取分解 Conjunctive Decomposition</h3><p><strong>当R是几个转换关系同步组合的结果时</strong>，通常会出现这种情况。<br>设X为一组变量，两个命题公式A、B且满足 $X\cap var(A) =\emptyset$。则$∃X ▪ A ∧ B ⇐⇒ A ∧ ∃X ▪ B$<br>假设R为一组BDD的集合 $\bold{R}=\bigwedge\limits_{1\le i\le n }\bold{R}<em>i$<br>$$\begin{align*}<br>BDDIMAGE(S,R) &amp;= UnPrime(∃AP ▪ S ∧ R)\<br>&amp;= UnPrime\left(∃AP ▪ S ∧\left( \bigwedge\limits</em>{1≤i≤n} R_i\right)\right) \<br>&amp;= UnPrime(∃V_1 ▪ (∃V_2 ▪ …∃Vn ▪ (S ∧ R_n)··· ∧ R_2) ∧ R1)\<br>&amp;\text{where, for}\ 1 ≤ i ≤ n,\ V_i = AP ∩ \left(Var(R_i)/ \bigcup\limits_{1≤j&lt;i}Var(R_j)\right)<br>\end{align*}<br>$$<br>$V_i$是原子命题p的集合，使得i是p出现在Ri中的最小值。<br>$$\begin{align*}<br>BDDPREIMAGE(S,R) &amp;= ∃AP’ ▪ Prime(S) ∧ R\<br>&amp;= ∃AP’ ▪ Prime(S)\wedge \left( \bigwedge\limits_{1≤i≤n} R_i\right) \<br>&amp;=  ∃V’<em>1 ▪ (∃V_2’ ▪ ···∃V_n’ ▪ (Prime(S) ∧ R_n)··· ∧ R_2) ∧ R1\<br>&amp; \text{where, for}\ 1 ≤ i ≤ n,\ V_i = AP’ ∩ \left(Var(R_i)/ \bigcup\limits</em>{1≤j&lt;i}Var(R_j)\right)\<br>\end{align*}<br>$$</p>
<h2 id="Kripke结构的Model-Checking-（！！！算法，对应书的P231）"><a href="#Kripke结构的Model-Checking-（！！！算法，对应书的P231）" class="headerlink" title="Kripke结构的Model Checking （！！！算法，对应书的P231）"></a>Kripke结构的Model Checking （！！！算法，对应书的P231）</h2><p>我们假设M是一组原子命题AP上的Kripke结构$(S,R,L)$(即 我们的模型系统)；R用BDD表示，M有一个指定的初始状态$s_0∈S$，用BDD $s_0$表示。</p>
<p>任何安全属性的模型检查都可以简化为表单$\bold{AG}p$的CTL公式的模型检查，其中p是单个原子命题。这是因为对任何安全属性的违反都可以简化为某些定义良好的坏状态的可达性。如果$M \models  \varphi$，则$\varphi$被称为$M$的一个不变量。<br>判断$M \models  \varphi$的算法如下：<br>工作原理是迭代计算从初始状态s0(第2-7行)可到达的状态集，然后检查是否存在不满足p (第8行)的可达状态。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.2z4cxjxt5t80.webp" alt="判断M |= AGp"></p>
<h3 id="CTL-Model-Checking"><a href="#CTL-Model-Checking" class="headerlink" title="CTL Model Checking"></a>CTL Model Checking</h3><p>每个CTL公式$\varphi$是一个状态公式。当且仅当M的初始状态$s_0$满足$\varphi$时，$M \models  \varphi$</p>
<p>将CTL的语法限制如下，其中$\varphi、\varphi_1、\varphi_2$为CTL公式，$p\in AP$:<br>$\varphi = p | ¬\varphi_1 | \varphi_1 ∧ \varphi_2 | EX\varphi_1 | EG\varphi_1 | E(\varphi_1 U \varphi_2)$。<br>用⊥和⊤分别表示$(p_0∧¬p_0)$和$¬⊥$，其中$p_0\in AP $是一个特殊的原子命题。其他操作符使用标准的等价符替换。见 <a href="#%E5%88%86%E6%94%AF%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91-%E8%AE%A1%E7%AE%97%E6%A0%91%E9%80%BB%E8%BE%91%EF%BC%88CTL%EF%BC%89">计算树逻辑（CTL)</a><br>CTL模型检测算法：<br>两步工作:</p>
<ul>
<li>使用辅助函数$CTLSTATES$来计算满足$\varphi$的关于M的状态集S;</li>
<li>当且仅当$s0∈S$时返回true。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.6vmcu84747o0.webp" alt="CTL模型检测算法"><blockquote>
<p>函数 <strong>EXSTATES(M,S)</strong> 使用章节中描述的<a href="#%E5%9B%BE%E5%83%8F%E8%BF%90%E7%AE%97">PreImage</a>方法计算S的前一状态集合。<br>函数 <strong>EGSTATES(M,S)</strong> 迭代地计算一个状态集，该状态集存在一个只包含集合S中的状态的路径。<br>函数 <strong>EUSTATES(M,S1,S2)</strong> 计算存在一条从S1到S2的路径的状态集。</p>
</blockquote>
</li>
</ul>
<h1 id="SAT求解器（Propositional-SAT-Solving）"><a href="#SAT求解器（Propositional-SAT-Solving）" class="headerlink" title="SAT求解器（Propositional SAT Solving）"></a>SAT求解器（Propositional SAT Solving）</h1><p>给定一个命题逻辑公式，确定是否存在一个变量赋值，使得公式的计算结果为真，这被称为布尔可满足性问题，通常缩写为SAT（Boolean Satisfiability Problem）。</p>
<ul>
<li>是一个NP完备问题。<ul>
<li>不太可能存在任意多项式的SAT算法</li>
<li>不排除找到足够高效的算法的可能性</li>
</ul>
</li>
<li>完整的SAT求解者可以找到一个解(即一个令人满意的变量赋值)或证明不存在解。对于许多其他领域，包括使用模型检查的验证，主要任务是证明实例的不可满足性</li>
<li>随机方法不能证明实例是不可满足的，即使他们可能能够为某些类型的可满足实例快速找到解决方案。<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2>布尔公式$\mathcal{F}$是在一组 命题变量是用标准逻辑连接词，¬，∧，∨归纳定义的，如下:</li>
<li>原子(atom)$x$是布尔公式。</li>
<li>如果$\mathcal{F}$是一个布尔公式，则$(¬\mathcal{F})$是一个布尔公式。(当$\mathcal{F}$表示一个原子$x$时，$¬\mathcal{F}$用$\overline{x}$表示。)</li>
<li>如果$\mathcal{F}$和$\mathcal{G}$是布尔公式，那么$(\mathcal{F}∨\mathcal{G})$也是布尔公式。</li>
<li>如果$\mathcal{F}$和$\mathcal{G}$为布尔公式，则$(\mathcal{F}∧\mathcal{G})$为布尔公式。</li>
</ul>
<p>表达方式：</p>
<ul>
<li>合取范式（ conjunctive normal form (CNF)）<br>任何命题公式，最终都能够化成$ (A 1 ∨A 2 )∧(A 3​ ∨A 4 ) $的形式</li>
<li>析取范式（disjunctive normal form (DNF)）<br>任何命题公式，最终都能够化成 $( A 1 ∧ A 2 ) ∨ ( A 3 ∧ A 4 )$的形式</li>
</ul>
<p>给定一个公式$\mathcal{F}$，一个真值赋值$\mathcal{ν}$是一个从变量$\mathcal{F}$到$ {0,1}$的映射，$\mathcal{ν}: var(\mathcal{F}) \mapsto {0,1}$。公式所取的值(公式结果)为$\mathcal{F^v}$</p>
<ul>
<li>如果存在一个字面量$l\in c$，使得$l^ν = 1$，则子句$c$是满足的（<em>satisfied</em>）。</li>
<li>如果所有$c$中的字面量取值都为0，则子句$c$是假的(<em>falsified</em>)。</li>
<li>除一个字面值赋值为0外，其余的字面值未赋值,那么这个子句是单元（<em>unit</em>）。</li>
<li>如果一个子句既没有 falsified ，也没有被satisfied，也没有unit，那么它就是未解决的unresolved。</li>
<li>如果所有子句都satisfied,那么CNF公式satisfied。如果有至少一个子句falsified,那么CNF公式falsified。</li>
<li>如果 $\mathcal{F^v} = 1$，则F的真值赋值是令人满意satisfying的(或简单地说是令人满意的真值赋值 a satisfying truth assignment)。公式F是可满足的前提是它有一个令人满意的真值赋值;否则是无法满足的。如果公式F是可满足的，则为$F \models\mkern-15mu/ ⊥$。如果公式F是 不满足的，则$F⊨⊥$。</li>
</ul>
<p>SAT求解器中的一个关键程序是单元子句规则unit clause rule:</p>
<ul>
<li>如果子句是单元，那么它唯一未赋值的字面量必须赋值1才能满足子句。</li>
<li>单元子句规则的迭代应用称为单元传播（unit propagation）或 布尔约束传播(BCP：Boolean constraint propagation)。</li>
<li>如果识别出一个falsified的子句，则声明冲突条件，且算法回溯。</li>
</ul>
<p>在CDCL SAT求解器中，每个变量x由许多属性来描述，包括值(value)、前项(antecedent)子句(或仅仅是前项)和决策级别(decision level)，分别用$ν(x)∈{0,u,1}， α(x)∈F∪{NIL}和 δ(x)∈{−1,0,1，…，| x |}$表示。</p>
<ul>
<li>一个变量x被作为应用单位子句规则的结果赋值，则被称为被推导的（implied）。用于推演变量x的单元子句c被认为是x的前项子句，$α(x) = c$。</li>
<li>变量x的决策级别表示该变量被赋值为{0,1}的决策树的深度。未分配变量x的决策水平为−1，$δ(x) =−1$。<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4pygyqzbdgg0.webp" alt="image"><br>上图示例中，除了决策级别0之外，一个决策文字与每个决策级别相关联。例如，对于决策 级别1，决策文字为w，表示w被赋值为1。给定推导图，可以从传入边推断给定推导赋值的前项。例如，b被赋值为 1，因为a和x被赋值为1。因此，b的先行项是$(\overline{x}\vee \overline{a}\vee \overline{b})$。<h2 id="CDCL-SAT-Solvers"><a href="#CDCL-SAT-Solvers" class="headerlink" title="CDCL SAT Solvers"></a>CDCL SAT Solvers</h2><h3 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h3><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.5vrsehez7qo0.webp" alt="image"></li>
</ul>
<p>算法1显示了CDCL SAT求解器的标准组织，它基本上遵循DPLL的组织。与DPLL主要的区别是每次识别冲突时调用CONFLICTANALYSIS函数 ，以及在发生回溯时调用BACKTRACK。此外，BACKTRACK过程允许非按时间顺序进行回溯</p>
<ul>
<li><strong>UNITPROPAGATION</strong>由单元子句规则的迭代应用组成。如果识别出falsified的子句，则返回冲突指示。</li>
<li><strong>PICKBRANCHINGVARIABLE</strong>由选择一个变量并为其赋值组成。</li>
<li><strong>CONFLICTANALYSIS</strong>包括分析最近的冲突，并从冲突中学习一个新的从句。</li>
<li><strong>BACKTRACK</strong>返回到由<strong>CONFLICTANALYSIS</strong>计算的决策级别。</li>
<li><strong>ALLVARIABLESASSIGNED</strong> 测试是否所有变量都已赋值，在这种情况下，算法终止，表明CNF公式是可满足的。<h3 id="Clause-Learning-and-Non-chronological-Backtracking"><a href="#Clause-Learning-and-Non-chronological-Backtracking" class="headerlink" title="Clause Learning and Non-chronological Backtracking"></a>Clause Learning and Non-chronological Backtracking</h3>算法2总结了冲突分析(和 学习)过程的主要步骤。输入参数是CNF公式和当前赋值集。</li>
<li>从⊥顶点(表示已证伪的子句)开始遍历当前决策级别上可推导的字面量。</li>
<li>对于每个遍历的字面量，将分析先行词中的字面量。<ul>
<li>在比当前决策级别低的决策级别分配的字面量将记录其补充字面量，</li>
<li>而在当前决策级别分配的字面量将被安排遍历。</li>
</ul>
</li>
<li>重复该过程直到访问当前决策级别的分支变量。</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4bis0lponxm0.webp" alt="image"></p>
<p>图2显示了一个产生冲突的单元传播的简单示例。x推出a，z推出a、b，a、b导致冲突发生。<br>图3显示了冲突学习算法的处理过程。从冲突节点⊥开始。a、b、 和z会被访问，因为它们都分配在决策级别3。记录的文字是$\overline{x}$和$\overline{z}$。因此，所创建的子句是$(\overline{x}∨\overline{z})$。<br>图4还显示了 回溯后的结果。<br>| <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.5ot3l2vup380.webp" alt="image"> | <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.768ldpz365k0.webp" alt="image"> | <img src="https://cdn.staticaly.com/gh/konsin/images@main/image.5mxjx2e2nv40.webp" alt="image"> |<br>| :——————————————————————————– | :——————————————————————————– | :——————————————————————————– |</p>
<h1 id="SAT-Based-Model-Checking"><a href="#SAT-Based-Model-Checking" class="headerlink" title="SAT-Based Model Checking"></a>SAT-Based Model Checking</h1><p>Modern satisfiability (SAT)求解器已成为许多模型检查器的核心技术。</p>
<ul>
<li>与基于bdd的模型 检查器相比，大大提高了容量。</li>
<li>SAT解算器通常能够解决比基于二进制决策图(bdd)的经典技术更大的公式</li>
<li>基于bdd的技术允许有效地实现量词消除，这对于符号定点算法中的终止检查至关重要。</li>
</ul>
<p>SAT-based bounded modelchecking (BMC) 有界模型检验？</p>
<ul>
<li>转换系统和属性的符号表示在给定的K个步骤中一起展开</li>
<li>如果存在长度k以内的反例，则得到一个可满足的公式。</li>
<li>然后，公式被传递给一个有效的SAT求解器。</li>
</ul>
<h2 id="Bounded-Model-Checking-on-Kripke-Structures"><a href="#Bounded-Model-Checking-on-Kripke-Structures" class="headerlink" title="Bounded Model Checking on Kripke Structures"></a>Bounded Model Checking on Kripke Structures</h2><p>这里仅限于线性时序逻辑(LTL)中给出的属性。<br><strong>安全属性(Safety Properties)</strong>:<br>$\bold{G}p$:对于这种性质，可以被给出满足¬p的状态s结束的有限路径作为反例。<br>$$<br>\exists s_{0}, \ldots, s_{k} . \quad I\left(s_{0}\right) \wedge \bigwedge_{i=0}^{k-1} T\left(s_{i}, s_{i+1}\right) \wedge \neg p\left(s_{k}\right) \quad(1)<br>$$<br>第一个连接符$I\left(s_{0}\right)$确保 状态$s_0$是初始状态之一。第二个连词对需求进行编码，即对于每个$i∈{0，…，k−1}$有从$s_i$到$s_{i+1}$的换。这相当于创建了转换关系T的k个副本。最后，连接符$\neg p\left(s_{k}\right)$断言状态$s_k$满足$¬p$ 。<br><strong>活跃属性(Liveness Properties)</strong>:<br>$\bold{F}p$:这种形式的属性的反例总是可以给出一个有限(可能是空的)前缀(称为词干)，后面跟着一个有限循环。路径上的所有状态满足¬p。<br>$$<br>\exists s_0,\ldots,s_k.\quad I(s_0)\wedge\bigwedge\limits_{i\equiv0}^{k-1}T(s_i,s_{i+1})\wedge\bigwedge\limits_{i=0}^{k-1}\neg p(s_i)\wedge\bigvee\limits_{i\equiv0}^{k-1}s_k=s_i\quad(2)<br>$$</p>
<h1 id="Combining-Model-Checking-and-Testing"><a href="#Combining-Model-Checking-and-Testing" class="headerlink" title="Combining Model Checking and Testing"></a>Combining Model Checking and Testing</h1><p>模型检查是一种基于穷举状态空间探索的形式验证<br>在实践中，验证保证往往是有限的：仅检查程序或程序模型的特定属性，在一些特定的环境假设下，检查本身通常是近似的。</p>
<p>模型检查应该更多地被视为“超级测试”，而不是严格数学意义上的形式验证：提供更好的覆盖范围，计算成本更高，在测试和正式验证之间提供了一个有吸引力的实际权衡</p>
<p>模型检查的关键实用优势在于，它能够发现极其难以发现的bug</p>
<p>软件模型检查的两种主要方法：<br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.3yfq5h4zvai0.webp" alt="image"></p>
<ul>
<li>一种方法使用抽象 abstraction:它包括通过静态分析其代码自动从软件应用程序中提取抽象模型，然后使用传统的模型检查算法分析该模型。</li>
<li>另一种方法使用适配adaptation:包括将模型检查调整为一种适用于工业规模软件的系统测试形式</li>
</ul>
<h2 id="顺序软件的系统测试"><a href="#顺序软件的系统测试" class="headerlink" title="顺序软件的系统测试"></a>顺序软件的系统测试</h2><p>符号执行是指用符号值而不是具体值执行程序。赋值语句表示为其(符号)参数的函数，而条件语句 表示为对符号值的约束。可用于错误检测、程序修复、调试、维护和故障本地化。</p>
<h3 id="测试生成的方式："><a href="#测试生成的方式：" class="headerlink" title="测试生成的方式："></a>测试生成的方式：</h3><ul>
<li>静态测试生成是对程序进行静态分析的过程符号执行技术，试图计算驱动器的输入P沿着特定的执行路径或分支，而无需执行程序。<ul>
<li><strong>静态测试生成</strong>不能通过条件语句的任何分支生成测试输入来驱动 程序模糊的执行:静态测试 生成对于这样的程序是无用的。</li>
</ul>
</li>
<li><strong>动态测试生成</strong>执行程序p，它由执行程序P组成，通常从一些随机输入开始，同时动态执行符号执行，在执行过程中从分支语句中的谓词收集输入上的符号约束，然后使用约束求解器推断出前一个输入的变体，以便引导程序的下一次执行转向替代程序分支。<ul>
<li>符号执行现在是具体执行的附属品。</li>
<li>使用具体值和随机化可以缓解符号执行的不精确性</li>
<li>动态测试生成是目前已知的最精确的代码驱动测试生成形式</li>
</ul>
</li>
</ul>
<p><strong>动态测试生成示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">obscure</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="built_in">hash</span>(y)) <span class="built_in">abort</span>(); <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最初x =33. y = 42. </li>
<li>假设hash(y)=567，路径约束变为$\phi_{\rho}=(x \neq 567)$</li>
<li>新的输入向量x=567.y=42</li>
</ul>
<p><strong>动态测试生成示例2：</strong><br><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.4wr93lcevtw0.webp" alt="image"><br>考虑图5所示的函数h。函数h是有缺陷的，因为它对其输入向量 (由输入参数x和y组成)的某个值可能导致中止。但使用随机值运行x和y的程序不太可能发现错误。</p>
<ul>
<li>最初，x=269167349,y=889801541</li>
<li>符号动态执行产生路径约束$\phi_{\rho}=(x\neq y)\wedge(2\cdot x\neq x+10)$。</li>
<li>对当前路径约束的最后一个约束求反得到约束 $\phi_{\rho}’=(x\neq y)\wedge(2\cdot x= x+10)$</li>
<li>新的路径约束的解是(x = 10,y = 889801541)。</li>
</ul>
<h3 id="优势与局限"><a href="#优势与局限" class="headerlink" title="优势与局限"></a>优势与局限</h3><p>优势：</p>
<ul>
<li>即使定向搜索通常不能在合理的时间内探索大型程序的所有可行路径，但它通常比纯随机测试获得更好的覆盖率，因此可以发现新的程序错误。</li>
<li>可以增量地实现</li>
</ul>
<p>在高层次上，系统动态测试生成受到两个主要限制:</p>
<ul>
<li>沿个别路径符号执行的频繁不精确，以及</li>
<li>通常需要探索的大量路径，或者路径爆炸。</li>
</ul>
<p>挑战</p>
<ul>
<li>从符号执行的不精确中恢复</li>
<li>将符号执行扩展到数十亿条指令，有效地检查许多属性</li>
<li>有关指针、不同大小的输入、浮点指令、无限循环的原因</li>
<li>优先搜索</li>
<li>跨代码更改重用以前的分析结果</li>
</ul>
<h2 id="数据输入并发软件的系统测试"><a href="#数据输入并发软件的系统测试" class="headerlink" title="数据输入并发软件的系统测试"></a>数据输入并发软件的系统测试</h2><p><a href="http://osl.cs.illinois.edu/software/jcute/">jCUTE</a>是一种动态测试生成技术：</p>
<ul>
<li>生成一个随机输入和一个计划，计划指定线程的执行顺序</li>
<li>回溯并生成一个新的调度或新的输入，并再次执行程序</li>
<li>继续执行，直到使用深度优先搜索策略探索了所有可能的不同执行路径</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/konsin/images@main/image.6ov8yqs3cn40.webp" alt="image"></p>
<ol>
<li>Z=2345354且顺序$(t_1,1) (t_2,, 1) (t_2,2)$是约束$〈2 ∗ z_0 + 1! = 2〉$的唯一执行路径</li>
<li>约束求反$2 * z_0 +1 = 2$，仍无解</li>
<li>回溯并生成一个调度，以便下一次执行变成$(t_2,, 1) (t_2,2)(t_1,1) $</li>
<li>再次回溯(t2,1)(t1,1)(t2,2) 路径约束为$〈2 ∗ z_0 + 1! = 3〉$</li>
<li>负约束$2 ∗ z0 + 1 = 3$有解$z0 = 1$</li>
<li>(t2,1)(t1,1)(t2,2)(t2,3)导致中止</li>
</ol>
<h1 id="反例引导的抽象细化-CEGAR-CounterExample-Guided-Abstraction-Refinement"><a href="#反例引导的抽象细化-CEGAR-CounterExample-Guided-Abstraction-Refinement" class="headerlink" title="反例引导的抽象细化 (CEGAR:CounterExample-Guided Abstraction Refinement)"></a>反例引导的抽象细化 (CEGAR:CounterExample-Guided Abstraction Refinement)</h1><p>书13.5章</p>
<h1 id="Partial-Order-Reduction"><a href="#Partial-Order-Reduction" class="headerlink" title="Partial-Order Reduction"></a>Partial-Order Reduction</h1><p>书6章</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>使用PySide为树莓派创建应用</title>
    <url>/2023/05/24/%E4%BD%BF%E7%94%A8PySide%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="树莓派设置QT程序自启动"><a href="#树莓派设置QT程序自启动" class="headerlink" title="树莓派设置QT程序自启动"></a>树莓派设置QT程序自启动</h1><p>修改rc.local或者systemcmd注册服务的方式启动<code>PySide</code>编写的窗口应用会出现错误</p>
<blockquote>
<p>qt.qpa.xcb: could not connect to display</p>
</blockquote>
<p>因此这并不是一个很好的方式，而树莓派的系统中提供了另一种应用自启动的方式：<br>在<code>/home/XXX/.config/autostart</code>目录下创建<code>.desktop</code>文件可以实现桌面应用程序的自动执行。如下为文件书写格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=app_name</span><br><span class="line">Comment=app_comment</span><br><span class="line">Exec=正常的执行程序的shell指令</span><br><span class="line">Icon=图标文件（非必须）</span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">MultipleArgs=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br><span class="line">StartupNotify=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="pyqt或者pyside实现将SVG显示在Label的方法。"><a href="#pyqt或者pyside实现将SVG显示在Label的方法。" class="headerlink" title="pyqt或者pyside实现将SVG显示在Label的方法。"></a>pyqt或者pyside实现将SVG显示在Label的方法。</h1><p>如果不需要对SVG进行修改可以直接使用修改styleSheet的方式，添加属性为<code>image:url()</code>。<br>如果需要调整SVG尺寸或者颜色，可以参考如下方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convertSVGtoImg</span>(<span class="params">self, src, size:QSize</span>) -&gt;QPixmap:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param src: SVG路径</span></span><br><span class="line"><span class="string">    :type src: _type_</span></span><br><span class="line"><span class="string">    :param size: 生成图片大小</span></span><br><span class="line"><span class="string">    :type size: QSize</span></span><br><span class="line"><span class="string">    :return: 返回处理后的SVG图片</span></span><br><span class="line"><span class="string">    :rtype: QPixmap</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    svg_remder = QSvgRenderer(src)</span><br><span class="line"></span><br><span class="line">    image = QImage(size, QImage.Format.Format_ARGB32_Premultiplied)</span><br><span class="line">    image.fill(Qt.transparent)</span><br><span class="line">    painter = QPainter(image)</span><br><span class="line">    painter.setRenderHints(QPainter.Antialiasing|QPainter.TextAntialiasing| QPainter.SmoothPixmapTransform)</span><br><span class="line">    svg_remder.render(painter)</span><br><span class="line">    pix = QPixmap() </span><br><span class="line">    painter.end()    </span><br><span class="line">    pix=pix.fromImage(image) </span><br><span class="line">    <span class="keyword">return</span> pix</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convertSVGtoImg</span>(<span class="params">self, src, size:QSize, color:QColor</span>) -&gt;QPixmap:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param src: SVG路径</span></span><br><span class="line"><span class="string">    :type src: _type_</span></span><br><span class="line"><span class="string">    :param size: 生成图片大小</span></span><br><span class="line"><span class="string">    :type size: QSize</span></span><br><span class="line"><span class="string">    :param color: 要更改的颜色</span></span><br><span class="line"><span class="string">    :type color: QColor</span></span><br><span class="line"><span class="string">    :return: 返回处理后的SVG图片</span></span><br><span class="line"><span class="string">    :rtype: QPixmap</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    svg_remder = QSvgRenderer(src)</span><br><span class="line"></span><br><span class="line">    image = QImage(size, QImage.Format.Format_ARGB32_Premultiplied)</span><br><span class="line">    image.fill(Qt.transparent)</span><br><span class="line">    painter = QPainter(image)</span><br><span class="line">    painter.setRenderHints(QPainter.Antialiasing|QPainter.TextAntialiasing| QPainter.SmoothPixmapTransform)</span><br><span class="line">    svg_remder.render(painter)</span><br><span class="line">    pix = QPixmap() </span><br><span class="line">    painter.end()   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(image.width()):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(image.height()): </span><br><span class="line">                    <span class="keyword">if</span>(image.pixelColor(i,j) != Qt.transparent ):</span><br><span class="line">                            image.setPixelColor(i,j,color)   </span><br><span class="line">    pix=pix.fromImage(image) </span><br><span class="line">    <span class="keyword">return</span> pix  </span><br></pre></td></tr></table></figure>

<h1 id="pyqt-pyside中定时器的使用"><a href="#pyqt-pyside中定时器的使用" class="headerlink" title="pyqt|pyside中定时器的使用"></a>pyqt|pyside中定时器的使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个计时器</span></span><br><span class="line">self.timeRefresh = QTimer()</span><br><span class="line"><span class="comment">#连接处理函数</span></span><br><span class="line">self.timeRefresh.timeout.connect(self.refreshTime) </span><br><span class="line"><span class="comment">#开启循环计时</span></span><br><span class="line">self.timeRefresh.start(<span class="number">1000</span>) </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果只需要单次计时</span></span><br><span class="line"><span class="string">self.weatherRefresh.setSingleShot(True)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="树莓派中pyside的安装"><a href="#树莓派中pyside的安装" class="headerlink" title="树莓派中pyside的安装"></a>树莓派中pyside的安装</h1><p>树莓派中目前只有pyside2，并且在官方的 Ubuntu 和 Debian 存储库中。每个Pyside模块都是一个单独的包。所以安装时也需要一个个安装这些组件。一行命令搞定全部组件：<br><code>sudo apt-get install python3-pyside2.qt3dcore python3-pyside2.qt3dinput python3-pyside2.qt3dlogic python3-pyside2.qt3drender python3-pyside2.qtcharts python3-pyside2.qtconcurrent python3-pyside2.qtcore python3-pyside2.qtgui python3-pyside2.qthelp python3-pyside2.qtlocation python3-pyside2.qtmultimedia python3-pyside2.qtmultimediawidgets python3-pyside2.qtnetwork python3-pyside2.qtopengl python3-pyside2.qtpositioning python3-pyside2.qtprintsupport python3-pyside2.qtqml python3-pyside2.qtquick python3-pyside2.qtquickwidgets python3-pyside2.qtscript python3-pyside2.qtscripttools python3-pyside2.qtsensors python3-pyside2.qtsql python3-pyside2.qtsvg python3-pyside2.qttest python3-pyside2.qttexttospeech python3-pyside2.qtuitools python3-pyside2.qtwebchannel python3-pyside2.qtwebsockets python3-pyside2.qtwidgets python3-pyside2.qtx11extras python3-pyside2.qtxml python3-pyside2.qtxmlpatterns </code></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>配置教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QT</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
</search>
